
rom.s

    1 A:1000                                    ;
    2 A:1000                                    ; haiku6502 ROM
    3 A:1000                                    ;
    4 A:1000                                    ; Annotated and modified emulator ROM using orig_monitor_rom.s as a template.
    5 A:1000                                    ; This code is only for academic purposes.
    6 A:1000                                    ; This file is compatible with xa assembler and is not relocatable.
    7 A:1000                                    ; Care has to be taken to keep the "go" jump table addresses area on page 0xFE or else it will cease to work this way.
    8 A:1000                                    ; There are a few nifty tricks in the original assembler code to save a few bytes here and there that probably
    9 A:1000                                    ; would not have been done this way were there more than 12KB address space available for ROM.
   10 A:1000                                    ;
   11 A:1000                                    ; The following modifications have been made
   11 A:1000                                    
   12 A:1000                                    ;
   13 A:1000                                    ; - fixed character mapping. ASCII chars are now ASCII chars in the right code points.
   14 A:1000                                    ; - removed memory mapped text and graphics screens. The screen is now a terminal peripheral controlled
   15 A:1000                                    ;   through I/O ports 0xC010-0xC01F
   16 A:1000                                    ; - keyboard strobe is now in 0xC001, to make space for more i/o control addresses
   17 A:1000                                    ; - removed screen address calculations, no longer needed with sane terminal cursor coordinates that
   18 A:1000                                    ;   are no longer aligned with cathode ray tube electronic beam scan sequence.
   19 A:1000                                    ; - Bell just sends a CTL-G to terminal
   20 A:1000                                    ; - Tape in/out goes to a tape file. with the right sampling rate, it should be possible to read in data tapes.
   21 A:1000                                    ;   not much use though, since the rom routine addresses are now no longer compatible.
   22 A:1000                                    ; - The screen size is taken from the terminal dimensions. Size is no longer restricted to 1KB text pages.
   23 A:1000                                    ; - Lo-Res and Hi-Res graphics modes are gone for now since they don't work too well with the standard ncurses based
   24 A:1000                                    ;   terminal peripheral. A graphics terminal peripheral could be added, though.
   25 A:1000                                    ; - The peripheral system is not completed, especially emulator interrupt management is rudimentary. So peripheral
   26 A:1000                                    ;   rom areas can be addressed, but the extension rom area 0xC800-0xC8FF needs work. This does not ffect this rom,
   27 A:1000                                    ;   though...
   28 A:1000                                    ;
   29 A:1000                                    ; The monitor part works pretty much the same as described in the Apple II Reference Manual. It has a nice disassembler.
   30 A:1000                                    ; It provides RAM editing as hex dump only for now.
   31 A:1000                                    ;
   32 A:1000                                    ; Memory layout
   32 A:1000                                    
   33 A:1000                                    ;
   34 A:1000                                    ; 0x0000-0x00FF Zero page
   35 A:1000                                    ; 0x0100-9x01FF Stack
   36 A:1000                                    ; 0x0200-0x02FF text buffer
   37 A:1000                                    ; 0x0300-0x03FF system vars & vectors
   38 A:1000                                    ; 0x0400-0xBFFF free RAM
   39 A:1000                                    ; 0xC000-0xCFFF I/O
   40 A:1000                                    ; 0xD000-0xFFFF ROM; thereof
   41 A:1000                                    ;               0xD000 - 0xF800 Reserved for language modules
   42 A:1000                                    ;               0xF800 - 0xFFFF System Monitor ROM
   43 A:1000                                    ;               0xFFFA - 0xFFFF Hardwired 6502 NMI, Reset and IRQ vectors, have to be kept at fixed addresses.
   44 A:1000                                    ; On Reset, the program counter is loaded from 0xFFFC and 0xFFFD. all addresses with least
   45 A:1000                                    ; significant (lsb,low) byte first.
   46 A:1000                                    ;
   47 A:1000                                    ; TODO Fix remaining bugs, cleanup code
   48 A:1000                                    ;

   50 A:1000                                     .include "symbols.inc"

symbols.inc

    1 A:1000                                    ; common symbol definitions, borrowed from
    2 A:1000                                    ; 1979 Apple ][ Reference Manual, Monitor ROM Listing

    4 A:1000                                    loc0=$00
    5 A:1000                                    loc1=$01
    6 A:1000                                    wndlft=$20
    7 A:1000                                    wndwdth=$21
    8 A:1000                                    wndtop=$22
    9 A:1000                                    wndbtm=$23
   10 A:1000                                    ch=$24
   11 A:1000                                    cv=$25
   12 A:1000                                    h2=$2c
   13 A:1000                                    lmnem=$2c
   14 A:1000                                    rtnl=$2c
   15 A:1000                                    v2=$2d
   16 A:1000                                    rmnem=$2d
   17 A:1000                                    rtnh=$2d
   18 A:1000                                    mask=$2e
   19 A:1000                                    chksum=$2e
   20 A:1000                                    format=$2e
   21 A:1000                                    lastin=$2f
   22 A:1000                                    length=$2f
   23 A:1000                                    sign=$2f
   24 A:1000                                    color=$30
   25 A:1000                                    mode=$31
   26 A:1000                                    invflg=$32
   27 A:1000                                    prompt=$33
   28 A:1000                                    ysav=$34
   29 A:1000                                    ysav1=$35
   30 A:1000                                    cswl=$36           ; CSW character out vector
   31 A:1000                                    cswh=$37
   32 A:1000                                    kswl=$38           ; keyboard input vector
   33 A:1000                                    kswh=$39
   34 A:1000                                    pcl=$3a
   35 A:1000                                    pch=$3b
   36 A:1000                                    xqt=$3c
   37 A:1000                                    xqtnz=$3c
   38 A:1000                                    a1l=$3c
   39 A:1000                                    a1h=$3d
   40 A:1000                                    a2l=$3e
   41 A:1000                                    a2h=$3f
   42 A:1000                                    a3l=$40
   43 A:1000                                    a3h=$41
   44 A:1000                                    a4l=$42
   45 A:1000                                    a4h=$43
   46 A:1000                                    a5l=$44
   47 A:1000                                    a5h=$45
   48 A:1000                                    acc=$45
   49 A:1000                                    xreg=$46
   50 A:1000                                    yreg=$47
   51 A:1000                                    status=$48
   52 A:1000                                    spnt=$49
   53 A:1000                                    rndl=$4e           ; pseudo-random
   54 A:1000                                    rndh=$4f
   55 A:1000                                    acl=$50
   56 A:1000                                    ach=$51
   57 A:1000                                    xtndl=$52
   58 A:1000                                    xtndh=$53
   59 A:1000                                    auxl=$54
   60 A:1000                                    auxh=$55
   61 A:1000                                    in=$0200           ; input buffer base
   62 A:1000                                    usradr=$03f8
   63 A:1000                                    nmiloc=$03fb
   64 A:1000                                    irqloc=$03fe
   65 A:1000                                    ioadr=$c000
   66 A:1000                                    kbd=$c000
   67 A:1000                                    kbdstrb=$c001
   68 A:1000                                    termcy=$c010           ; terminal cursor y   RW
   69 A:1000                                    termcx=$c011           ; terminal cursor x   RW
   70 A:1000                                    termout=$c012           ; termout character under cursor RW
   71 A:1000                                    termesc=$c013           ; terminal connamd byte W
   72 A:1000                                    termea1=$c014           ; terminal command argl   (bad design, will change)
   73 A:1000                                    termea2=$c015           ; terminal command argh
   74 A:1000                                    termwh=$c016           ; temrinal window height
   75 A:1000                                    termww=$c017           ; terminal window width

   77 A:1000                                    tapeout=$c020
   78 A:1000                                    spkr=$c030
   79 A:1000                                    txtclr=$c050
   80 A:1000                                    txtset=$c051
   81 A:1000                                    mixclr=$c052
   82 A:1000                                    mixset=$c053
   83 A:1000                                    lowscr=$c056
   84 A:1000                                    hiscr=$c057
   85 A:1000                                    lores=$c056
   86 A:1000                                    hires=$c057
   87 A:1000                                    tapein=$c060
   88 A:1000                                    paddl0=$c061
   89 A:1000                                    ptrig=$c070

   91 A:1000                                    ;
   92 A:1000                                    ;  Ecape commands for terminal
   92 A:1000                                    
   93 A:1000                                    ;
   94 A:1000                                    t_cls=$00           ; Clear screen
   95 A:1000                                    t_cll=$01           ; clear from cursor to end of line
   96 A:1000                                    t_clb=$02           ; clear from cursor to end of line
   97 A:1000                                    t_scr=$03           ; scroll one line up
   98 A:1000                                    t_norm=$04           ; normal chars
   99 A:1000                                    t_inv=$05           ; inverse chars
  100 A:1000                                    t_blnk=$06           ; blinking chars
  101 A:1000                                    t_qcch=$07           ; query current character under cursor

  103 A:1000                                    ; t_qy    = $04   ; query terminal cursor y; for result read terminl,h
  104 A:1000                                    ; t_qx    = $05   ; query terminal cursor x; for result read terminl,h

  106 A:1000                                    ; characters
  107 A:1000                                    k_ctl_a=$01
  108 A:1000                                    k_ctl_b=$02
  109 A:1000                                    k_ctl_c=$03
  110 A:1000                                    k_ctl_d=$04
  111 A:1000                                    k_ctl_e=$05
  112 A:1000                                    k_ctl_f=$06
  113 A:1000                                    k_ctl_g=$07
  114 A:1000                                    k_bs=$08
  115 A:1000                                    k_tab=$09
  116 A:1000                                    k_lf=$0a
  117 A:1000                                    k_ctl_k=$0b
  118 A:1000                                    k_ctl_l=$0c
  119 A:1000                                    k_cr=$0a
  120 A:1000                                    k_ctl_n=$0e
  121 A:1000                                    k_ctl_o=$0f
  122 A:1000                                    k_ctl_p=$10
  123 A:1000                                    k_ctl_q=$11
  124 A:1000                                    k_ctl_r=$12
  125 A:1000                                    k_ctl_s=$13
  126 A:1000                                    k_ctl_t=$14
  127 A:1000                                    k_ctl_u=$15
  128 A:1000                                    k_ctl_v=$16
  129 A:1000                                    k_ctl_w=$17
  130 A:1000                                    k_ctl_x=$18
  131 A:1000                                    k_ctl_y=$19
  132 A:1000                                    k_ctl_z=$1a
  133 A:1000                                    k_esc=$1b
  134 A:1000                                    k_entr=k_cr
  135 A:1000                                    gr_top='+'
  136 A:1000                                    gr_btm='_'
  137 A:1000                                    gr_grid=$61

rom.s

    1 A:1000                                     *= $d000              ; ROM start address

   52 A:d000  00 ff 00 10 00 24 2c ...           .dsb $1000,$00        ; first filler, 4KB low ROM
   53 A:e000                           lang      
   53 A:e000  20 06 e0                           jsr lang_init
   54 A:e003                           lang2     
   54 A:e003  4c 07 e0                           jmp lang_cont
   55 A:e006                           lang_init 
   55 A:e006  60                                 rts 
   56 A:e007                           lang_cont 
   56 A:e007  00 ff f9 17 00 24 2c ...           .dsb $17f9,$00        ; filler up to F800
   57 A:f800                                     *= $f800
   58 A:f800                           plot      
   58 A:f800  4a                                 lsr                    ; Well, 2 blocks per char in low res graphics. need to find the right char to plot.
   59 A:f801  8d 10 c0                           sta termcy                ; set y pos in accu to terminal
   60 A:f804  8c 11 c0                           sty termcx                ; set x pos in y register to terminal
   61 A:f807  a9 61                              lda #gr_grid               ; dec grid char
   62 A:f809  8d 12 c0                           sta termout
   63 A:f80c  60                                 rts 
   64 A:f80d                           hline     
   64 A:f80d  20 00 f8                           jsr plot                ; plot square
   65 A:f810                           hline1    
   65 A:f810  c4 2c                              cpy h2                ; done?
   66 A:f812  b0 11                              bcs rts1                ;   yes, return
   67 A:f814  c8                                 iny                    ;   no, incr x-coord index
   68 A:f815  20 00 f8                           jsr plot                ; plot next square
   69 A:f818  90 f6                              bcc hline1                ; always taken
   70 A:f81a                           vlinez    
   70 A:f81a  69 01                              adc #$01             ; next y-coord
   71 A:f81c                           vline     
   71 A:f81c  48                                 pha                    ;  save y-coord in a on stack
   72 A:f81d  20 00 f8                           jsr plot                ; plot square
   73 A:f820  68                                 pla 
   74 A:f821  c5 2d                              cmp v2                ; done?
   75 A:f823  90 f5                              bcc vlinez                ;   no, loop
   76 A:f825                           rts1      
   76 A:f825  60                                 rts 
   77 A:f826                           clrscr    
   77 A:f826  a0 2f                              ldy #$2f             ; max y, full scrn clr
   78 A:f828  d0 02                              bne clrsc2                ; always taken
   79 A:f82a                           clrtop    
   79 A:f82a  a0 27                              ldy #$27             ; max y, top scrn clr
   80 A:f82c                           clrsc2    
   80 A:f82c  84 2d                              sty v2                ; store as bottom coord for vline calls
   81 A:f82e  a0 27                              ldy #$27             ; rightmost x.coord (column)
   82 A:f830                           clrsc3    
   82 A:f830  a9 00                              lda #$00             ; top coord for vline calls
   83 A:f832  85 30                              sta color                ; clear color (black)
   84 A:f834  20 1c f8                           jsr vline                ; draw vline
   85 A:f837  88                                 dey                    ; next leftmost x-coord
   86 A:f838  10 f6                              bpl clrsc3                ; loop until done
   87 A:f83a  60                                 rts 
   88 A:f83b                           nxtcol    
   88 A:f83b  a5 30                              lda color                ; increment color by 3
   89 A:f83d  18                                 clc 
   90 A:f83e  69 03                              adc #$03
   91 A:f840                           setcol    
   91 A:f840  29 0f                              and #$0f             ; sets color = 17*A mod 16
   92 A:f842  85 30                              sta color
   93 A:f844  0a                                 asl 
   94 A:f845  0a                                 asl 
   95 A:f846  0a                                 asl 
   96 A:f847  0a                                 asl                    ; << 4 = *16
   97 A:f848  05 30                              ora color                ; + 1
   98 A:f84a  85 30                              sta color
   99 A:f84c  60                                 rts 
  100 A:f84d                           scrn      
  100 A:f84d  a9 00                              lda #$00             ; gone.
  101 A:f84f  60                                 rts 
  102 A:f850                           selnibl   
  102 A:f850  90 04                              bcc rtmaskz                ; if even, use low nibble else use high nibble (was scrn2)
  103 A:f852  4a                                 lsr 
  104 A:f853  4a                                 lsr 
  105 A:f854  4a                                 lsr                    ; shift high nibble into low nibble
  106 A:f855  4a                                 lsr 
  107 A:f856                           rtmaskz   
  107 A:f856  29 0f                              and #$0f             ; mask lower 4 bits
  108 A:f858  60                                 rts 
  109 A:f859                           insds1    
  109 A:f859  a6 3a                              ldx pcl                ; print pcl,h
  110 A:f85b  a4 3b                              ldy pch
  111 A:f85d  20 9e fd                           jsr pryx2
  112 A:f860  20 1f f9                           jsr prblnk                ; followed by a blank
  113 A:f863  a1 3a                              lda (pcl,x)
  114 A:f865                           insds2    
  114 A:f865  a8                                 tay 
  115 A:f866  4a                                 lsr                    ; even / odd test
  116 A:f867  90 09                              bcc ieven
  117 A:f869  6a                                 ror                    ; bit 1 test
  118 A:f86a  b0 10                              bcs err                ; xxxxxx11 invalid opcode
  119 A:f86c  c9 a2                              cmp #$a2
  120 A:f86e  f0 0c                              beq err                ; opcode 89 invalid
  121 A:f870  29 87                              and #$87             ; mask bits
  122 A:f872                           ieven     
  122 A:f872  4a                                 lsr                    ; lsb into carry for l/r test
  123 A:f873  aa                                 tax 
  124 A:f874  bd 39 f9                           lda fmt1,x              ; get format index byte
  125 A:f877  20 50 f8                           jsr selnibl                ; r/l h-byte on carry
  126 A:f87a  d0 04                              bne getfmt
  127 A:f87c                           err       
  127 A:f87c  a0 80                              ldy #$80             ; substitute $80 for invalid ops
  128 A:f87e  a9 00                              lda #$00             ; set print format index to 0
  129 A:f880                           getfmt    
  129 A:f880  aa                                 tax 
  130 A:f881  bd 7d f9                           lda fmt2,x              ; index into print format table
  131 A:f884  85 2e                              sta format                ; save for addr field formatting
  132 A:f886  29 03                              and #$03             ; mask for 2-bit length
  133 A:f888                                    ; (P=1 byte, 1=2 byte, 2=3 byte)
  134 A:f888  85 2f                              sta length
  135 A:f88a  98                                 tya                    ; opcode
  136 A:f88b  29 8f                              and #$8f             ; mask for 1xxx1010 test
  137 A:f88d  aa                                 tax                    ;  save it
  138 A:f88e  98                                 tya                    ; opcode to a again
  139 A:f88f  a0 03                              ldy #$03
  140 A:f891  e0 8a                              cpx #$8a
  141 A:f893  f0 0b                              beq mnndx3
  142 A:f895                           mnndx1    
  142 A:f895  4a                                 lsr 
  143 A:f896  90 08                              bcc mnndx3                ; form index into mnemonic tble
  144 A:f898  4a                                 lsr 
  145 A:f899                           mnndx2    
  145 A:f899  4a                                 lsr                    ; 1)  1xxx1010 => 00101xxx
  146 A:f89a  09 20                              ora #$20             ; 2)  xxxyyy01 => 00111xxx
  147 A:f89c  88                                 dey                    ; 3)  xxxyyy10 => 00110xxx
  148 A:f89d  d0 fa                              bne mnndx2                ; 4)  xxxyy100 => 00100xxx
  149 A:f89f  c8                                 iny                    ; 5)  xxxxx000 => 000xxxxx
  150 A:f8a0                           mnndx3    
  150 A:f8a0  88                                 dey 
  151 A:f8a1  d0 f2                              bne mnndx1
  152 A:f8a3  60                                 rts 
  153 A:f8a4  ff ff ff                           .byt $ff,$ff,$ff  ; ???
  154 A:f8a7                           instdsp   
  154 A:f8a7  20 59 f8                           jsr insds1                ; gen fmt, len bytes
  155 A:f8aa  48                                 pha                    ; save mnemonic table index
  156 A:f8ab                           prntop    
  156 A:f8ab  b1 3a                              lda (pcl),y
  157 A:f8ad  20 e2 fd                           jsr prbyte
  158 A:f8b0  a2 01                              ldx #$01             ; print 2 blanks
  159 A:f8b2                           prntbl    
  159 A:f8b2  20 21 f9                           jsr prbl2
  160 A:f8b5  c4 2f                              cpy length                ; print inst (1-3 bytes)
  161 A:f8b7  c8                                 iny                    ; in a 12 char field
  162 A:f8b8  90 f1                              bcc prntop
  163 A:f8ba  a2 03                              ldx #$03             ; char count for mnemonic print
  164 A:f8bc  c0 04                              cpy #$04
  165 A:f8be  90 f2                              bcc prntbl
  166 A:f8c0  68                                 pla                    ; recover mnemonic index
  167 A:f8c1  a8                                 tay 
  168 A:f8c2  b9 97 f9                           lda mneml,y
  169 A:f8c5  85 2c                              sta lmnem                ; fetch 3 char mnemonic
  170 A:f8c7  b9 d7 f9                           lda mnemr,y              ;   (packed in 2 bytes, only chars A-Z
  171 A:f8ca  85 2d                              sta rmnem
  172 A:f8cc                           prmn1     
  172 A:f8cc  a9 00                              lda #$00
  173 A:f8ce  a0 05                              ldy #$05
  174 A:f8d0                           prnm2     
  174 A:f8d0  06 2d                              asl rmnem                ; shift 5 bits of
  175 A:f8d2  26 2c                              rol lmnem                ;   character into Accu
  176 A:f8d4  2a                                 rol                    ;      (clears carry)
  177 A:f8d5  88                                 dey 
  178 A:f8d6  d0 f8                              bne prnm2
  179 A:f8d8  69 3f                              adc #'?'             ; add "?" offset
  180 A:f8da  20 f5 fd                           jsr cout                ; output a char of mnem
  181 A:f8dd  ca                                 dex 
  182 A:f8de  d0 ec                              bne prmn1
  183 A:f8e0  20 1f f9                           jsr prblnk                ; output 3 blanks
  184 A:f8e3  a4 2f                              ldy length
  185 A:f8e5  a2 06                              ldx #$06             ; count for 6 format bits
  186 A:f8e7                           pradr1    
  186 A:f8e7  e0 03                              cpx #$03
  187 A:f8e9  f0 1c                              beq pradr5                ; if x=3 then addr
  188 A:f8eb                           pradr2    
  188 A:f8eb  06 2e                              asl format
  189 A:f8ed  90 0e                              bcc pradr3
  190 A:f8ef  bd 8a f9                           lda char1-1,x
  191 A:f8f2  20 f5 fd                           jsr cout
  192 A:f8f5  bd 90 f9                           lda char2-1,x
  193 A:f8f8  f0 03                              beq pradr3
  194 A:f8fa  20 f5 fd                           jsr cout
  195 A:f8fd                           pradr3    
  195 A:f8fd  ca                                 dex 
  196 A:f8fe  d0 e7                              bne pradr1
  197 A:f900  60                                 rts 
  198 A:f901                           pradr4    
  198 A:f901  88                                 dey 
  199 A:f902  30 e7                              bmi pradr2
  200 A:f904  20 e2 fd                           jsr prbyte
  201 A:f907                           pradr5    
  201 A:f907  a5 2e                              lda format
  202 A:f909  c9 e8                              cmp #$e8             ; handle relative address mode
  203 A:f90b  b1 3a                              lda (pcl),y            ;  special (print target, not offset)
  204 A:f90d  90 f2                              bcc pradr4
  205 A:f90f                           reladr    
  205 A:f90f  20 2d f9                           jsr pcadj3
  206 A:f912  aa                                 tax                    ; pcl,pch+offset+1 to a,y
  207 A:f913  e8                                 inx 
  208 A:f914  d0 01                              bne prntyx                ; +1 to y,x
  209 A:f916  c8                                 iny 
  210 A:f917                                    ;
  211 A:f917                                    ; print y and x  as 4 digit hex number
  212 A:f917                                    ;
  213 A:f917                           prntyx    
  213 A:f917  98                                 tya 
  214 A:f918                           prntax    
  214 A:f918  20 e2 fd                           jsr prbyte                ; output target adr
  215 A:f91b                           prntx     
  215 A:f91b  8a                                 txa                    ;    of branch and return
  216 A:f91c  4c e2 fd                           jmp prbyte
  217 A:f91f                           prblnk    
  217 A:f91f  a2 03                              ldx #$03             ; blank count
  218 A:f921                           prbl2     
  218 A:f921  a9 20                              lda #' '             ; load a space
  219 A:f923                           prbl3     
  219 A:f923  20 f5 fd                           jsr cout                ; output a blank
  220 A:f926  ca                                 dex 
  221 A:f927  d0 f8                              bne prbl2
  222 A:f929  60                                 rts 
  223 A:f92a                           pcadj     
  223 A:f92a  38                                 sec                    ; 0=1-byte, 1=2-byte,
  224 A:f92b                           pcadj2    
  224 A:f92b  a5 2f                              lda length                ;   2=3-byte
  225 A:f92d                           pcadj3    
  225 A:f92d  a4 3b                              ldy pch
  226 A:f92f  aa                                 tax                    ; test displacement sign
  227 A:f930  10 01                              bpl pcadj4                ;   (for rel branch)
  228 A:f932  88                                 dey 
  229 A:f933                           pcadj4    
  229 A:f933  65 3a                              adc pcl
  230 A:f935  90 01                              bcc rts2                ; pcl+LENGTH(or Displc.)+1 to A
  231 A:f937  c8                                 iny                    ;   carry inot y (pch)
  232 A:f938                           rts2      
  232 A:f938  60                                 rts 
  233 A:f939                                    ;
  234 A:f939                                    ; fmt1 bytes
  234 A:f939                           XXXXXXY0 instructions 
  235 A:f939                                    ;       if Y=0
  235 A:f939                           then left half byte 
  236 A:f939                                    ;       if Y=1  then right half byte
  237 A:f939                                    ;                    (X=index)
  238 A:f939                           fmt1      
  238 A:f939  04 20 54 30 0d                     .byt $04,$20,$54,$30,$0d
  239 A:f93e  80 04 90 03 22                     .byt $80,$04,$90,$03,$22
  240 A:f943  54 33 0d 80 04                     .byt $54,$33,$0d,$80,$04
  241 A:f948  90 04 20 54 33                     .byt $90,$04,$20,$54,$33
  242 A:f94d  0d 80 04 90 04                     .byt $0d,$80,$04,$90,$04
  243 A:f952  20 54 3b 0d 80                     .byt $20,$54,$3b,$0d,$80
  244 A:f957  04 90 00 22 44                     .byt $04,$90,$00,$22,$44
  245 A:f95c  33 0d c8 44 00                     .byt $33,$0d,$c8,$44,$00
  246 A:f961  11 22 44 33 0d                     .byt $11,$22,$44,$33,$0d
  247 A:f966  c8 44 a9 01 22                     .byt $c8,$44,$a9,$01,$22
  248 A:f96b  44 33 0d 80 04                     .byt $44,$33,$0d,$80,$04
  249 A:f970  90 01 22 44 33                     .byt $90,$01,$22,$44,$33
  250 A:f975  0d 80 04 90                        .byt $0d,$80,$04,$90
  251 A:f979  26 31 87 9a                        .byt $26,$31,$87,$9a; ZZXXXXY01 instructions
  252 A:f97d                           fmt2      
  252 A:f97d  00                                 .byt $00              ; ERR
  253 A:f97e  21                                 .byt $21              ; IMM
  254 A:f97f  81                                 .byt $81              ; Z-PAGE
  255 A:f980  82                                 .byt $82              ; ABS
  256 A:f981  00                                 .byt $00              ; IMPLIED
  257 A:f982  00                                 .byt $00              ; ACCUMULATOR
  258 A:f983  59                                 .byt $59              ; (ZPAG,X)
  259 A:f984  4d                                 .byt $4d              ; (ZPAG),Y
  260 A:f985  91                                 .byt $91              ; ZPAG,X
  261 A:f986  92                                 .byt $92              ; ABS,X
  262 A:f987  86                                 .byt $86              ; ABS,Y
  263 A:f988  4a                                 .byt $4a              ; (ABS)
  264 A:f989  85                                 .byt $85              ; ZPAG,Y
  265 A:f98a  9d                                 .byt $9d              ; RELATIVE
  266 A:f98b                           char1     
  266 A:f98b  2c 29 2c 23 28 24                  .byt ',',')',',','#','(','$'
  267 A:f991                           char2     
  267 A:f991  59 00 58 24 24 00                  .byt 'Y',0,"X$$",0
  268 A:f997                                    ;
  269 A:f997                                    ; mneml is of form
  269 A:f997                                    
  270 A:f997                                    ; (A) XXXXX000
  271 A:f997                                    ; (B) XXXYY100
  272 A:f997                                    ; (C) 1XXX1010
  273 A:f997                                    ; (D) XXXYYY10
  274 A:f997                                    ; (E) XXXYYY01
  275 A:f997                                    ;     (X=index)
  276 A:f997                           mneml     
  276 A:f997  1c 8a 1c 23 5d 8b                  .byt $1c,$8a,$1c,$23,$5d,$8b
  277 A:f99d  1b a1 9d 8a 1d 23                  .byt $1b,$a1,$9d,$8a,$1d,$23
  278 A:f9a3  9d 8b 1d a1 00 29                  .byt $9d,$8b,$1d,$a1,$00,$29
  279 A:f9a9  19 ae 69 a8 19 23                  .byt $19,$ae,$69,$a8,$19,$23
  280 A:f9af  24 53 1b 23 24 53                  .byt $24,$53,$1b,$23,$24,$53
  281 A:f9b5  19 a1                              .byt $19,$a1        ; (A) Format Above
  282 A:f9b7  00 1a 5b 5b a5 69                  .byt $00,$1a,$5b,$5b,$a5,$69
  283 A:f9bd  24 24                              .byt $24,$24        ; (B) Format
  284 A:f9bf  ae ae a8 ad 29 00                  .byt $ae,$ae,$a8,$ad,$29,$00
  285 A:f9c5  7c 00                              .byt $7c,$00        ; (C) Format
  286 A:f9c7  15 9c 6d 9c a5 69                  .byt $15,$9c,$6d,$9c,$a5,$69
  287 A:f9cd  29 53                              .byt $29,$53        ; (D) Format
  288 A:f9cf  84 13 34 11 a5 69                  .byt $84,$13,$34,$11,$a5,$69
  289 A:f9d5  23 a0                              .byt $23,$a0        ; (E) Format
  290 A:f9d7                           mnemr     
  290 A:f9d7  d8 62 5a 48 26 62                  .byt $d8,$62,$5a,$48,$26,$62
  291 A:f9dd  94 88 54 44 c8 54                  .byt $94,$88,$54,$44,$c8,$54
  292 A:f9e3  68 44 e8 94 00 b4                  .byt $68,$44,$e8,$94,$00,$b4
  293 A:f9e9  08 84 74 b4 28 6e                  .byt $08,$84,$74,$b4,$28,$6e
  294 A:f9ef  74 f4 cc 4a 72 f2                  .byt $74,$f4,$cc,$4a,$72,$f2
  295 A:f9f5  a4 8a                              .byt $a4,$8a        ; (A) Format
  296 A:f9f7  00 aa a2 a2 74 74                  .byt $00,$aa,$a2,$a2,$74,$74
  297 A:f9fd  74 72                              .byt $74,$72        ; (B) Format
  298 A:f9ff  44 68 b2 32 b2 00                  .byt $44,$68,$b2,$32,$b2,$00
  299 A:fa05  22 00                              .byt $22,$00        ; (C) Format
  300 A:fa07  1a 1a 26 26 72 72                  .byt $1a,$1a,$26,$26,$72,$72
  301 A:fa0d  88 c8                              .byt $88,$c8        ; (D) Format
  302 A:fa0f  c4 ca 26 48 44 44                  .byt $c4,$ca,$26,$48,$44,$44
  303 A:fa15  a2 c8                              .byt $a2,$c8        ; (E) Format
  304 A:fa17  ff ff ff                           .byt $ff,$ff,$ff
  305 A:fa1a                                    ;
  306 A:fa1a                                    ;  SPACE FREE
  307 A:fa1a                                    ;
  308 A:fa1a                           keep_aligned 
  308 A:fa1a                                    
  309 A:fa1a  00 ff 6d 00 00 24 f8 ...           .dsb $6d              ; blank must be on page $FE for jump table to work
  310 A:fa87                                    ;
  311 A:fa87                                    ; monitor stepping
  312 A:fa87                                    ; this is nice... it emulates itself to execute a program stepwise
  313 A:fa87                                    ;
  314 A:fa87                           step      
  314 A:fa87  20 a7 f8                           jsr instdsp                ; disassemble one instruction
  315 A:fa8a  68                                 pla                    ;   at (pcl,h)
  316 A:fa8b  85 2c                              sta rtnl                ; adjust to user
  317 A:fa8d  68                                 pla                    ;   stack, save
  318 A:fa8e  85 2d                              sta rtnh                ;   return address
  319 A:fa90  a2 08                              ldx #$08
  320 A:fa92                           xqinit    
  320 A:fa92  bd 54 fb                           lda initbl-1,x        ; init xeq (execute) area
  321 A:fa95  95 3c                              sta xqt,x
  322 A:fa97  ca                                 dex 
  323 A:fa98  d0 f8                              bne xqinit
  324 A:fa9a  a1 3a                              lda (pcl,x)            ; user opcode byte
  325 A:fa9c  f0 42                              beq xbrk                ; special if BRK
  326 A:fa9e  a4 2f                              ldy length                ; LEN from disassembly
  327 A:faa0  c9 20                              cmp #$20
  328 A:faa2  f0 59                              beq xjsr                ; handle jsr, rts, jmp,
  329 A:faa4  c9 60                              cmp #$60             ;   jmp (), rti special
  330 A:faa6  f0 45                              beq xrts
  331 A:faa8  c9 4c                              cmp #$4c
  332 A:faaa  f0 5c                              beq xjmp
  333 A:faac  c9 6c                              cmp #$6c
  334 A:faae  f0 59                              beq xjmpat
  335 A:fab0  c9 40                              cmp #$40
  336 A:fab2  f0 35                              beq xrti
  337 A:fab4  29 1f                              and #$1f             ; TODO comment
  338 A:fab6  49 14                              eor #$14
  339 A:fab8  c9 04                              cmp #$04             ; copy user instruction to xeq area
  340 A:faba  f0 02                              beq xq2                ;   with trailing nops
  341 A:fabc                           xq1       
  341 A:fabc  b1 3a                              lda (pcl),y            ; change rel branch
  342 A:fabe                           xq2       
  342 A:fabe  99 3c 00                           sta xqtnz,y              ;   disp to 4 for
  343 A:fac1  88                                 dey                    ;   jmp to branch or
  344 A:fac2  10 f8                              bpl xq1                ;   nbranch from xeq
  345 A:fac4  20 3f ff                           jsr restore                ; restore user reg contents
  346 A:fac7  4c 3c 00                           jmp xqtnz                ; xeq (execute) user op from RAM
  347 A:faca                           irqvec    
  347 A:faca  85 45                              sta acc                ;    (return to nbranch)
  348 A:facc  68                                 pla                    ; fetch p status register into a
  349 A:facd  48                                 pha                    ; * * IRQ handler
  350 A:face  0a                                 asl 
  351 A:facf  0a                                 asl 
  352 A:fad0  0a                                 asl                    ; put B flag in high bit
  353 A:fad1  30 03                              bmi break                ; if set, handle BRK
  354 A:fad3  6c fe 03                           jmp (irqloc)              ; user routine vector in RAM
  355 A:fad6                           break     
  355 A:fad6  28                                 plp 
  356 A:fad7  20 4c ff                           jsr sav1                ; save regs on break
  357 A:fada  68                                 pla                    ; including pc
  358 A:fadb  85 3a                              sta pcl
  359 A:fadd  68                                 pla 
  360 A:fade  85 3b                              sta pch
  361 A:fae0                           xbrk      
  361 A:fae0  20 59 f8                           jsr insds1                ; print user pc
  362 A:fae3  20 1e fb                           jsr rgdsp1                ;   and registers
  363 A:fae6  4c 65 ff                           jmp mon                ; go to monitor
  364 A:fae9                           xrti      
  364 A:fae9  18                                 clc 
  365 A:faea  68                                 pla                    ; simulate rti by expecting
  366 A:faeb  85 48                              sta status                ;    status from stack, then rts
  367 A:faed                           xrts      
  367 A:faed  68                                 pla                    ; rts simulation
  368 A:faee  85 3a                              sta pcl                ;   extract pc from stack
  369 A:faf0  68                                 pla                    ; and update pc by 1 (LEN=0)
  370 A:faf1                           pcinc2    
  370 A:faf1  85 3b                              sta pch
  371 A:faf3                           pcinc3    
  371 A:faf3  a5 2f                              lda length                ; update pc by LEN
  372 A:faf5  20 2d f9                           jsr pcadj3
  373 A:faf8  84 3b                              sty pch
  374 A:fafa  18                                 clc                    ; short unconditional jump
  375 A:fafb  90 14                              bcc newpcl                ;  CLC BCC #rel
  376 A:fafd                           xjsr      
  376 A:fafd  18                                 clc 
  377 A:fafe  20 2b f9                           jsr pcadj2                ; update pc and push
  378 A:fb01  aa                                 tax                    ;   onto stack for
  379 A:fb02  98                                 tya                    ;   JSR simulate
  380 A:fb03  48                                 pha 
  381 A:fb04  8a                                 txa 
  382 A:fb05  48                                 pha 
  383 A:fb06  a0 02                              ldy #$02
  384 A:fb08                           xjmp      
  384 A:fb08  18                                 clc 
  385 A:fb09                           xjmpat    
  385 A:fb09  b1 3a                              lda (pcl),Y
  386 A:fb0b  aa                                 tax                    ; load pc for jump,
  387 A:fb0c  88                                 dey                    ;   (JMP) simulate
  388 A:fb0d  b1 3a                              lda (pcl),y
  389 A:fb0f  86 3b                              stx pch
  390 A:fb11                           newpcl    
  390 A:fb11  85 3a                              sta pcl
  391 A:fb13  b0 f3                              bcs xjmp
  392 A:fb15                           rtnjmp    
  392 A:fb15  a5 2d                              lda rtnh
  393 A:fb17  48                                 pha 
  394 A:fb18  a5 2c                              lda rtnl
  395 A:fb1a  48                                 pha 
  396 A:fb1b                           regdsp    
  396 A:fb1b  20 96 fd                           jsr crout                ; display user reg
  397 A:fb1e                           rgdsp1    
  397 A:fb1e  a9 45                              lda #<acc              ;  contents with
  398 A:fb20  85 40                              sta a3l                ;  labels
  399 A:fb22  a9 00                              lda #>acc
  400 A:fb24  85 41                              sta a3h
  401 A:fb26  a2 fb                              ldx #$fb
  402 A:fb28                           rdsp1     
  402 A:fb28  a9 20                              lda #' '
  403 A:fb2a  20 f5 fd                           jsr cout                ; output space
  404 A:fb2d  bd 62 fa                           lda rtbl-$fb,x        ; register name (x has FB so base address = rtbl - FB)
  405 A:fb30  20 f5 fd                           jsr cout
  406 A:fb33  a9 3d                              lda #'='             ; '='
  407 A:fb35  20 f5 fd                           jsr cout
  408 A:fb38  b5 4a                              lda acc+5,x
  409 A:fb3a  20 e2 fd                           jsr prbyte
  410 A:fb3d  e8                                 inx 
  411 A:fb3e  30 e8                              bmi rdsp1
  412 A:fb40  60                                 rts 
  413 A:fb41                           branch    
  413 A:fb41  18                                 clc                    ; branch taken,
  414 A:fb42  a0 01                              ldy #$01             ;  add LEN+2 to pc
  415 A:fb44  b1 3a                              lda (pcl),y
  416 A:fb46  20 2d f9                           jsr pcadj3
  417 A:fb49  85 3a                              sta pcl
  418 A:fb4b  98                                 tya 
  419 A:fb4c  38                                 sec 
  420 A:fb4d  b0 a2                              bcs pcinc2
  421 A:fb4f                           nbranch   
  421 A:fb4f  20 4a ff                           jsr save                ; normal return after
  422 A:fb52  38                                 sec                    ;   xeq user of
  423 A:fb53  b0 9e                              bcs pcinc3                ; go update pc
  424 A:fb55                           initbl    
  424 A:fb55  ea                                 nop 
  425 A:fb56  ea                                 nop                    ; dummy fill for
  426 A:fb57  4c 4f fb                           jmp nbranch                ;   xeq area
  427 A:fb5a  4c 41 fb                           jmp branch
  428 A:fb5d                           rtbl      
  428 A:fb5d  c1                                 .byt $c1              ; 'A'
  429 A:fb5e  d8                                 .byt $d8              ; 'X'
  430 A:fb5f  d9                                 .byt $d9              ; 'Y'
  431 A:fb60  d0                                 .byt $d0              ; 'P'
  432 A:fb61  d3                                 .byt $d3              ; 'S'
  433 A:fb62                           pread     
  433 A:fb62  ad 70 c0                           lda ptrig                ; paddle read; trigger paddles
  434 A:fb65  a0 00                              ldy #$00             ; init count
  435 A:fb67  ea                                 nop                    ; compensate timing for first count
  436 A:fb68  ea                                 nop                    ; 2 x 2 cycles
  437 A:fb69                           pread2    
  437 A:fb69  bd 61 c0                           lda paddl0,x              ; count y-reg
  438 A:fb6c  10 04                              bpl rts2d                ;    every 12 usec
  439 A:fb6e  c8                                 iny 
  440 A:fb6f  d0 f8                              bne pread2                ;    exit at 255 max
  441 A:fb71  88                                 dey 
  442 A:fb72                           rts2d     
  442 A:fb72  60                                 rts 
  443 A:fb73                           init      
  443 A:fb73  a9 00                              lda #$00             ; clr status for debug
  444 A:fb75  85 48                              sta status                ;   software
  445 A:fb77  ad 56 c0                           lda lores
  446 A:fb7a  ad 56 c0                           lda lowscr
  447 A:fb7d                           settxt    
  447 A:fb7d  ad 51 c0                           lda txtset                ; set for text mode
  448 A:fb80  a9 00                              lda #$00             ;   full screen window
  449 A:fb82  f0 0b                              beq setwnd
  450 A:fb84                           setgr     
  450 A:fb84  ad 50 c0                           lda txtclr                ; set for graphics mode
  451 A:fb87  ad 53 c0                           lda mixset                ;   lower 4 lines as
  452 A:fb8a  20 2a f8                           jsr clrtop                ;   text window
  453 A:fb8d  a9 14                              lda #$14
  454 A:fb8f                           setwnd    
  454 A:fb8f  85 22                              sta wndtop                ; set for 40 col window
  455 A:fb91  a9 00                              lda #$00             ;    top in accu,
  456 A:fb93  85 20                              sta wndlft                ;    bottom at line 24
  457 A:fb95  ad 17 c0                           lda termww                ; get terminal window width
  458 A:fb98  85 21                              sta wndwdth
  459 A:fb9a  ad 16 c0                           lda termwh                ; get terminal window height
  460 A:fb9d  85 23                              sta wndbtm
  461 A:fb9f  38                                 sec 
  462 A:fba0  e9 01                              sbc #$01             ; last possible row in window
  463 A:fba2                           tabv      
  463 A:fba2  85 25                              sta cv                ; vtabs to row in accu
  464 A:fba4  60                                 rts 
  465 A:fba5                           mulpm     
  465 A:fba5  20 e9 fb                           jsr md1                ; abs value of ac, aux
  466 A:fba8                           mul       
  466 A:fba8  a0 10                              ldy #$10             ; index for 16 bits
  467 A:fbaa                           mul2      
  467 A:fbaa  a5 50                              lda acl                ; acx * aux + xtnd
  468 A:fbac  4a                                 lsr                    ;  to ac, xtnd
  469 A:fbad  90 0c                              bcc mul4                ; if no carry,
  470 A:fbaf  18                                 clc                    ;   no partial product
  471 A:fbb0  a2 fe                              ldx #$fe
  472 A:fbb2                           mul3      
  472 A:fbb2  b5 54                              lda xtndl+2,x        ; add multiplicant (aux)
  473 A:fbb4  75 56                              adc auxl+2,x        ;   to partial product
  474 A:fbb6  95 54                              sta xtndl+2,x        ;     (xtnd)
  475 A:fbb8  e8                                 inx 
  476 A:fbb9  d0 f7                              bne mul3
  477 A:fbbb                           mul4      
  477 A:fbbb  a2 03                              ldx #$03
  478 A:fbbd                           mul5      
  478 A:fbbd  76 50                              ror acl,x              ; orig DFB #$76, #$50 ?!? maybe a bug in their assembler software
  479 A:fbbf  ca                                 dex 
  480 A:fbc0  10 fb                              bpl mul5
  481 A:fbc2  88                                 dey 
  482 A:fbc3  d0 e5                              bne mul2
  483 A:fbc5  60                                 rts 
  484 A:fbc6                           divpm     
  484 A:fbc6  20 e9 fb                           jsr md1                ; abs value of ac, aux
  485 A:fbc9                           div       
  485 A:fbc9  a0 10                              ldy #$10             ; index for 16 bits
  486 A:fbcb                           div2      
  486 A:fbcb  06 51                              asl ach
  487 A:fbcd  26 51                              rol ach
  488 A:fbcf  26 52                              rol xtndl                ; xtnd/aux
  489 A:fbd1  26 53                              rol xtndh                ;   to ac.
  490 A:fbd3  38                                 sec 
  491 A:fbd4  a5 52                              lda xtndl
  492 A:fbd6  e5 54                              sbc auxl                ; mod to xtnd
  493 A:fbd8  aa                                 tax 
  494 A:fbd9  a5 53                              lda xtndh
  495 A:fbdb  e5 55                              sbc auxh
  496 A:fbdd  90 06                              bcc div3
  497 A:fbdf  86 52                              stx xtndl
  498 A:fbe1  85 53                              sta xtndh
  499 A:fbe3  e6 50                              inc acl
  500 A:fbe5                           div3      
  500 A:fbe5  88                                 dey 
  501 A:fbe6  d0 e3                              bne div2
  502 A:fbe8  60                                 rts 
  503 A:fbe9                           md1       
  503 A:fbe9  a0 00                              ldy #$00             ; abs value of ac, aux
  504 A:fbeb  84 2f                              sty sign                ;   with result sign
  505 A:fbed  a2 54                              ldx #auxl               ;   in lsb of sign
  506 A:fbef  20 f4 fb                           jsr md2
  507 A:fbf2  a2 50                              ldx #acl
  508 A:fbf4                           md2       
  508 A:fbf4  b5 01                              lda loc1,x              ; x specifies ac or aux
  509 A:fbf6  10 0d                              bpl mdrts
  510 A:fbf8  38                                 sec 
  511 A:fbf9                           md3       
  511 A:fbf9  98                                 tya 
  512 A:fbfa  f5 00                              sbc loc0,x              ; compl specified reg
  513 A:fbfc  95 00                              sta loc0,x              ;   if negative
  514 A:fbfe  98                                 tya 
  515 A:fbff  f5 01                              sbc loc1,x
  516 A:fc01  95 01                              sta loc1,x
  517 A:fc03  e6 2f                              inc sign
  518 A:fc05                           mdrts     
  518 A:fc05  60                                 rts 

  520 A:fc06                           bell1     
  520 A:fc06  a9 07                              lda #k_ctl_g               ; output bell and return
  521 A:fc08  8d 12 c0                           sta termout                ; pit to term directly here...
  522 A:fc0b  60                                 rts 
  523 A:fc0c  ea ff 10 00 00 24 2c ...           .dsb $10,$ea
  524 A:fc1c                           rts2b     
  524 A:fc1c  60                                 rts 
  525 A:fc1d                                    ;
  526 A:fc1d                                    ; Store terminal char output and advance screen cursor
  527 A:fc1d                                    ;
  528 A:fc1d                           stoadv    
  528 A:fc1d  a4 25                              ldy cv                ; cursor y index to y register
  529 A:fc1f  8c 10 c0                           sty termcy                ; set terminal cursor y
  530 A:fc22  a4 24                              ldy ch                ; cursor h index to y register
  531 A:fc24  8c 11 c0                           sty termcx                ; set terminal cursor x
  532 A:fc27  a4 32                              ldy invflg                ;
  533 A:fc29  8c 13 c0                           sty termesc                ; invflg has the command byte for the char attribute normal or reverse
  534 A:fc2c  8d 12 c0                           sta termout                ; output char
  535 A:fc2f                                    ;
  536 A:fc2f                                    ; advance cursor
  537 A:fc2f                                    ;
  538 A:fc2f                                    ; add next line routine if cursor proceeds to right margin
  539 A:fc2f                                    ;
  540 A:fc2f                           advance   
  540 A:fc2f  e6 24                              inc ch                ; increment cursor h index
  541 A:fc31  a5 24                              lda ch                ;   (move right)
  542 A:fc33  c5 21                              cmp wndwdth                ; beyond window width?
  543 A:fc35  b0 4e                              bcs cr                ;   yes, cr to next line
  544 A:fc37                           rts3      
  544 A:fc37  60                                 rts                    ; no, return
  545 A:fc38                                    ;
  546 A:fc38                                    ; Video out
  547 A:fc38                                    ;
  548 A:fc38                                    ; Write character to terminal I/O
  549 A:fc38                                    ;
  550 A:fc38                           vidout    
  550 A:fc38  c9 20                              cmp #' '             ; control char?
  551 A:fc3a  b0 e1                              bcs stoadv                ;   no, output it
  552 A:fc3c  c9 0a                              cmp #k_entr               ; CR?  0x1D | 0x80
  553 A:fc3e  f0 45                              beq cr                ;   yes
  554 A:fc40  c9 0a                              cmp #k_lf               ; LF?
  555 A:fc42  f0 45                              beq lf                ;   yes
  556 A:fc44  c9 08                              cmp #k_bs               ; backspace (CTRL-H)?
  557 A:fc46  d0 be                              bne bell1                ;   no, check for bell
  558 A:fc48                           bs        
  558 A:fc48  c6 24                              dec ch                ; decrement cursor h index
  559 A:fc4a  10 eb                              bpl rts3                ; if pos, ok, else move up
  560 A:fc4c  a5 21                              lda wndwdth                ; set ch to wndwdth-1
  561 A:fc4e  85 24                              sta ch
  562 A:fc50  c6 24                              dec ch                ; rightmost screen position
  563 A:fc52                           up        
  563 A:fc52  a5 22                              lda wndtop                ; cursor v index
  564 A:fc54  c5 25                              cmp cv
  565 A:fc56  b0 02                              bcs rts4                ; if top line then return
  566 A:fc58  c6 25                              dec cv                ; decr cursor v
  567 A:fc5a                           rts4      
  567 A:fc5a  60                                 rts 
  568 A:fc5b                           esc1      
  568 A:fc5b  49 1b                              eor #k_esc               ; esc?
  569 A:fc5d  f0 1c                              beq home                ;   if so, do home and clear
  570 A:fc5f  e9 02                              sbc #$02             ; esc-a or -b check
  571 A:fc61  30 cc                              bmi advance                ;   a, advance
  572 A:fc63  f0 e3                              beq bs                ;   b, backspace
  573 A:fc65  e9 02                              sbc #$02             ; esc-c or -d check
  574 A:fc67  30 20                              bmi lf                ;   c, down
  575 A:fc69  f0 e7                              beq up                ;   d, go up
  576 A:fc6b  e9 02                              sbc #$02             ; esc-e or -f check
  577 A:fc6d  90 2a                              bcc clreol                ;   e, clear to end of line
  578 A:fc6f  d0 e9                              bne rts4                ;   not f, return
  579 A:fc71                           clreop    
  579 A:fc71  a4 24                              ldy ch                ; cursor h to y
  580 A:fc73  a5 25                              lda cv                ; cursor v to a
  581 A:fc75                           cleop1    
  581 A:fc75  48                                 pha                    ; save current line on stk
  582 A:fc76  a9 00                              lda #t_cls               ; clear screen command
  583 A:fc78  8d 13 c0                           sta termesc                ; send to terminal
  584 A:fc7b                           home      
  584 A:fc7b  a5 22                              lda wndtop                ; init cursor v
  585 A:fc7d  85 25                              sta cv                ;   and h-indices
  586 A:fc7f  a0 00                              ldy #$00
  587 A:fc81  84 24                              sty ch                ; then clear to end of page
  588 A:fc83  f0 f0                              beq cleop1
  589 A:fc85                           cr        
  589 A:fc85  a9 00                              lda #$00             ; cursor to left of index
  590 A:fc87  85 24                              sta ch
  591 A:fc89                           lf        
  591 A:fc89  e6 25                              inc cv                ; incr cursor v (down 1 line)
  592 A:fc8b  a5 25                              lda cv
  593 A:fc8d  c5 23                              cmp wndbtm                ; off screen?
  594 A:fc8f  90 c9                              bcc rts4                ;   no, done
  595 A:fc91  c6 25                              dec cv                ; decr cursor v (back to bottom)
  596 A:fc93                           scroll    
  596 A:fc93  a9 03                              lda #t_scr               ; scroll command
  597 A:fc95  8d 13 c0                           sta termesc                ; let the terminal scroll.
  598 A:fc98  60                                 rts 
  599 A:fc99                           clreol    
  599 A:fc99  a9 01                              lda #t_cll               ; clear to eol command
  600 A:fc9b  8d 13 c0                           sta termesc                ; execute
  601 A:fc9e  60                                 rts 
  602 A:fc9f                           wait      
  602 A:fc9f  38                                 sec 
  603 A:fca0                           wait2     
  603 A:fca0  48                                 pha 
  604 A:fca1                           wait3     
  604 A:fca1  e9 01                              sbc #$01
  605 A:fca3  d0 fc                              bne wait3                ; 1.02.4 uSec
  606 A:fca5  68                                 pla                    ; (13+2712*A+512*A*A) on 1 MHz
  607 A:fca6  e9 01                              sbc #$01
  608 A:fca8  d0 f6                              bne wait2                ; busy, busy, busy waiting
  609 A:fcaa  60                                 rts 
  610 A:fcab                           nxta4     
  610 A:fcab  e6 42                              inc a4l                ; incr 2-byte a4
  611 A:fcad  d0 02                              bne nxta1                ;  and a1
  612 A:fcaf  e6 43                              inc a4h
  613 A:fcb1                           nxta1     
  613 A:fcb1  a5 3c                              lda a1l                ; incr 2-byte a1
  614 A:fcb3  c5 3e                              cmp a2l
  615 A:fcb5  a5 3d                              lda a1h                ;   and compare to a2
  616 A:fcb7  e5 3f                              sbc a2h
  617 A:fcb9  e6 3c                              inc a1l                ;  carry set if >=
  618 A:fcbb  d0 02                              bne rts4b
  619 A:fcbd  e6 3d                              inc a1h
  620 A:fcbf                           rts4b     
  620 A:fcbf  60                                 rts 
  621 A:fcc0                           headr     
  621 A:fcc0  a0 4b                              ldy #$4b             ; write A * 256 'long 1'
  622 A:fcc2  20 d2 fc                           jsr zerdly                ;   half cycles
  623 A:fcc5  d0 f9                              bne headr                ;     (650 usec each)
  624 A:fcc7  69 fe                              adc #$fe
  625 A:fcc9  b0 f5                              bcs headr                ; then a 'short 0'
  626 A:fccb  a0 21                              ldy #$21             ;    (400 usec)
  627 A:fccd                           wrbit     
  627 A:fccd  20 d2 fc                           jsr zerdly                ; write two half cycles
  628 A:fcd0  c8                                 iny                    ;   of 250 usec ('0')
  629 A:fcd1  c8                                 iny                    ;   or 500 usec ('0')
  630 A:fcd2                           zerdly    
  630 A:fcd2  88                                 dey                    ; it means 'zero delay'
  631 A:fcd3  d0 fd                              bne zerdly
  632 A:fcd5  90 05                              bcc wrtape                ; y is count for
  633 A:fcd7  a0 32                              ldy #$32             ;   timing loop
  634 A:fcd9                           onedly    
  634 A:fcd9  88                                 dey                    ; 'ones delay'
  635 A:fcda  d0 fd                              bne onedly
  636 A:fcdc                           wrtape    
  636 A:fcdc  ac 20 c0                           ldy tapeout                ; tape output toggle
  637 A:fcdf  a0 2c                              ldy #$2c
  638 A:fce1  ca                                 dex 
  639 A:fce2  60                                 rts 
  640 A:fce3                           rdbyte    
  640 A:fce3  a2 08                              ldx #$08             ; 8 bits to read
  641 A:fce5                           rdbyt2    
  641 A:fce5  48                                 pha                    ; read two transitions
  642 A:fce6  20 f1 fc                           jsr rd2bit                ;   (find edge)
  643 A:fce9  68                                 pla 
  644 A:fcea  2a                                 rol                    ; next bit
  645 A:fceb  a0 3a                              ldy #$3a             ; count for samples
  646 A:fced  ca                                 dex 
  647 A:fcee  d0 f5                              bne rdbyt2
  648 A:fcf0  60                                 rts 
  649 A:fcf1                           rd2bit    
  649 A:fcf1  20 f4 fc                           jsr rdbit
  650 A:fcf4                           rdbit     
  650 A:fcf4  88                                 dey                    ; decr y until
  651 A:fcf5  ad 60 c0                           lda tapein                ;   tape transition
  652 A:fcf8  45 2f                              eor lastin
  653 A:fcfa  10 f8                              bpl rdbit
  654 A:fcfc  45 2f                              eor lastin
  655 A:fcfe  85 2f                              sta lastin
  656 A:fd00  c0 80                              cpy #$80             ; set carry on y register
  657 A:fd02  60                                 rts 
  658 A:fd03                           charout   
  658 A:fd03  a4 25                              ldy cv                ; cursor y index to y register
  659 A:fd05  8c 10 c0                           sty termcy                ; set terminal cursor y
  660 A:fd08  a4 24                              ldy ch                ; cursor h index to y register
  661 A:fd0a  8c 11 c0                           sty termcx                ; set terminal cursor x
  662 A:fd0d  8d 12 c0                           sta termout                ; output char
  663 A:fd10  60                                 rts 
  664 A:fd11                           rdkey     
  664 A:fd11  a0 06                              ldy #t_blnk               ; set screen to flash
  665 A:fd13  8c 13 c0                           sty termesc
  666 A:fd16  ad 12 c0                           lda termout                ; get char at cursor pos.
  667 A:fd19  20 03 fd                           jsr charout
  668 A:fd1c  a0 04                              ldy #t_norm               ; set screen back to normal after
  669 A:fd1e  8c 13 c0                           sty termesc
  670 A:fd21  6c 38 00                           jmp (kswl)              ; go to user key-in
  671 A:fd24                           keyin     
  671 A:fd24  e6 4e                              inc rndl
  672 A:fd26  d0 02                              bne keyin2                ; inc random number
  673 A:fd28  e6 4f                              inc rndh
  674 A:fd2a                           keyin2    
  674 A:fd2a  ad 00 c0                           lda kbd
  675 A:fd2d  f0 f5                              beq keyin                ; busy waiting loop until key != 0...
  676 A:fd2f  20 03 fd                           jsr charout                ; replace flashing screen
  677 A:fd32  2c 01 c0                           bit kbdstrb                ; clear key strobe
  678 A:fd35  60                                 rts 
  679 A:fd36                           esc       
  679 A:fd36  20 11 fd                           jsr rdkey                ; get keycode
  680 A:fd39  20 5b fc                           jsr esc1                ;  handle esc function
  681 A:fd3c                           rdchar    
  681 A:fd3c  20 11 fd                           jsr rdkey                ; read key
  682 A:fd3f  c9 1b                              cmp #k_esc               ; ESC?
  683 A:fd41  f0 f3                              beq esc                ;   yes, don't return
  684 A:fd43  60                                 rts 
  685 A:fd44                           notcr     
  685 A:fd44  a5 32                              lda invflg
  686 A:fd46  48                                 pha 
  687 A:fd47  a9 04                              lda #t_norm
  688 A:fd49  85 32                              sta invflg                ; echo user line
  689 A:fd4b  bd 00 02                           lda in,x              ;   non inverse
  690 A:fd4e  20 f5 fd                           jsr cout
  691 A:fd51  68                                 pla 
  692 A:fd52  85 32                              sta invflg
  693 A:fd54  bd 00 02                           lda in,x
  694 A:fd57  c9 08                              cmp #k_bs               ; check for edit keys
  695 A:fd59  f0 1d                              beq bckspc                ;  bs, ctrl-x
  696 A:fd5b  c9 18                              cmp #k_ctl_x
  697 A:fd5d  f0 0a                              beq cancel
  698 A:fd5f  e0 f8                              cpx #$f8             ; margin?
  699 A:fd61  90 03                              bcc notcr1
  700 A:fd63  20 3a ff                           jsr bell                ; yes, sound bell
  701 A:fd66                           notcr1    
  701 A:fd66  e8                                 inx                    ; advance input index
  702 A:fd67  d0 13                              bne nxtchar
  703 A:fd69                           cancel    
  703 A:fd69  a9 5c                              lda #'\'             ; backslash after cancelled LTN?
  704 A:fd6b  20 f5 fd                           jsr cout
  705 A:fd6e                           getlnz    
  705 A:fd6e  20 96 fd                           jsr crout                ; output cr
  706 A:fd71                           getln     
  706 A:fd71  a5 33                              lda prompt
  707 A:fd73  20 f5 fd                           jsr cout                ; output prompt char
  708 A:fd76  a2 01                              ldx #$01             ; init input index
  709 A:fd78                           bckspc    
  709 A:fd78  8a                                 txa                    ;   will backspace to u
  710 A:fd79  f0 f3                              beq getlnz
  711 A:fd7b  ca                                 dex 
  712 A:fd7c                           nxtchar   
  712 A:fd7c  20 3c fd                           jsr rdchar
  713 A:fd7f  c9 15                              cmp #k_ctl_u               ; use screen char
  714 A:fd81  d0 03                              bne captst                ;  for ctrl-u
  715 A:fd83  ad 12 c0                           lda termout                ; get char under cursor
  716 A:fd86                           captst    
  716 A:fd86  c9 60                              cmp #$60
  717 A:fd88  90 02                              bcc addinp                ; convert to caps; for now..
  718 A:fd8a  29 df                              and #$df
  719 A:fd8c                           addinp    
  719 A:fd8c  9d 00 02                           sta in,x              ; add to input buffer
  720 A:fd8f  c9 0a                              cmp #k_entr
  721 A:fd91  d0 b1                              bne notcr
  722 A:fd93  20 99 fc                           jsr clreol                ; clear to eol if cr
  723 A:fd96                           crout     
  723 A:fd96  a9 0a                              lda #k_entr
  724 A:fd98  d0 5b                              bne cout                ; branches always ?!?
  725 A:fd9a                           pra1      
  725 A:fd9a  a4 3d                              ldy a1h                ; print CR,A1 in hex
  726 A:fd9c  a6 3c                              ldx a1l
  727 A:fd9e                                    ;
  728 A:fd9e                                    ; print address header at start of line
  729 A:fd9e                                    ; yyxx-
  730 A:fd9e                                    ;
  731 A:fd9e                           pryx2     
  731 A:fd9e  20 96 fd                           jsr crout
  732 A:fda1  20 17 f9                           jsr prntyx
  733 A:fda4  a0 00                              ldy #$00
  734 A:fda6  a9 2d                              lda #'-'             ; print '-'
  735 A:fda8  4c f5 fd                           jmp cout
  736 A:fdab                                    ;
  737 A:fdab                                    ; Examine 8 bytes at address
  738 A:fdab                                    ; Triggered by command xxxx.yyyy
  739 A:fdab                                    ;
  740 A:fdab                           xam8      
  740 A:fdab  a5 3c                              lda a1l
  741 A:fdad  09 07                              ora #$07             ; set to finish at
  742 A:fdaf  85 3e                              sta a2l                ;   mod 8=7
  743 A:fdb1  a5 3d                              lda a1h
  744 A:fdb3  85 3f                              sta a2h
  745 A:fdb5                           mod8chk   
  745 A:fdb5  a5 3c                              lda a1l
  746 A:fdb7  29 07                              and #$07
  747 A:fdb9  d0 03                              bne dataout
  748 A:fdbb                                    ;
  749 A:fdbb                                    ; Examine byte at address
  750 A:fdbb                                    ;
  751 A:fdbb                           xam       
  751 A:fdbb  20 9a fd                           jsr pra1
  752 A:fdbe                           dataout   
  752 A:fdbe  a9 20                              lda #' '
  753 A:fdc0  20 f5 fd                           jsr cout                ; output blank
  754 A:fdc3  b1 3c                              lda (a1l),y
  755 A:fdc5  20 e2 fd                           jsr prbyte                ; print byte in hex
  756 A:fdc8  20 b1 fc                           jsr nxta1
  757 A:fdcb  90 e8                              bcc mod8chk                ; check if time to,
  758 A:fdcd  60                                 rts                    ;  print address
  759 A:fdce                           xampm     
  759 A:fdce  4a                                 lsr                    ; determine if mon
  760 A:fdcf  90 ea                              bcc xam                ;  mode is xam
  761 A:fdd1  4a                                 lsr                    ;  add or sub
  762 A:fdd2  4a                                 lsr 
  763 A:fdd3  a5 3e                              lda a2l
  764 A:fdd5  90 02                              bcc add
  765 A:fdd7  49 ff                              eor #$ff             ; sub - form 2's complement
  766 A:fdd9                           add       
  766 A:fdd9  65 3c                              adc a1l
  767 A:fddb  48                                 pha 
  768 A:fddc  a9 3d                              lda #'='             ; print '=' the result
  769 A:fdde  20 f5 fd                           jsr cout
  770 A:fde1  68                                 pla 
  771 A:fde2                                    ;
  772 A:fde2                                    ; print byte as 2 hex digits
  773 A:fde2                                    ;
  774 A:fde2                           prbyte    
  774 A:fde2  48                                 pha                    ; save a for second half
  775 A:fde3  4a                                 lsr                    ; shift 4 high digits into low nibble, destroys accu
  776 A:fde4  4a                                 lsr 
  777 A:fde5  4a                                 lsr 
  778 A:fde6  4a                                 lsr 
  779 A:fde7  20 ed fd                           jsr prhexz                ; first hex per subroutine,
  780 A:fdea  68                                 pla                    ;   second hex direct, reuse rts for prbyte
  781 A:fdeb                           prhex     
  781 A:fdeb  29 0f                              and #$0f             ; print hex digit in accu
  782 A:fded                                    ;
  783 A:fded                                    ; print lower accu nibble as hex number
  784 A:fded                                    ;
  785 A:fded                           prhexz    
  785 A:fded  09 30                              ora #$30             ;   lsb's
  786 A:fdef  c9 3a                              cmp #$3a
  787 A:fdf1  90 02                              bcc cout
  788 A:fdf3  69 06                              adc #$06             ; afterwards, flow into cout
  789 A:fdf5                                    ;
  790 A:fdf5                                    ; Character out to screen
  791 A:fdf5                                    ; go through cswl zero page vector
  792 A:fdf5                                    ;
  793 A:fdf5                           cout      
  793 A:fdf5  6c 36 00                           jmp (cswl)              ; vector to user output routine
  794 A:fdf8                                    ;
  795 A:fdf8                                    ; Standard cswl character out routine
  796 A:fdf8                                    ;
  797 A:fdf8                           cout1     
  797 A:fdf8  84 35                              sty ysav1                ; save the y register
  798 A:fdfa  48                                 pha                    ; save A
  799 A:fdfb  20 38 fc                           jsr vidout                ; output a as ascii
  800 A:fdfe  68                                 pla                    ; restore A
  801 A:fdff  a4 35                              ldy ysav1                ; restore y and return
  802 A:fe01  60                                 rts 
  803 A:fe02                                    ;
  804 A:fe02                                    ; on blank / return, execute preceding command
  805 A:fe02                                    ;
  806 A:fe02                           bli       
  806 A:fe02  c6 34                              dec ysav
  807 A:fe04  f0 a5                              beq xam8
  808 A:fe06                           blank     
  808 A:fe06  ca                                 dex                    ; blank to mon
  809 A:fe07  d0 16                              bne setmdz                ; after blank
  810 A:fe09  c9 3a                              cmp #':'             ; data store mode?
  811 A:fe0b  d0 c1                              bne xampm                ;   no, xam, add or sub
  812 A:fe0d                           stor      
  812 A:fe0d  85 31                              sta mode                ; keep in store mode
  813 A:fe0f  a5 3e                              lda a2l
  814 A:fe11  91 40                              sta (a3l),y            ; store as low byte as (a3)
  815 A:fe13  e6 40                              inc a3l
  816 A:fe15  d0 02                              bne rts5                ; incr a3, return
  817 A:fe17  e6 41                              inc a3h
  818 A:fe19                           rts5      
  818 A:fe19  60                                 rts 
  819 A:fe1a                                    ;
  820 A:fe1a                                    ; set the command mode
  821 A:fe1a                                    ;
  822 A:fe1a                           setmode   
  822 A:fe1a  a4 34                              ldy ysav                ; save converted colon, '+',
  823 A:fe1c  b9 ff 01                           lda in-1,y          ;  '-', '.' as mode.
  824 A:fe1f                           setmdz    
  824 A:fe1f  85 31                              sta mode
  825 A:fe21  60                                 rts 
  826 A:fe22                                    ;
  827 A:fe22                                    ; '<' command for move / verify
  828 A:fe22                                    ; initialize zero page variables for following V/M command
  829 A:fe22                                    ;
  830 A:fe22                           lt        
  830 A:fe22  a2 01                              ldx #$01
  831 A:fe24                           lt2       
  831 A:fe24  b5 3e                              lda a2l,x              ; copy a2 (2 bytes) to
  832 A:fe26  95 42                              sta a4l,x              ;   a4 and a5
  833 A:fe28  95 44                              sta a5l,x
  834 A:fe2a  ca                                 dex 
  835 A:fe2b  10 f7                              bpl lt2
  836 A:fe2d  60                                 rts 
  837 A:fe2e                                    ;
  838 A:fe2e                                    ; copy memory range
  839 A:fe2e                                    ;
  840 A:fe2e                           move      
  840 A:fe2e  b1 3c                              lda (a1l),y            ; move (a1 to a2) to
  841 A:fe30  91 42                              sta (a4l),y            ;   (a4)
  842 A:fe32  20 ab fc                           jsr nxta4
  843 A:fe35  90 f7                              bcc move
  844 A:fe37  60                                 rts 
  845 A:fe38                                    ;
  846 A:fe38                                    ; verify that two memory ranges have same content
  847 A:fe38                                    ;
  848 A:fe38                           vfy       
  848 A:fe38  b1 3c                              lda (a1l),y            ; verify (a1 to a2) with
  849 A:fe3a  d1 42                              cmp (a4l),y            ;   (a4)
  850 A:fe3c  f0 1c                              beq vfyok
  851 A:fe3e  20 9a fd                           jsr pra1
  852 A:fe41  b1 3c                              lda (a1l),y
  853 A:fe43  20 e2 fd                           jsr prbyte
  854 A:fe46  a9 20                              lda #' '             ; space
  855 A:fe48  20 f5 fd                           jsr cout
  856 A:fe4b  a9 28                              lda #'('             ; '('
  857 A:fe4d  20 f5 fd                           jsr cout
  858 A:fe50  b1 42                              lda (a4l),y
  859 A:fe52  20 e2 fd                           jsr prbyte
  860 A:fe55  a9 29                              lda #')'             ; ')'
  861 A:fe57  20 f5 fd                           jsr cout
  862 A:fe5a                           vfyok     
  862 A:fe5a  20 ab fc                           jsr nxta4
  863 A:fe5d  90 d9                              bcc vfy
  864 A:fe5f  60                                 rts 
  865 A:fe60                                    ;
  866 A:fe60                                    ; list memory range as assembler
  867 A:fe60                                    ;
  868 A:fe60                           list      
  868 A:fe60  20 77 fe                           jsr a1pc                ; move a1 (2 bytes) to
  869 A:fe63  a9 14                              lda #$14             ;  pc if specified and
  870 A:fe65                           list2     
  870 A:fe65  48                                 pha                    ;  dissemble 20 instructions
  871 A:fe66  20 a7 f8                           jsr instdsp
  872 A:fe69  20 2a f9                           jsr pcadj                ; adjust pc each instruction
  873 A:fe6c  85 3a                              sta pcl
  874 A:fe6e  84 3b                              sty pch
  875 A:fe70  68                                 pla 
  876 A:fe71  38                                 sec 
  877 A:fe72  e9 01                              sbc #$01             ; next 20 instr.
  878 A:fe74  d0 ef                              bne list2
  879 A:fe76  60                                 rts 
  880 A:fe77                           a1pc      
  880 A:fe77  8a                                 txa                    ; if user specified address
  881 A:fe78  f0 07                              beq a1pcrts                ;   copy from a1 to pc
  882 A:fe7a                           a1pclp    
  882 A:fe7a  b5 3c                              lda a1l,X
  883 A:fe7c  95 3a                              sta pcl,x
  884 A:fe7e  ca                                 dex 
  885 A:fe7f  10 f9                              bpl a1pclp
  886 A:fe81                           a1pcrts   
  886 A:fe81  60                                 rts 
  887 A:fe82                                    ;
  888 A:fe82                                    ; set inverde character mode
  889 A:fe82                                    ;
  890 A:fe82                           setinv    
  890 A:fe82  a0 05                              ldy #t_inv               ; set for inverse video
  891 A:fe84  d0 02                              bne setiflg
  892 A:fe86                                    ;
  893 A:fe86                                    ; set norml character mode
  894 A:fe86                                    ;
  895 A:fe86                           setnorm   
  895 A:fe86  a0 04                              ldy #t_norm               ; set for normal video
  896 A:fe88                           setiflg   
  896 A:fe88  84 32                              sty invflg
  897 A:fe8a  60                                 rts 
  898 A:fe8b                                    ;
  899 A:fe8b                                    ; set input port to standard keyboard
  900 A:fe8b                                    ;
  901 A:fe8b                           setkbd    
  901 A:fe8b  a9 00                              lda #$00             ; simulate port #0 input
  902 A:fe8d                           inport    
  902 A:fe8d  85 3e                              sta a2l                ;   specified (keyin routine)
  903 A:fe8f                           inprt     
  903 A:fe8f  a2 38                              ldx #kswl
  904 A:fe91  a0 24                              ldy #<keyin              ; see if it is the default vector
  905 A:fe93  d0 08                              bne ioprt
  906 A:fe95                                    ;
  907 A:fe95                                    ; Set output port to standard terminal
  908 A:fe95                                    ;
  909 A:fe95                           setvid    
  909 A:fe95  a9 00                              lda #$00             ; simulate port #0 output
  910 A:fe97                           outport   
  910 A:fe97  85 3e                              sta a2l                ;   specified (cout routine)
  911 A:fe99                           outprt    
  911 A:fe99  a2 36                              ldx #cswl
  912 A:fe9b  a0 f8                              ldy #<cout1              ; compare with address of default vector
  913 A:fe9d                           ioprt     
  913 A:fe9d  a5 3e                              lda a2l                ; set ram in/out vectors
  914 A:fe9f  29 0f                              and #$0f
  915 A:fea1  f0 06                              beq ioprt1
  916 A:fea3  09 c0                              ora #>ioadr              ; high byte
  917 A:fea5  a0 00                              ldy #$00
  918 A:fea7  f0 02                              beq ioprt2
  919 A:fea9                           ioprt1    
  919 A:fea9  a9 fd                              lda #>cout1
  920 A:feab                           ioprt2    
  920 A:feab  94 00                              sty loc0,x
  921 A:fead  95 01                              sta loc1,x
  922 A:feaf  60                                 rts 
  923 A:feb0                                    ;
  924 A:feb0                                    ; execute installed language
  925 A:feb0                                    ;
  926 A:feb0                           x_lang    
  926 A:feb0  4c 00 e0                           jmp lang
  927 A:feb3                                    ; soft entry vector for installed language
  928 A:feb3                           bascont   
  928 A:feb3  4c 03 e0                           jmp lang2
  929 A:feb6                           go        
  929 A:feb6  20 77 fe                           jsr a1pc                ; adr to pc if specified
  930 A:feb9  20 3f ff                           jsr restore                ; restore meta registers
  931 A:febc  6c 3a 00                           jmp (pcl)              ; go to user subroutine
  932 A:febf                           regz      
  932 A:febf  4c 1b fb                           jmp regdsp                ; jump to register display
  933 A:fec2                                    ;
  934 A:fec2                                    ; trace command
  935 A:fec2                                    ;
  936 A:fec2                           trace     
  936 A:fec2  c6 34                              dec ysav
  937 A:fec4                           stepz     
  937 A:fec4  20 77 fe                           jsr a1pc                ; adr to pc if specified
  938 A:fec7  4c 87 fa                           jmp step                ; take one step
  939 A:feca                                    ;
  940 A:feca                                    ; execute user command
  941 A:feca                                    ; 
  942 A:feca                           usr       
  942 A:feca  4c f8 03                           jmp usradr                ; to usr subroutine at usradr
  943 A:fecd                                    ;
  944 A:fecd                                    ; write memory range to tape OUT
  945 A:fecd                                    ;
  946 A:fecd                           write     
  946 A:fecd  a9 40                              lda #$40
  947 A:fecf  20 c0 fc                           jsr headr                ; write 10-sec header
  948 A:fed2  a0 27                              ldy #$27
  949 A:fed4                           wr1       
  949 A:fed4  a2 00                              ldx #$00
  950 A:fed6  41 3c                              eor (a1l,x)
  951 A:fed8  48                                 pha 
  952 A:fed9  a1 3c                              lda (a1l,x)
  953 A:fedb  20 ed fe                           jsr wrbyte
  954 A:fede  20 b1 fc                           jsr nxta1
  955 A:fee1  a0 1d                              ldy #$1d
  956 A:fee3  68                                 pla 
  957 A:fee4  90 ee                              bcc wr1
  958 A:fee6  a0 22                              ldy #$22
  959 A:fee8  20 ed fe                           jsr wrbyte
  960 A:feeb  f0 4d                              beq bell
  961 A:feed                           wrbyte    
  961 A:feed  a2 10                              ldx #$10
  962 A:feef                           wrbyt2    
  962 A:feef  0a                                 asl 
  963 A:fef0  20 cd fc                           jsr wrbit
  964 A:fef3  d0 fa                              bne wrbyt2
  965 A:fef5  60                                 rts 
  966 A:fef6                                    ;
  967 A:fef6                                    ; execute command line
  968 A:fef6                                    ;
  969 A:fef6                           crmon     
  969 A:fef6  20 02 fe                           jsr bli                ; handle CR as blank
  970 A:fef9  68                                 pla                    ;  then pop stack
  971 A:fefa  68                                 pla                    ; and return to mon
  972 A:fefb  d0 6c                              bne monz
  973 A:fefd                                    ;
  974 A:fefd                                    ; read memory area from tape IN
  975 A:fefd                                    ;
  976 A:fefd                                    ; first synchronize timing with the header block,
  977 A:fefd                                    ; Then read bytes and check checksum
  978 A:fefd                                    ; 1s and 0s have different lengths, so number and frequency 
  979 A:fefd                                    ; of machine cycles is important for executing this
  980 A:fefd                                    ;
  981 A:fefd                           read      
  981 A:fefd  20 f1 fc                           jsr rd2bit                ; find tapein edge
  982 A:ff00  a9 16                              lda #$16
  983 A:ff02  20 c0 fc                           jsr headr                ; delay 3.5s
  984 A:ff05  85 2e                              sta chksum                ; init checksum = $FF
  985 A:ff07  20 f1 fc                           jsr rd2bit                ; find tapein edge
  986 A:ff0a                           rd2       
  986 A:ff0a  a0 24                              ldy #$24             ; look for sync bit
  987 A:ff0c  20 f4 fc                           jsr rdbit                ; (short 0)
  988 A:ff0f  b0 f9                              bcs rd2                ; loop until found
  989 A:ff11  20 f4 fc                           jsr rdbit                ; skip second sync h-cycle
  990 A:ff14  a0 3b                              ldy #$3b             ; index for 0/1 test
  991 A:ff16                           rd3       
  991 A:ff16  20 e3 fc                           jsr rdbyte                ; read a byte
  992 A:ff19  81 3c                              sta (a1l,x)            ; store at (a1)
  993 A:ff1b  45 2e                              eor chksum
  994 A:ff1d  85 2e                              sta chksum                ; update running checksum
  995 A:ff1f  20 b1 fc                           jsr nxta1                ; incr a1, compare to a2
  996 A:ff22  a0 35                              ldy #$35             ; compensate 0/1 index
  997 A:ff24  90 f0                              bcc rd3                ; loop until done
  998 A:ff26  20 e3 fc                           jsr rdbyte                ; read chksum byte
  999 A:ff29  c5 2e                              cmp chksum
 1000 A:ff2b  f0 0d                              beq bell                ; good, sound bell and return
 1001 A:ff2d                                    ;
 1002 A:ff2d                                    ; print "ERR" and beep
 1003 A:ff2d                                    ;
 1004 A:ff2d                           prerr     
 1004 A:ff2d  a9 c5                              lda #$c5             ; 'E'
 1005 A:ff2f  20 f5 fd                           jsr cout                ; print "ERR" then bell
 1006 A:ff32  a9 d2                              lda #$d2             ; 'R'
 1007 A:ff34  20 f5 fd                           jsr cout
 1008 A:ff37  20 f5 fd                           jsr cout
 1009 A:ff3a                                    ;
 1010 A:ff3a                                    ; ring the terminal bell
 1011 A:ff3a                                    ;
 1012 A:ff3a                           bell      
 1012 A:ff3a  a9 07                              lda #k_ctl_g               ; output bell and return
 1013 A:ff3c  4c f5 fd                           jmp cout                ; reuse cout rts directly here...
 1014 A:ff3f                                    ;
 1015 A:ff3f                                    ; restore registers from zero page storage
 1016 A:ff3f                                    ;
 1017 A:ff3f                           restore   
 1017 A:ff3f  a5 48                              lda status                ; restore 6502 register contents
 1018 A:ff41  48                                 pha                    ;  used by debug software
 1019 A:ff42  a5 45                              lda acc
 1020 A:ff44                           restr1    
 1020 A:ff44  a6 46                              ldx xreg
 1021 A:ff46  a4 47                              ldy yreg
 1022 A:ff48  28                                 plp 
 1023 A:ff49  60                                 rts 
 1024 A:ff4a                                    ;
 1025 A:ff4a                                    ; save 6502 reg contents to zero page storage
 1026 A:ff4a                                    ;
 1027 A:ff4a                           save      
 1027 A:ff4a  85 45                              sta acc
 1028 A:ff4c                           sav1      
 1028 A:ff4c  86 46                              stx xreg
 1029 A:ff4e  84 47                              sty yreg
 1030 A:ff50  08                                 php 
 1031 A:ff51  68                                 pla 
 1032 A:ff52  85 48                              sta status
 1033 A:ff54  ba                                 tsx 
 1034 A:ff55  86 49                              stx spnt
 1035 A:ff57  d8                                 cld 
 1036 A:ff58  60                                 rts 
 1037 A:ff59                                    ;
 1038 A:ff59                                    ; 6502 reset vector
 1039 A:ff59                                    ;
 1040 A:ff59                           reset     
 1040 A:ff59  20 86 fe                           jsr setnorm
 1041 A:ff5c  20 73 fb                           jsr init
 1042 A:ff5f  20 95 fe                           jsr setvid
 1043 A:ff62  20 8b fe                           jsr setkbd
 1044 A:ff65                                    ;
 1045 A:ff65                                    ; Monitor entry point
 1046 A:ff65                                    ;
 1047 A:ff65                           mon       
 1047 A:ff65  d8                                 cld 
 1048 A:ff66  20 3a ff                           jsr bell
 1049 A:ff69                           monz      
 1049 A:ff69  a9 2a                              lda #'*'             ; Monitor prompt
 1050 A:ff6b  85 33                              sta prompt
 1051 A:ff6d  20 6e fd                           jsr getlnz                ; get line
 1052 A:ff70  20 c7 ff                           jsr zmode                ; clear monitor mode, scan idx
 1053 A:ff73                                    ;
 1054 A:ff73                                    ; get the next item from input line
 1055 A:ff73                                    ;
 1056 A:ff73                           nxtitm    
 1056 A:ff73  20 a7 ff                           jsr getnum                ; get item, non-hex
 1057 A:ff76  84 34                              sty ysav
 1058 A:ff78  a0 17                              ldy #$17             ; x-reg=0 if no hex input
 1059 A:ff7a                                    ;
 1060 A:ff7a                                    ; look up command subroutine for current character
 1061 A:ff7a                                    ;
 1062 A:ff7a                           chrsrch   
 1062 A:ff7a  88                                 dey 
 1063 A:ff7b  30 e8                              bmi mon                ; not found, go to mon
 1064 A:ff7d  d9 cc ff                           cmp chrtbl,y              ; find cmnd char in table
 1065 A:ff80  d0 f8                              bne chrsrch
 1066 A:ff82  20 be ff                           jsr tosub                ; found call corresponding subroutine
 1067 A:ff85  a4 34                              ldy ysav
 1068 A:ff87  4c 73 ff                           jmp nxtitm
 1069 A:ff8a                                    ;
 1070 A:ff8a                                    ; get one hex digit from input
 1071 A:ff8a                                    ;
 1072 A:ff8a                           dig       
 1072 A:ff8a  a2 03                              ldx #$03
 1073 A:ff8c  0a                                 asl 
 1074 A:ff8d  0a                                 asl                    ; got hex digit in low nibble, shift into A2
 1075 A:ff8e  0a                                 asl 
 1076 A:ff8f  0a                                 asl                    ; first, position in high nibble of accu
 1077 A:ff90                           nxtbit    
 1077 A:ff90  0a                                 asl                    ; transport a high bit to carry
 1078 A:ff91  26 3e                              rol a2l                ; rotate carry into low byte into carry
 1079 A:ff93  26 3f                              rol a2h                ; rotate carry into high byte
 1080 A:ff95  ca                                 dex                    ; leave x = $FF if digit
 1081 A:ff96  10 f8                              bpl nxtbit
 1082 A:ff98                           nxtbas    
 1082 A:ff98  a5 31                              lda mode
 1083 A:ff9a  d0 06                              bne nxtbs2                ;   if mode is zero
 1084 A:ff9c  b5 3f                              lda a2h,x              ;    then copy a2 to
 1085 A:ff9e  95 3d                              sta a1h,x              ;     a1 and a3
 1086 A:ffa0  95 41                              sta a3h,x
 1087 A:ffa2                           nxtbs2    
 1087 A:ffa2  e8                                 inx 
 1088 A:ffa3  f0 f3                              beq nxtbas
 1089 A:ffa5  d0 06                              bne nxtchr
 1090 A:ffa7                                    ;
 1091 A:ffa7                                    ; getnum read command
 1092 A:ffa7                                    ; result
 1092 A:ffa7                                    
 1093 A:ffa7                                    ;   a - mode
 1094 A:ffa7                                    ;   x - number of numeric args
 1095 A:ffa7                                    ;
 1096 A:ffa7                           getnum    
 1096 A:ffa7  a2 00                              ldx #$00             ;  clear A2
 1097 A:ffa9  86 3f                              stx a2h
 1098 A:ffab  86 3e                              stx a2l
 1099 A:ffad                           nxtchr    
 1099 A:ffad  b9 00 02                           lda in,y              ; get char
 1100 A:ffb0  c8                                 iny 
 1101 A:ffb1  49 30                              eor #$30             ; $30 0 -> $00; $39 9 -> $09; $41 A -> $71; $20 -> $10...
 1102 A:ffb3  c9 0a                              cmp #$0a
 1103 A:ffb5  90 d3                              bcc dig                ; if hex digit
 1104 A:ffb7  69 88                              adc #$88             ; c=1, $76 F + $88 + 1 = $FF; $71 A + $88 + 1 = $FA
 1105 A:ffb9  c9 fa                              cmp #$fa
 1106 A:ffbb  b0 cd                              bcs dig                ; if not a digit a now has ch eor #$30 + $B9
 1107 A:ffbd  60                                 rts 
 1108 A:ffbe                                    ;
 1109 A:ffbe                                    ; Go to command routine
 1110 A:ffbe                                    ;
 1111 A:ffbe                           tosub     
 1111 A:ffbe  a9 fe                              lda #>go              ; Push high order subroutine address on stack
 1112 A:ffc0  48                                 pha 
 1113 A:ffc1  b9 e3 ff                           lda subtbl,y              ; Push low order subroutine address on stack
 1114 A:ffc4  48                                 pha 
 1115 A:ffc5  a5 31                              lda mode                ;  old mode to A
 1116 A:ffc7                                    ;
 1117 A:ffc7                                    ; 
 1118 A:ffc7                           zmode     
 1118 A:ffc7  a0 00                              ldy #$00             ; clr mode,
 1119 A:ffc9  84 31                              sty mode
 1120 A:ffcb  60                                 rts                    ; go to command subroutine previously pushed on the stack

 1122 A:ffcc                           chrtbl    
 1122 A:ffcc  bc                                 .byt (((k_ctl_c^$30)+$89)&$ff)
 1123 A:ffcd  b2                                 .byt (((k_ctl_y^$30)+$89)&$ff)
 1124 A:ffce  be                                 .byt (((k_ctl_e^$30)+$89)&$ff)
 1125 A:ffcf  ed                                 .byt ((('T'^$30)+$89)&$ff)
 1126 A:ffd0  ef                                 .byt ((('V'^$30)+$89)&$ff)
 1127 A:ffd1  c4                                 .byt (((k_ctl_k^$30)+$89)&$ff)
 1128 A:ffd2  ec                                 .byt ((('S'^$30)+$89)&$ff)
 1129 A:ffd3  a9                                 .byt (((k_ctl_p^$30)+$89)&$ff)
 1130 A:ffd4  bb                                 .byt (((k_ctl_b^$30)+$89)&$ff)
 1131 A:ffd5  a6                                 .byt ((('-'^$30)+$89)&$ff)
 1132 A:ffd6  a4                                 .byt ((('+'^$30)+$89)&$ff)
 1133 A:ffd7  06                                 .byt ((('M'^$30)+$89)&$ff)
 1134 A:ffd8  95                                 .byt ((('<'^$30)+$89)&$ff)
 1135 A:ffd9  07                                 .byt ((('N'^$30)+$89)&$ff)
 1136 A:ffda  02                                 .byt ((('I'^$30)+$89)&$ff)
 1137 A:ffdb  05                                 .byt ((('L'^$30)+$89)&$ff)
 1138 A:ffdc  f0                                 .byt ((('W'^$30)+$89)&$ff)
 1139 A:ffdd  00                                 .byt ((('G'^$30)+$89)&$ff)
 1140 A:ffde  eb                                 .byt ((('R'^$30)+$89)&$ff)
 1141 A:ffdf  93                                 .byt (((':'^$30)+$89)&$ff)
 1142 A:ffe0  a7                                 .byt ((('.'^$30)+$89)&$ff)
 1143 A:ffe1  c3                                 .byt (((k_entr^$30)+$89)&$ff)
 1144 A:ffe2  99                                 .byt (((' '^$30)+$89)&$ff)
 1145 A:ffe3                                    ; Monitor commands
 1145 A:ffe3                                    
 1146 A:ffe3                                    ; ctrl-c        bascont
 1147 A:ffe3                                    ; ctrl-y        usr
 1148 A:ffe3                                    ; ctrl-e        regz
 1149 A:ffe3                                    ; 'T'           trace
 1150 A:ffe3                                    ; 'V'           vfy
 1151 A:ffe3                                    ; ctrl-k        inprt
 1152 A:ffe3                                    ; 'S'           stepz
 1153 A:ffe3                                    ; ctrl-p        outprt
 1154 A:ffe3                                    ; ctrl-b        x_lang
 1155 A:ffe3                                    ; '-'           setmode
 1156 A:ffe3                                    ; '+'           setmode
 1157 A:ffe3                                    ; 'M'           move
 1158 A:ffe3                                    ; '<'           lt
 1159 A:ffe3                                    ; 'N'           setnorm
 1160 A:ffe3                                    ; 'I'           setinv
 1161 A:ffe3                                    ; 'L'           list
 1162 A:ffe3                                    ; 'W'           write
 1163 A:ffe3                                    ; 'G'           go
 1164 A:ffe3                                    ; 'R'           read
 1165 A:ffe3                                    ; colon         write area addr1,addr2
 1166 A:ffe3                                    ; '.'           hexdump addr1,addr2
 1167 A:ffe3                                    ; enter         execute monitor command line
 1168 A:ffe3                                    ; ' '           add preceding command to line

 1170 A:ffe3                           subtbl    
 1170 A:ffe3  b3                                 .byt <bascont               ; CTL-C - exit moitor to installed language
 1171 A:ffe4  ca                                 .byt <usr               ; CTL-Y - execute user command at vector %3F8
 1172 A:ffe5  bf                                 .byt <regz               ; CTL-E - examine registers
 1173 A:ffe6  c2                                 .byt <trace               ; "T" - Trace until reset or brk
 1174 A:ffe7  38                                 .byt <vfy               ; "V" - Verify memory range
 1175 A:ffe8  8f                                 .byt <inprt               ; [0-7] CTL-K - input from keyboard (0) or peripheral card 1-7
 1176 A:ffe9  c4                                 .byt <stepz               ; "S" - Step
 1177 A:ffea  99                                 .byt <outprt               ; [0-7] CTL-P - send output to video (0) or printer peripheral 1-7
 1178 A:ffeb  b0                                 .byt <x_lang               ; CTL-B -
 1179 A:ffec  1a                                 .byt <setmode               ; "-" - hexadecimal substraction
 1180 A:ffed  1a                                 .byt <setmode               ; "+" - hexadecimal addition
 1181 A:ffee  2e                                 .byt <move               ; "M" - mpve memory range
 1182 A:ffef  22                                 .byt <lt               ; "< aaaa.bbbb M|V" - Move / compare memory range
 1183 A:fff0  86                                 .byt <setnorm               ; "N" - set to normal output
 1184 A:fff1  82                                 .byt <setinv               ; "I" - set to inverse output
 1185 A:fff2  60                                 .byt <list               ; "L" - list preceding memory add
 1186 A:fff3  cd                                 .byt <write               ; "aaaa.bbbb W" - Save memory range on tape
 1187 A:fff4  b6                                 .byt <go               ; "aaaa G" - Run program as subroutine at aaaa
 1188 A:fff5  fd                                 .byt <read               ; "aaaa.bbbb R" - Read memory range from tape
 1189 A:fff6  1a                                 .byt <setmode               ; colon xx yy... - change current location. to given ehx bytes
 1190 A:fff7  1a                                 .byt <setmode               ; ".yyyy" - examine bytes between after current position and yyyy
 1191 A:fff8  f6                                 .byt <crmon               ; enter - starts evaluation of commands in input line
 1192 A:fff9  06                                 .byt <blank               ; space separator
 1193 A:fffa                                    ;
 1194 A:fffa                                    ; 6502 fixed system vectors. Must start at 0xFFFA
 1195 A:fffa                                    ; .org not working here, adjusting with
 1196 A:fffa                                    ; .dsb block "keep_aligned" above
 1197 A:fffa                                    ;
 1198 A:fffa                           sysvec_nmi 
 1198 A:fffa  fb 03                              .word nmiloc                ; nmi vector set up in RAM by reset routine
 1199 A:fffc                           sysvec_reset 
 1199 A:fffc  59 ff                              .word reset                ; reset vector
 1200 A:fffe                           sysvec_irq 
 1200 A:fffe  ca fa                              .word irqvec                ; irq vector in rom
