
rom.s

    1 A:1000                                    ;
    2 A:1000                                    ; haiku6502 ROM
    3 A:1000                                    ;
    4 A:1000                                    ; Annotated and modified emulator ROM using orig_monitor_rom.s as a template.
    5 A:1000                                    ; This code is only for academic purposes.
    6 A:1000                                    ; This file is compatible with xa assembler and is not relocatable.
    7 A:1000                                    ; Care has to be taken to keep the "go" jump table addresses area on page 0xFE or else it will cease to work this way.
    8 A:1000                                    ; There are a few nifty tricks in the original assembler code to save a few bytes here and there that probably
    9 A:1000                                    ; would not have been done this way were there more than 12KB address space available for ROM.
   10 A:1000                                    ;
   11 A:1000                                    ; The following modifications have been made:
   12 A:1000                                    ;
   13 A:1000                                    ; - fixed character mapping. ASCII chars are now ASCII chars in the right code points.
   14 A:1000                                    ; - removed memory mapped text and graphics screens. The screen is now a terminal peripheral controlled
   15 A:1000                                    ;   through I/O ports 0xC010-0xC01F
   16 A:1000                                    ; - keyboard strobe is now in 0xC001, to make space for more i/o control addresses
   17 A:1000                                    ; - removed screen address calculations, no longer needed with sane terminal cursor coordinates that
   18 A:1000                                    ;   are no longer aligned with cathode ray tube electronic beam scan sequence.
   19 A:1000                                    ; - Bell just sends a CTL-G to terminal
   20 A:1000                                    ; - Tape in/out goes to a tape file. with the right sampling rate, it should be possible to read in data tapes.
   21 A:1000                                    ;   not much use though, since the rom routine addresses are now no longer compatible.
   22 A:1000                                    ;   TODO: Should be changed to just write the content to some output file, would make much more sense.
   23 A:1000                                    ; - The screen size is taken from the terminal dimensions. Size is no longer restricted to 1KB text pages.
   24 A:1000                                    ; - Lo-Res and Hi-Res graphics modes are gone for now since they don't work too well with the standard ncurses based
   25 A:1000                                    ;   terminal peripheral. A graphics terminal peripheral could be added, though.
   26 A:1000                                    ; - The peripheral system is not completed, especially emulator interrupt management is rudimentary. So peripheral
   27 A:1000                                    ;   rom areas can be addressed, but the extension rom area 0xC800-0xC8FF needs work. This does not ffect this rom,
   28 A:1000                                    ;   though...
   29 A:1000                                    ; - Added 'Q' command to monitor to terminate emulator via jump to address $FFFF
   30 A:1000                                    ; - Added Mni-Assembler command as '!', '*' returns from mini-assembler to monitor
   31 A:1000                                    ; - Mini-Assembler resurrected following mostly the manual description. It is a complete new implementation in asm.s
   32 A:1000                                    ; The monitor part works pretty much the same as described in the Apple II Reference Manual. It has a nice disassembler.
   33 A:1000                                    ; It provides RAM editing as hex dump only for now.
   34 A:1000                                    ;
   35 A:1000                                    ; Memory layout:
   36 A:1000                                    ;
   37 A:1000                                    ; 0x0000-0x00FF Zero page
   38 A:1000                                    ; 0x0100-9x01FF Stack
   39 A:1000                                    ; 0x0200-0x02FF text buffer
   40 A:1000                                    ; 0x0300-0x03FF system vars & vectors
   41 A:1000                                    ; 0x0400-0xBFFF free RAM
   42 A:1000                                    ; 0xC000-0xCFFF I/O
   43 A:1000                                    ; 0xD000-0xFFFF ROM; thereof
   44 A:1000                                    ;               0xD000 - 0xF500 Reserved for language modules
   45 A:1000                                    ;               0xF4BF - 0xF800 Mini-Assembler (asm.s)
   46 A:1000                                    ;               0xF800 - 0xFFFF System Monitor ROM
   47 A:1000                                    ;               0xFFFA - 0xFFFF Hardwired 6502 NMI, Reset and IRQ vectors, have to be kept at fixed addresses.
   48 A:1000                                    ; On Reset, the program counter is loaded from 0xFFFC and 0xFFFD. all addresses with least
   49 A:1000                                    ; significant (lsb,low) byte first.
   50 A:1000                                    ;
   51 A:1000                                    ; TODO Fix remaining bugs, cleanup code
   52 A:1000                                    ;

   54 A:1000                                     .include "symbols.inc"

symbols.inc

    1 A:1000                                    ; common symbol definitions, based on
    2 A:1000                                    ; 1979 Apple ][ Reference Manual, Monitor ROM Listing

    4 A:1000                                    loc0=$00
    5 A:1000                                    loc1=$01
    6 A:1000                                    wndlft=$20
    7 A:1000                                    wndwdth=$21
    8 A:1000                                    wndtop=$22
    9 A:1000                                    wndbtm=$23
   10 A:1000                                    ch=$24
   11 A:1000                                    cv=$25
   12 A:1000                                    tpdir=$26           ; tape direction for header op - 0 write, 1 read
   13 A:1000                                    rdline=$28           ; vector for readline
   14 A:1000                                    rdlinh=$29           ;   msb
   15 A:1000                                    h2=$2c
   16 A:1000                                    lmnem=$2c
   17 A:1000                                    rtnl=$2c
   18 A:1000                                    v2=$2d
   19 A:1000                                    rmnem=$2d
   20 A:1000                                    rtnh=$2d
   21 A:1000                                    mask=$2e
   22 A:1000                                    chksum=$2e
   23 A:1000                                    format=$2e
   24 A:1000                                    lastin=$2f
   25 A:1000                                    length=$2f
   26 A:1000                                    sign=$2f
   27 A:1000                                    color=$30
   28 A:1000                                    mode=$31
   29 A:1000                                    invflg=$32
   30 A:1000                                    prompt=$33
   31 A:1000                                    ysav=$34
   32 A:1000                                    ysav1=$35
   33 A:1000                                    cswl=$36           ; CSW character out vector
   34 A:1000                                    cswh=$37
   35 A:1000                                    kswl=$38           ; keyboard input vector
   36 A:1000                                    kswh=$39
   37 A:1000                                    pcl=$3a
   38 A:1000                                    pch=$3b
   39 A:1000                                    xqt=$3c
   40 A:1000                                    xqtnz=$3c
   41 A:1000                                    a1l=$3c
   42 A:1000                                    a1h=$3d
   43 A:1000                                    a2l=$3e
   44 A:1000                                    a2h=$3f
   45 A:1000                                    a3l=$40
   46 A:1000                                    a3h=$41
   47 A:1000                                    a4l=$42
   48 A:1000                                    a4h=$43
   49 A:1000                                    a5l=$44
   50 A:1000                                    opcode=$44           ; temp opcode for assembler
   51 A:1000                                    a5h=$45
   52 A:1000                                    adrl=$45           ; low address byte for assembler
   53 A:1000                                    acc=$45
   54 A:1000                                    adrh=$46           ; high address byte for assembler
   55 A:1000                                    xreg=$46
   56 A:1000                                    opb=$47           ; opcode 'b' bits
   57 A:1000                                    yreg=$47
   58 A:1000                                    cmdlen=$47           ; instruction length for assembler, 1-3 bytes
   59 A:1000                                    status=$48
   60 A:1000                                    spnt=$49
   61 A:1000                                    rndl=$4e           ; pseudo-random
   62 A:1000                                    rndh=$4f
   63 A:1000                                    acl=$50
   64 A:1000                                    ach=$51
   65 A:1000                                    xtndl=$52
   66 A:1000                                    xtndh=$53
   67 A:1000                                    auxl=$54
   68 A:1000                                    auxh=$55
   69 A:1000                                    in=$0200           ; input buffer base
   70 A:1000                                    usradr=$03f8
   71 A:1000                                    nmiloc=$03fb
   72 A:1000                                    irqloc=$03fe
   73 A:1000                                    ioadr=$c000
   74 A:1000                                    kbd=$c000
   75 A:1000                                    kbdstrb=$c001
   76 A:1000                                    rnd=$c00f           ; random byte RO
   77 A:1000                                    termcy=$c010           ; terminal cursor y   RW
   78 A:1000                                    termcx=$c011           ; terminal cursor x   RW
   79 A:1000                                    termout=$c012           ; termout character under cursor RW
   80 A:1000                                    termesc=$c013           ; terminal connamd byte W
   81 A:1000                                    termea1=$c014           ; terminal command argl   (bad design, will change)
   82 A:1000                                    termea2=$c015           ; terminal command argh
   83 A:1000                                    termwh=$c016           ; temrinal window height
   84 A:1000                                    termww=$c017           ; terminal window width
   85 A:1000                                    termin=$c018
   86 A:1000                                    terml=$c019           ; stdio mode next line char of 0 terminated string. R
   87 A:1000                                    termp=$c01a           ; stdio mode next line char of 0 terminated string. RW
   88 A:1000                                    termmd=$c01f           ; terminal mode, RO. #$00 - screen, #$01 - stdio
   89 A:1000                                    tapeout=$c020
   90 A:1000                                    tapein=$c021
   91 A:1000                                    tapecls=$c022
   92 A:1000                                    spkr=$c030
   93 A:1000                                    paddl0=$c061
   94 A:1000                                    ptrig=$c070

   96 A:1000                                    ;
   97 A:1000                                    ;  Ecape commands for terminal:
   98 A:1000                                    ;
   99 A:1000                                    t_cls=$00           ; Clear screen
  100 A:1000                                    t_cll=$01           ; clear from cursor to end of line
  101 A:1000                                    t_clb=$02           ; clear from cursor to end of line
  102 A:1000                                    t_scr=$03           ; scroll one line up
  103 A:1000                                    t_norm=$04           ; normal chars
  104 A:1000                                    t_inv=$05           ; inverse chars
  105 A:1000                                    t_blnk=$06           ; blinking chars
  106 A:1000                                    t_qcch=$07           ; query current character under cursor

  108 A:1000                                    ; t_qy    = $04   ; query terminal cursor y; for result read terminl,h
  109 A:1000                                    ; t_qx    = $05   ; query terminal cursor x; for result read terminl,h

  111 A:1000                                    ; characters
  112 A:1000                                    k_ctl_a=$01
  113 A:1000                                    k_ctl_b=$02
  114 A:1000                                    k_ctl_c=$03
  115 A:1000                                    k_ctl_d=$04
  116 A:1000                                    k_ctl_e=$05
  117 A:1000                                    k_ctl_f=$06
  118 A:1000                                    k_ctl_g=$07
  119 A:1000                                    k_bs=$08
  120 A:1000                                    k_tab=$09
  121 A:1000                                    k_lf=$0a
  122 A:1000                                    k_ctl_k=$0b
  123 A:1000                                    k_ctl_l=$0c
  124 A:1000                                    k_cr=$0a
  125 A:1000                                    k_ctl_n=$0e
  126 A:1000                                    k_ctl_o=$0f
  127 A:1000                                    k_ctl_p=$10
  128 A:1000                                    k_ctl_q=$11
  129 A:1000                                    k_ctl_r=$12
  130 A:1000                                    k_ctl_s=$13
  131 A:1000                                    k_ctl_t=$14
  132 A:1000                                    k_ctl_u=$15
  133 A:1000                                    k_ctl_v=$16
  134 A:1000                                    k_ctl_w=$17
  135 A:1000                                    k_ctl_x=$18
  136 A:1000                                    k_ctl_y=$19
  137 A:1000                                    k_ctl_z=$1a
  138 A:1000                                    k_esc=$1b
  139 A:1000                                    k_entr=k_cr
  140 A:1000                                    gr_top='+'
  141 A:1000                                    gr_btm='_'
  142 A:1000                                    colon=$3a
  143 A:1000                                    gr_grid=$61

rom.s


   56 A:1000                                     *= $d000              ; ROM start address
   57 A:d000  00 ff 00 10 00 24 2c ...           .dsb $1000,$00        ; first filler, 4KB low ROM
   58 A:e000                           lang      
   58 A:e000  20 06 e0                           jsr lang_init
   59 A:e003                           lang2     
   59 A:e003  4c 07 e0                           jmp lang_cont
   60 A:e006                           lang_init 
   60 A:e006  60                                 rts 
   61 A:e007                           lang_cont 
   61 A:e007  00 ff b2 14 00 24 2c ...           .dsb $14b2,$00        ; filler up to F800

   63 A:f4b9                                     .include "asm.s"

asm.s

    1 A:f4b9                                    ;
    2 A:f4b9                                    ; Mini-Assembler
    3 A:f4b9                                    ;
    4 A:f4b9                                    ; Assembles single instruction at the program cursor into machine code.
    5 A:f4b9                                    ; Following the syntax documented in the Apple II Reference manual
    6 A:f4b9                                    ;
    7 A:f4b9                                    ; xa assembler seems to have some obscure problems with block markers, so everything
    8 A:f4b9                                    ; is on top level. I tried with block proc and (, but tht produced sntax errors far, far away
    9 A:f4b9                                    ; Solution would be to use a different assembler. but they all have their quirks.
   10 A:f4b9                                    ;
   11 A:f4b9                           nextch    
   11 A:f4b9  c8                                 iny 
   12 A:f4ba  b9 00 02                           lda in,y
   13 A:f4bd  60                                 rts 
   14 A:f4be                                    ;
   15 A:f4be                                    ; consume blanks and $ signs,
   16 A:f4be                                    ; since all numbers are hex
   17 A:f4be                                    ; returns first non ignored char in a
   18 A:f4be                                    ;
   19 A:f4be                           eatblp    
   19 A:f4be  c8                                 iny 
   20 A:f4bf                           eatblank  
   20 A:f4bf  b9 00 02                           lda in,y
   21 A:f4c2  c9 20                              cmp #' '
   22 A:f4c4  f0 f8                              beq eatblp
   23 A:f4c6  c9 24                              cmp #'$'
   24 A:f4c8  f0 f4                              beq eatblp
   25 A:f4ca  60                                 rts 
   26 A:f4cb                                    ; get code for menmonic
   27 A:f4cb                                    ; input: a has first letter.
   28 A:f4cb                                    ; return: mnem index in x
   29 A:f4cb                           syntaxerr 
   29 A:f4cb  20 15 ff                           jsr bell
   30 A:f4ce  a9 20                              lda #' '
   31 A:f4d0                           @blnks    
   31 A:f4d0  20 7f fd                           jsr cout
   32 A:f4d3  88                                 dey 
   33 A:f4d4  10 fa                              bpl @blnks
   34 A:f4d6  a9 5e                              lda #'^'
   35 A:f4d8  20 7f fd                           jsr cout
   36 A:f4db  a6 49                              ldx spnt                ; restore entry point stack position
   37 A:f4dd  9a                                 txs 
   38 A:f4de  4c fb f4                           jmp asmz

   40 A:f4e1                           setaddr   
   40 A:f4e1  20 aa ff                           jsr zmode                ; clear (reused) monitor mode, scan idx
   41 A:f4e4  20 85 ff                           jsr getnum
   42 A:f4e7  60                                 rts 
   43 A:f4e8                           hasaddr   
   43 A:f4e8  a0 04                              ldy #$04             ; look at first 5 chars, beginning with last
   44 A:f4ea                           @hadrlp   
   44 A:f4ea  b9 00 02                           lda in,y
   45 A:f4ed  c9 3a                              cmp #':'
   46 A:f4ef  f0 f0                              beq setaddr                ; if so, set current address
   47 A:f4f1  88                                 dey 
   48 A:f4f2  10 f6                              bpl @hadrlp
   49 A:f4f4  a0 00                              ldy #$00             ; no address found, reset 'in' pointer
   50 A:f4f6  60                                 rts 
   51 A:f4f7                                    ;
   52 A:f4f7                                    ; Mini-Assembler entry point.
   53 A:f4f7                                    ;
   54 A:f4f7                           asm_entry 
   54 A:f4f7  d8                                 cld                    ; who knows where we came from... bcd mode tends to confuse hex based arithmetics.
   55 A:f4f8                                    ;
   56 A:f4f8                                    ; save stack pointer to spnt to return to clean state
   57 A:f4f8                                    ; when processing syntax errors
   58 A:f4f8                                    ; from deeper subroutine level.
   59 A:f4f8                                    ; very crude exception handling.
   60 A:f4f8                                    ; This makes it possible to handle syntax errors in subroutines
   61 A:f4f8                                    ; without too much overhead - process is aborted and asm returns to prompt.
   62 A:f4f8                                    ;
   63 A:f4f8  ba                                 tsx 
   64 A:f4f9  86 49                              stx spnt
   65 A:f4fb                                    ;
   66 A:f4fb                                    ; main assembler loop
   67 A:f4fb                                    ;
   68 A:f4fb                           asmz      
   68 A:f4fb  a9 21                              lda #'!'
   69 A:f4fd  85 33                              sta prompt                ; set prompt to '!'
   70 A:f4ff  20 f5 fc                           jsr getlnz                ; get line
   71 A:f502  20 aa ff                           jsr zmode
   72 A:f505  20 e8 f4                           jsr hasaddr                ; see if line has address label "%x:"
   73 A:f508  a2 01                              ldx #$01
   74 A:f50a                           @setpcl   
   74 A:f50a  b5 3c                              lda a1l,x
   75 A:f50c  95 3a                              sta pcl,x
   76 A:f50e  ca                                 dex 
   77 A:f50f  10 f9                              bpl @setpcl

   79 A:f511  20 bf f4                           jsr eatblank                ; skip whitespace
   80 A:f514                                    ;
   81 A:f514                                    ; on '*' return to monitor.
   82 A:f514                                    ;
   83 A:f514  c9 2a                              cmp #'*'
   84 A:f516  d0 03                              bne @procmnm
   85 A:f518  4c 47 ff                           jmp monz
   86 A:f51b                                    ;
   87 A:f51b                                    ; get the mnemonic from input line
   88 A:f51b                                    ;
   89 A:f51b                                    ;
   90 A:f51b                                    ; get coded mnemonic into a4
   91 A:f51b                                    ; ((menm0 & 0x1f) << 10) + ((menm1 & 0x1f) << 5) + (menm2 & 0x1f)
   92 A:f51b                                    ; so the opcode forms a word with 13 bits used.
   93 A:f51b                                    ; impossible mnemonics produce a syntax error, invalid mnemonics will produce an
   94 A:f51b                                    ; unknown opcode
   95 A:f51b                                    ;
   96 A:f51b                           @procmnm  
   96 A:f51b  29 1f                              and #$1f             ; ex.:  PHP                                            'P' = $50 -> $10
   97 A:f51d  85 43                              sta a4h                ;
   98 A:f51f  20 b9 f4                           jsr nextch                ; $1F useful bits, have to make room for 5 more        `H' = $48, useful $08
   99 A:f522  0a                                 asl                    ; $3E                                                        $90
  100 A:f523  0a                                 asl                    ; $7C                                                        $20
  101 A:f524  0a                                 asl                    ; $F8                                                        $40
  102 A:f525  0a                                 asl                    ; $01F0 high bit-> carry                                     $80 + 0
  103 A:f526  26 43                              rol a4h                ; $3FF0                                               $20    $80
  104 A:f528  0a                                 asl                    ; $03E0 high bit-> carry                                     $00 + 1
  105 A:f529  26 43                              rol a4h                ; $7FE0                                               $41    $00
  106 A:f52b  85 42                              sta a4l                ; $E0 , five lower bits free                                 $00
  107 A:f52d  20 b9 f4                           jsr nextch                ; $1F                                                  'P' = $50
  108 A:f530  29 1f                              and #$1f             ;                                                            $10
  109 A:f532  05 42                              ora a4l                ;                                                            $10
  110 A:f534  85 42                              sta a4l                ;                                                     $41    $10
  111 A:f536                                    ;
  112 A:f536                                    ; now we have the short form in a4.
  113 A:f536                                    ; go on to find the mnemonic in opcodex table
  114 A:f536                                    ; and tehn return this index to the opcode lookup tables
  115 A:f536  a2 71                              ldx #(opcodez-opcodex-1)+2
  116 A:f538                           @firstfail 
  116 A:f538  ca                                 dex 
  117 A:f539                           @scndfail 
  117 A:f539  ca                                 dex 
  118 A:f53a  30 8f                              bmi syntaxerr
  119 A:f53c  bd 56 f5                           lda opcodex,x     high
  120 A:f53f  c5 43                              cmp a4h
  121 A:f541  d0 f5                              bne @firstfail
  122 A:f543  ca                                 dex 
  123 A:f544  bd 56 f5                           lda opcodex,x     low
  124 A:f547  c5 42                              cmp a4l
  125 A:f549  d0 ee                              bne @scndfail
  126 A:f54b  8a                                 txa 
  127 A:f54c  4a                                 lsr                    ; rest of the tables have bytes not words, so half.
  128 A:f54d  85 42                              sta a4l
  129 A:f54f  c8                                 iny                    ; point to char after mnemonic
  130 A:f550                                    ;
  131 A:f550                                    ; at this point, we have the address set in a1-a3 and the
  132 A:f550                                    ; mnemonic code number in a4l.
  133 A:f550                                    ; Now proceed to  evaluate address part.
  134 A:f550                                    ; Following modes are possible:
  135 A:f550                                    ; - None. Command does not take arguments, it is finished.
  136 A:f550                                    ; - Immediate:  #Value
  137 A:f550                                    ; - Adr/Rel:    Address
  138 A:f550                                    ; - Indexed:    Address,X|Y
  139 A:f550                                    ; - indirect:   (Address)
  140 A:f550                                    ; - indir. indxd (Address),Y
  141 A:f550                                    ; - indexed ind. (Address,X)
  142 A:f550  20 bf f4                           jsr eatblank
  143 A:f553  4c a3 f6                           jmp eval_arg
  144 A:f556                                    ;
  145 A:f556                                    ; opcode char mappings
  146 A:f556                                    ;
  147 A:f556                           opcodex   
  147 A:f556                                    
  148 A:f556                                     .include "opcodes_compressed.s"

opcodes_compressed.s

    1 A:f556                                    ;
    2 A:f556                                    ; opcode char mappings
    3 A:f556                                    ;
    4 A:f556                                    ; mnemonic letters lower 5 bits with first letter left shifted 10 bits,
    5 A:f556                                    ; second letter left-shifted 5 bits.
    6 A:f556                                    ;
    7 A:f556                                    ; python calc_opval.py > opcodes_compressed.s
    8 A:f556                                    ;
    9 A:f556  83 04                              .word $0483              ; ADC   - $00   ($00)
   10 A:f558  c4 05                              .word $05c4              ; AND   - $01   ($02)
   11 A:f55a  6c 06                              .word $066c              ; ASL   - $02   ($04)
   12 A:f55c  63 08                              .word $0863              ; BCC   - $03   ($06)
   13 A:f55e  73 08                              .word $0873              ; BCS   - $04   ($08)
   14 A:f560  b1 08                              .word $08b1              ; BEQ   - $05   ($0a)
   15 A:f562  34 09                              .word $0934              ; BIT   - $06   ($0c)
   16 A:f564  a9 09                              .word $09a9              ; BMI   - $07   ($0e)
   17 A:f566  c5 09                              .word $09c5              ; BNE   - $08   ($10)
   18 A:f568  0c 0a                              .word $0a0c              ; BPL   - $09   ($12)
   19 A:f56a  4b 0a                              .word $0a4b              ; BRK   - $0a   ($14)
   20 A:f56c  c3 0a                              .word $0ac3              ; BVC   - $0b   ($16)
   21 A:f56e  d3 0a                              .word $0ad3              ; BVS   - $0c   ($18)
   22 A:f570  83 0d                              .word $0d83              ; CLC   - $0d   ($1a)
   23 A:f572  84 0d                              .word $0d84              ; CLD   - $0e   ($1c)
   24 A:f574  89 0d                              .word $0d89              ; CLI   - $0f   ($1e)
   25 A:f576  96 0d                              .word $0d96              ; CLV   - $10   ($20)
   26 A:f578  b0 0d                              .word $0db0              ; CMP   - $11   ($22)
   27 A:f57a  18 0e                              .word $0e18              ; CPX   - $12   ($24)
   28 A:f57c  19 0e                              .word $0e19              ; CPY   - $13   ($26)
   29 A:f57e  a3 10                              .word $10a3              ; DEC   - $14   ($28)
   30 A:f580  b8 10                              .word $10b8              ; DEX   - $15   ($2a)
   31 A:f582  b9 10                              .word $10b9              ; DEY   - $16   ($2c)
   32 A:f584  f2 15                              .word $15f2              ; EOR   - $17   ($2e)
   33 A:f586  c3 25                              .word $25c3              ; INC   - $18   ($30)
   34 A:f588  d8 25                              .word $25d8              ; INX   - $19   ($32)
   35 A:f58a  d9 25                              .word $25d9              ; INY   - $1a   ($34)
   36 A:f58c  b0 29                              .word $29b0              ; JMP   - $1b   ($36)
   37 A:f58e  72 2a                              .word $2a72              ; JSR   - $1c   ($38)
   38 A:f590  81 30                              .word $3081              ; LDA   - $1d   ($3a)
   39 A:f592  98 30                              .word $3098              ; LDX   - $1e   ($3c)
   40 A:f594  99 30                              .word $3099              ; LDY   - $1f   ($3e)
   41 A:f596  72 32                              .word $3272              ; LSR   - $20   ($40)
   42 A:f598  f0 39                              .word $39f0              ; NOP   - $21   ($42)
   43 A:f59a  41 3e                              .word $3e41              ; ORA   - $22   ($44)
   44 A:f59c  01 41                              .word $4101              ; PHA   - $23   ($46)
   45 A:f59e  10 41                              .word $4110              ; PHP   - $24   ($48)
   46 A:f5a0  81 41                              .word $4181              ; PLA   - $25   ($4a)
   47 A:f5a2  90 41                              .word $4190              ; PLP   - $26   ($4c)
   48 A:f5a4  ec 49                              .word $49ec              ; ROL   - $27   ($4e)
   49 A:f5a6  f2 49                              .word $49f2              ; ROR   - $28   ($50)
   50 A:f5a8  89 4a                              .word $4a89              ; RTI   - $29   ($52)
   51 A:f5aa  93 4a                              .word $4a93              ; RTS   - $2a   ($54)
   52 A:f5ac  43 4c                              .word $4c43              ; SBC   - $2b   ($56)
   53 A:f5ae  a3 4c                              .word $4ca3              ; SEC   - $2c   ($58)
   54 A:f5b0  a4 4c                              .word $4ca4              ; SED   - $2d   ($5a)
   55 A:f5b2  a9 4c                              .word $4ca9              ; SEI   - $2e   ($5c)
   56 A:f5b4  81 4e                              .word $4e81              ; STA   - $2f   ($5e)
   57 A:f5b6  98 4e                              .word $4e98              ; STX   - $30   ($60)
   58 A:f5b8  99 4e                              .word $4e99              ; STY   - $31   ($62)
   59 A:f5ba  38 50                              .word $5038              ; TAX   - $32   ($64)
   60 A:f5bc  39 50                              .word $5039              ; TAY   - $33   ($66)
   61 A:f5be  78 52                              .word $5278              ; TSX   - $34   ($68)
   62 A:f5c0  01 53                              .word $5301              ; TXA   - $35   ($6a)
   63 A:f5c2  13 53                              .word $5313              ; TXS   - $36   ($6c)
   64 A:f5c4  21 53                              .word $5321              ; TYA   - $37   ($6e)

asm.s

    1 A:f5c6                           opcodez   
    1 A:f5c6                                    

  150 A:f5c6                                    ;
  151 A:f5c6                                    ; opmode groups
  152 A:f5c6                                    ;
  153 A:f5c6                                    ;                                       |Impl|Imm|Abs |Zero|z_x |z_y |a_x |a_y |Rel |ix_ir|ir_ix|Ind
  154 A:f5c6                                    ; type 0: implied/accu, no arguments    | *  |   |    |    |    |    |    |    |    |     |     |
  155 A:f5c6                                    ; type 1: relative                      |    |   |(*) |    |    |    |    |    | <- |     |     |
  156 A:f5c6                                    ; type 2: full in (like adc)            |    | * | *  | *  | *  |    | *  | *  |    | *   | *   |
  157 A:f5c6                                    ; type 3: full out (without implied)    |    |   | *  | *  | *  |    | *  | *  |    | *   | *   |
  158 A:f5c6                                    ; type 4: shifting                      | *  |   | *  | *  | *  |    | *  |    |    |     |     |
  159 A:f5c6                                    ; type 5: cpx                           |    | * | *  | *  |    |    |    |    |    |     |     |
  160 A:f5c6                                    ; type 6: bit                           |    |   | *  | *  |    |    |    |    |    |     |     |
  161 A:f5c6                                    ; type 7: dec                           |    |   | *  | *  | *  |    | *  |    |    |     |     |
  162 A:f5c6                                    ; type 8: jmp                           |    |   | *  |    |    |    |    |    |    |     |     | *
  163 A:f5c6                                    ; type 9: jsr                           |    |   | *  |    |    |    |    |    |    |     |     |
  164 A:f5c6                                    ; type a: ldx/ldy changing index reg    |    | * |    | *  | y  | x  | y  | x  |    |     |     |
  165 A:f5c6                                    ; type b: stx/sty changing index reg    |    |   | *  | *  | y  | x  |    |    |    |     |     |
  166 A:f5c6                                    ;
  167 A:f5c6                           opmodes   
  167 A:f5c6                                    
  168 A:f5c6  02                                 .byt $02              ; 'ADC'    - 00
  169 A:f5c7  02                                 .byt $02              ; 'AND'
  170 A:f5c8  04                                 .byt $04              ; 'ASL'
  171 A:f5c9  01                                 .byt $01              ; 'BCC'
  172 A:f5ca  01                                 .byt $01              ; 'BCS'
  173 A:f5cb  01                                 .byt $01              ; 'BEQ'
  174 A:f5cc  06                                 .byt $06              ; 'BIT'
  175 A:f5cd  01                                 .byt $01              ; 'BMI'
  176 A:f5ce  01                                 .byt $01              ; 'BNE'    - 08
  177 A:f5cf  01                                 .byt $01              ; 'BPL'
  178 A:f5d0  00                                 .byt $00              ; 'BRK'
  179 A:f5d1  01                                 .byt $01              ; 'BVC'
  180 A:f5d2  01                                 .byt $01              ; 'BVS'
  181 A:f5d3  00                                 .byt $00              ; 'CLC'
  182 A:f5d4  00                                 .byt $00              ; 'CLD'
  183 A:f5d5  00                                 .byt $00              ; 'CLI'
  184 A:f5d6  00                                 .byt $00              ; 'CLV'    - 10
  185 A:f5d7  02                                 .byt $02              ; 'CMP'
  186 A:f5d8  05                                 .byt $05              ; 'CPX'
  187 A:f5d9  05                                 .byt $05              ; 'CPY'
  188 A:f5da  07                                 .byt $07              ; 'DEC'
  189 A:f5db  00                                 .byt $00              ; 'DEX'
  190 A:f5dc  00                                 .byt $00              ; 'DEY'
  191 A:f5dd  02                                 .byt $02              ; 'EOR'
  192 A:f5de  07                                 .byt $07              ; 'INC'    - 18
  193 A:f5df  00                                 .byt $00              ; 'INX'
  194 A:f5e0  00                                 .byt $00              ; 'INY'
  195 A:f5e1  08                                 .byt $08              ; 'JMP'
  196 A:f5e2  09                                 .byt $09              ; 'JSR'
  197 A:f5e3  02                                 .byt $02              ; 'LDA'
  198 A:f5e4  0a                                 .byt $0a              ; 'LDX'
  199 A:f5e5  0a                                 .byt $0a              ; 'LDY'
  200 A:f5e6  04                                 .byt $04              ; 'LSR'    - 20
  201 A:f5e7  00                                 .byt $00              ; 'NOP'
  202 A:f5e8  02                                 .byt $02              ; 'ORA'
  203 A:f5e9  00                                 .byt $00              ; 'PHA'
  204 A:f5ea  00                                 .byt $00              ; 'PHP'
  205 A:f5eb  00                                 .byt $00              ; 'PLA'
  206 A:f5ec  00                                 .byt $00              ; 'PLP'
  207 A:f5ed  04                                 .byt $04              ; 'ROL'
  208 A:f5ee  04                                 .byt $04              ; 'ROR'    - 28
  209 A:f5ef  00                                 .byt $00              ; 'RTI'
  210 A:f5f0  00                                 .byt $00              ; 'RTS'
  211 A:f5f1  02                                 .byt $02              ; 'SBC'
  212 A:f5f2  00                                 .byt $00              ; 'SEC'
  213 A:f5f3  00                                 .byt $00              ; 'SED'
  214 A:f5f4  00                                 .byt $00              ; 'SEI'
  215 A:f5f5  03                                 .byt $03              ; 'STA'
  216 A:f5f6  0b                                 .byt $0b              ; 'STX'    - 30
  217 A:f5f7  0b                                 .byt $0b              ; 'STY'
  218 A:f5f8  00                                 .byt $00              ; 'TAX'
  219 A:f5f9  00                                 .byt $00              ; 'TAY'
  220 A:f5fa  00                                 .byt $00              ; 'TSX'
  221 A:f5fb  00                                 .byt $00              ; 'TXA'
  222 A:f5fc  00                                 .byt $00              ; 'TXS'
  223 A:f5fd  00                                 .byt $00              ; 'TYA'    - 37
  224 A:f5fe                           opmodez   
  224 A:f5fe                                    
  225 A:f5fe                                    ;
  226 A:f5fe                                    ;   This is the basic opcodes with bits %aaabbbcc
  227 A:f5fe                                    ;   for instructions that only have implied mode
  228 A:f5fe                                    ;   the full opcode is given with bbb bits
  229 A:f5fe                                    ;   also set to speed up emission.
  230 A:f5fe                                    ;   see https:
  231 A:f5fe                                    ;
  232 A:f5fe                           code_ac   
  232 A:f5fe                                    
  233 A:f5fe  61                                 .byt $61              ; 'ADC'    - 00
  234 A:f5ff  21                                 .byt $21              ; 'AND'
  235 A:f600  02                                 .byt $02              ; 'ASL'
  236 A:f601  90                                 .byt $90              ; 'BCC'
  237 A:f602  b0                                 .byt $b0              ; 'BCS'
  238 A:f603  f0                                 .byt $f0              ; 'BEQ'
  239 A:f604  06                                 .byt $06              ; 'BIT'
  240 A:f605  30                                 .byt $30              ; 'BMI'
  241 A:f606  d0                                 .byt $d0              ; 'BNE'    - 08
  242 A:f607  10                                 .byt $10              ; 'BPL'
  243 A:f608  00                                 .byt $00              ; 'BRK'
  244 A:f609  50                                 .byt $50              ; 'BVC'
  245 A:f60a  70                                 .byt $70              ; 'BVS'
  246 A:f60b  18                                 .byt $18              ; 'CLC'
  247 A:f60c  d8                                 .byt $d8              ; 'CLD'
  248 A:f60d  58                                 .byt $58              ; 'CLI'
  249 A:f60e  b8                                 .byt $b8              ; 'CLV'    - 10
  250 A:f60f  61                                 .byt $61              ; 'CMP'
  251 A:f610  70                                 .byt $70              ; 'CPX'
  252 A:f611  60                                 .byt $60              ; 'CPY'
  253 A:f612  62                                 .byt $62              ; 'DEC'
  254 A:f613  ca                                 .byt $ca              ; 'DEX'
  255 A:f614  88                                 .byt $88              ; 'DEY'
  256 A:f615  21                                 .byt $21              ; 'EOR'
  257 A:f616  72                                 .byt $72              ; 'INC'    - 18
  258 A:f617  e8                                 .byt $e8              ; 'INX'
  259 A:f618  c8                                 .byt $c8              ; 'INY'
  260 A:f619  4c                                 .byt $4c              ; 'JMP'
  261 A:f61a  20                                 .byt $20              ; 'JSR'
  262 A:f61b  51                                 .byt $51              ; 'LDA'
  263 A:f61c  52                                 .byt $52              ; 'LDX'
  264 A:f61d  50                                 .byt $50              ; 'LDY'
  265 A:f61e  22                                 .byt $22              ; 'LSR'    - 20
  266 A:f61f  ea                                 .byt $ea              ; 'NOP'
  267 A:f620  01                                 .byt $01              ; 'ORA'
  268 A:f621  48                                 .byt $48              ; 'PHA'
  269 A:f622  08                                 .byt $08              ; 'PHP'
  270 A:f623  68                                 .byt $68              ; 'PLA'
  271 A:f624  28                                 .byt $28              ; 'PLP'
  272 A:f625  12                                 .byt $12              ; 'ROL'
  273 A:f626  32                                 .byt $32              ; 'ROR'    - 28
  274 A:f627  40                                 .byt $40              ; 'RTI'
  275 A:f628  60                                 .byt $60              ; 'RTS'
  276 A:f629  71                                 .byt $71              ; 'SBC'
  277 A:f62a  38                                 .byt $38              ; 'SEC'
  278 A:f62b  f8                                 .byt $f8              ; 'SED'
  279 A:f62c  78                                 .byt $78              ; 'SEI'
  280 A:f62d  41                                 .byt $41              ; 'STA'
  281 A:f62e  42                                 .byt $42              ; 'STX'    - 30
  282 A:f62f  40                                 .byt $40              ; 'STY'
  283 A:f630  aa                                 .byt $aa              ; 'TAX'
  284 A:f631  a8                                 .byt $a8              ; 'TAY'
  285 A:f632  ba                                 .byt $ba              ; 'TSX'
  286 A:f633  8a                                 .byt $8a              ; 'TXA'
  287 A:f634  9a                                 .byt $9a              ; 'TXS'
  288 A:f635  98                                 .byt $98              ; 'TYA'    - 37
  289 A:f636                           code_az   
  289 A:f636                                    

  291 A:f636                                    ;
  292 A:f636                                    ; print code
  293 A:f636                                    ; input:
  294 A:f636                                    ;   a - operation mode
  295 A:f636                                    ;   opb - opcode 'b' mode bits to 'or' in
  296 A:f636                           p_opcode  
  296 A:f636  bd fe f5                           lda code_ac,x
  297 A:f639  05 47                              ora opb
  298 A:f63b  85 44                              sta opcode
  299 A:f63d  4c 3c f7                           jmp finish_asm

  301 A:f640                                    ;
  302 A:f640                                    ; set instruction length
  303 A:f640                                    ; 1, 2 or 3 bytes
  304 A:f640                                    ;
  305 A:f640                           one_byte  
  305 A:f640  a9 01                              lda #$01
  306 A:f642  d0 06                              bne setcmdlen                ;always jump
  307 A:f644                           two_bytes 
  307 A:f644  a9 02                              lda #$02
  308 A:f646  d0 02                              bne setcmdlen                ;always jump
  309 A:f648                           three_bytes 
  309 A:f648  a9 03                              lda #$03
  310 A:f64a                           setcmdlen 
  310 A:f64a  85 47                              sta cmdlen

  312 A:f64c  4c 3c f7                           jmp finish_asm                ; done, ready to emit code

  314 A:f64f                           asm_simple 
  314 A:f64f  bd c6 f5                           lda opmodes,x
  315 A:f652  c9 02                              cmp #$02             ; type 0 and 1 do not need address mode specification, use code_a directl
  316 A:f654  10 06                              bpl @chk_shft
  317 A:f656  20 36 f6                           jsr p_opcode
  318 A:f659  4c 40 f6                           jmp one_byte
  319 A:f65c                           @chk_shft 
  319 A:f65c  c9 04                              cmp #$04             ; deal with accu mode shift operations
  320 A:f65e  d0 17                              bne loc_err
  321 A:f660  a9 08                              lda #$08             ; b = %010 -> aaa010cc
  322 A:f662  20 36 f6                           jsr p_opcode
  323 A:f665  4c 40 f6                           jmp one_byte

  325 A:f668                                    ; jsr getnum
  326 A:f668                                    ; jsr get_rel_a
  327 A:f668                           asm_imm   
  327 A:f668  bd c6 f5                           lda opmodes,x
  328 A:f66b  c9 02                              cmp #$02             ; type 2
  329 A:f66d  f0 0b                              beq asm_imm_ct
  330 A:f66f  c9 05                              cmp #$05             ; type 5
  331 A:f671  f0 07                              beq asm_imm_ct
  332 A:f673  c9 0a                              cmp #$0a             ; type a
  333 A:f675  f0 03                              beq asm_imm_ct
  334 A:f677                           loc_err   
  334 A:f677  4c cb f4                           jmp syntaxerr
  335 A:f67a                           asm_imm_ct 
  335 A:f67a  20 94 f6                           jsr g_adr
  336 A:f67d  a6 42                              ldx a4l
  337 A:f67f  bd fe f5                           lda code_ac,x
  338 A:f682  a2 00                              ldx #$00
  339 A:f684  29 03                              and #$03             ; isolate 'c' bits
  340 A:f686  c9 03                              cmp #$03             ; c=3 has b = %010 for imm, others b=000
  341 A:f688  d0 02                              bne @zerob
  342 A:f68a  a2 08                              ldx #$08             ; when c= %11 immediate is placed at b=%010
  343 A:f68c                           @zerob    
  343 A:f68c  86 47                              stx opb
  344 A:f68e  20 36 f6                           jsr p_opcode                ; fill in complete opcode
  345 A:f691  4c 44 f6                           jmp two_bytes

  347 A:f694                                    ;
  348 A:f694                                    ; get the address
  349 A:f694                                    ; if byte size is demanded, only the lower byte is used.
  350 A:f694                                    ;
  351 A:f694                           g_adr     
  351 A:f694  20 bf f4                           jsr eatblank                ; get rid of spaces and $
  352 A:f697  20 85 ff                           jsr getnum
  353 A:f69a  a5 3e                              lda a2l
  354 A:f69c  85 45                              sta adrl
  355 A:f69e  a5 3f                              lda a2h
  356 A:f6a0  85 46                              sta adrh
  357 A:f6a2  60                                 rts 

  359 A:f6a3                                    ; So after the mnemonic, there can be three options:
  360 A:f6a3                                    ; - #
  361 A:f6a3                                    ; - (
  362 A:f6a3                                    ; - Address
  363 A:f6a3                                    ;
  364 A:f6a3                                    ; After the address there can only be
  365 A:f6a3                                    ; - ,X|Y  for indexed
  366 A:f6a3                                    ; - ) for indirect
  367 A:f6a3                                    ; - ),Y
  368 A:f6a3                                    ; - ,X)
  369 A:f6a3                                    ;
  370 A:f6a3                                    ; Value is $?[\dA-Z]{1,2}
  371 A:f6a3                                    ; Address is [$?][\dA-Z]{1,4}
  372 A:f6a3                           eval_arg  
  372 A:f6a3  a6 42                              ldx a4l                ; load x with opcode index
  373 A:f6a5  a9 00                              lda #$00
  374 A:f6a7  85 47                              sta opb                ; clear opcode b
  375 A:f6a9  b9 00 02                           lda in,y
  376 A:f6ac  85 31                              sta mode
  377 A:f6ae  20 4e f7                           jsr chk_eol                ; end of line
  378 A:f6b1  f0 9c                              beq asm_simple                ; nothing there
  379 A:f6b3  bd c6 f5                           lda opmodes,x
  380 A:f6b6  f0 1d                              beq @err                ; type 0 does not have any arguments.  Eliminate type 0 from further considerations.
  381 A:f6b8  b9 00 02                           lda in,y              ; back to input char
  382 A:f6bb  c5 23                              cmp '#'
  383 A:f6bd  f0 a9                              beq asm_imm
  384 A:f6bf                                    ;
  385 A:f6bf                                    ;
  386 A:f6bf                                    ; now parse rest of address to determine address mode and get argument
  387 A:f6bf                                    ;
  388 A:f6bf                                    ; following options are possible (h = hex digit):
  389 A:f6bf                                    ; h{1.4}       absolute or zero             ; case 0: just 4 hex numbers
  390 A:f6bf                                    ; h{1.4},x|y   absolute or zero indexed     ; case 1: ends with ,x|y
  391 A:f6bf                                    ; (h{1,4})     indirect                     ; case 2: starts with (, ends with )
  392 A:f6bf                                    ; (h{1,2}),y   post-indexed indirect        ; case 3: starts with (, ends with ),y
  393 A:f6bf                                    ; (h{1,2},x)   pre-indexed indirect;       ; case 4: starts with (, ends with ,x)
  394 A:f6bf  c5 28                              cmp '('
  395 A:f6c1  f0 20                              beq @indirect
  396 A:f6c3                                    ;
  397 A:f6c3                                    ; cases 0 and 1
  398 A:f6c3                                    ;
  399 A:f6c3  20 94 f6                           jsr g_adr
  400 A:f6c6  20 4e f7                           jsr chk_eol
  401 A:f6c9  d0 03                              bne @cont
  402 A:f6cb  4c 77 f7                           jmp asm_direct                ; no more input -> case 0
  403 A:f6ce                           @cont     
  403 A:f6ce  20 bf f4                           jsr eatblank
  404 A:f6d1  c5 2c                              cmp ','              ; only , x|y possible now
  405 A:f6d3  f0 03                              beq @reg_indexed                ; -> check reg next
  406 A:f6d5                           @err      
  406 A:f6d5  4c cb f4                           jmp syntaxerr                ; syntax error for weverything else
  407 A:f6d8                           @reg_indexed 
  407 A:f6d8  20 b9 f4                           jsr nextch
  408 A:f6db  20 55 f7                           jsr chk_xy                ; check if valid reg
  409 A:f6de  d0 f5                              bne @err                ; no, syntax error
  410 A:f6e0  4c 8e f7                           jmp asm_indexed                ; yes, handle hhhh,reg (case 1)
  411 A:f6e3                                    ;
  412 A:f6e3                                    ; cases 2-4
  413 A:f6e3                           @indirect 
  413 A:f6e3  20 94 f6                           jsr g_adr                ; address comes after the brace in any case left..
  414 A:f6e6  c5 2c                              cmp ','
  415 A:f6e8  f0 06                              beq @preindexed                ; ',' can only be (hh,x)  -> case 4
  416 A:f6ea  c5 29                              cmp ')'              ;
  417 A:f6ec  f0 1f                              beq @ind_or_pi                ; ) can be indirect or indirect post-indexed (hhhh) or (hh),y
  418 A:f6ee  d0 e5                              bne @err                ; else err; we have to close the brace at least.
  419 A:f6f0                                    ;
  420 A:f6f0                                    ; case 4
  421 A:f6f0                                    ;
  422 A:f6f0                           @preindexed 
  422 A:f6f0  20 b9 f4                           jsr nextch
  423 A:f6f3  c9 58                              cmp #'X'
  424 A:f6f5  d0 de                              bne @err
  425 A:f6f7  20 b9 f4                           jsr nextch
  426 A:f6fa  c9 29                              cmp #')'
  427 A:f6fc  d0 d7                              bne @err
  428 A:f6fe  20 4e f7                           jsr chk_eol
  429 A:f701  d0 d2                              bne @err
  430 A:f703  bd c6 f5                           lda opmodes,x
  431 A:f706                           @chk23    
  431 A:f706  c9 40                              cmp #$40             ; only works for tpes 2 % 3
  432 A:f708  30 cb                              bmi @err
  433 A:f70a  4c 3c f7                           jmp finish_asm                ; b = 0, no need to change opcode
  434 A:f70d                                    ;
  435 A:f70d                                    ; cases 2-3
  436 A:f70d                                    ;
  437 A:f70d                           @ind_or_pi 
  437 A:f70d  20 b9 f4                           jsr nextch
  438 A:f710  c5 2c                              cmp ','
  439 A:f712  f0 07                              beq @indir_reg                ; (hh), -> case 3 reg test
  440 A:f714  20 4e f7                           jsr chk_eol
  441 A:f717  f0 15                              beq asm_indirect                ; ->  case 2
  442 A:f719  d0 ba                              bne @err                ; something unexpected in the line
  443 A:f71b                           @indir_reg 
  443 A:f71b  20 b9 f4                           jsr nextch
  444 A:f71e  c5 59                              cmp 'Y'
  445 A:f720  d0 b3                              bne @err
  446 A:f722                                    ;
  447 A:f722                                    ; case 3
  448 A:f722                                    ;
  449 A:f722  20 b9 f4                           jsr nextch
  450 A:f725  20 4e f7                           jsr chk_eol
  451 A:f728  d0 ab                              bne @err
  452 A:f72a  a9 10                              lda #$10             ; default: abs. Or in b = %100 into aaa100cc
  453 A:f72c  d0 d8                              bne @chk23                ; only do it if type 2 or 3

  455 A:f72e                                    ; asm_indirect: this only happens with jmp
  456 A:f72e                                    ; x must be $1B
  457 A:f72e                           asm_indirect 
  457 A:f72e  e0 1b                              cpx #$1b
  458 A:f730  f0 03                              beq @check
  459 A:f732  4c cb f4                           jmp syntaxerr
  460 A:f735                           @check    
  460 A:f735  a9 20                              lda #$20             ;  Or in  %001.000.00 into 010.011.00
  461 A:f737  05 47                              ora opb
  462 A:f739  4c 3c f7                           jmp finish_asm
  463 A:f73c                                    ;
  464 A:f73c                                    ; wrap up the assembly:
  465 A:f73c                                    ; emit code bytes to target position,
  466 A:f73c                                    ; then borrow the system monitors list command
  467 A:f73c                                    ; to print out the redisassenbled line.
  468 A:f73c                                    ;
  469 A:f73c                           finish_asm 
  469 A:f73c  a4 47                              ldy cmdlen
  470 A:f73e                           @loop     
  470 A:f73e  88                                 dey                    ; start y = cmdlen -1
  471 A:f73f  b9 44 00                           lda opcode,y
  472 A:f742  91 3e                              sta (a2l),y
  473 A:f744                           @short    
  473 A:f744  10 f8                              bpl @loop
  474 A:f746  a9 01                              lda #$01             ; disassemble just the one line
  475 A:f748  20 ef fd                           jsr list2
  476 A:f74b  4c fb f4                           jmp asmz
  477 A:f74e                                    ;
  478 A:f74e                                    ; check for end of line - eihter ENTER (set to 0x0a) or 0
  479 A:f74e                                    ; Z set if reached eol
  480 A:f74e                           chk_eol   
  480 A:f74e  c9 00                              cmp #$00
  481 A:f750  f0 02                              beq @fin
  482 A:f752  c9 0a                              cmp #k_entr
  483 A:f754                           @fin      
  483 A:f754  60                                 rts 

  485 A:f755                           chk_xy    
  485 A:f755  c9 58                              cmp #'X'
  486 A:f757  f0 02                              beq @fin
  487 A:f759  c9 59                              cmp #'Y'
  488 A:f75b                           @fin      
  488 A:f75b  60                                 rts 
  489 A:f75c                                    ;
  490 A:f75c                                    ; get relative address from pc
  491 A:f75c                                    ; and literal address in a1
  492 A:f75c                                    ; pc now points at rel address byte.
  493 A:f75c                                    ; address only convers -128 - +127,
  494 A:f75c                                    ; if the distance is larger it is an error
  495 A:f75c                                    ;
  496 A:f75c                           get_rel_a 
  496 A:f75c  38                                 sec                    ; set carry for following substraction
  497 A:f75d  a5 3a                              lda pcl                ;
  498 A:f75f  69 01                              adc #$01             ; add 2 to be relative to pc+2
  499 A:f761  e5 3c                              sbc a1l
  500 A:f763  85 45                              sta adrl                ; store in low adr
  501 A:f765  a5 3b                              lda pch
  502 A:f767  e5 3d                              sbc a1h
  503 A:f769  30 05                              bmi @chklow
  504 A:f76b  a5 45                              lda adrl
  505 A:f76d  30 05                              bmi @chkerr                ; pos > $7f
  506 A:f76f  60                       @chkok    rts 
  507 A:f770  a5 45                    @chklow   lda adrl
  508 A:f772  30 fb                              bmi @chkok                ; neg < $80
  509 A:f774  4c cb f4                 @chkerr   jmp syntaxerr             ; done, rel addr in adrl
  510 A:f777                                    ;
  511 A:f777                                    ; asm_direct: absolute or zero addr
  512 A:f777                                    ; if adrh == 0 and operation allows zero mode,
  513 A:f777                                    ; use that one. else go for absolute address (16bit)
  514 A:f777                                    ; if op does not have that either, throw syntax error
  515 A:f777                           asm_direct 
  515 A:f777  a6 42                              ldx a4l
  516 A:f779  bd c6 f5                           lda opmodes,x
  517 A:f77c  c9 01                              cmp #$01             ; relative branch; special treatment -> compute rel. addr. -> type 2 finished
  518 A:f77e  f0 dc                              beq get_rel_a
  519 A:f780  20 f4 f7                           jsr chk_zero_abs                ; from here on, just examine types 3-b. use zero page where possible.
  520 A:f783  a9 0c                              lda #$0c             ; default: abs. Or in b = %011 into aaa011cc
  521 A:f785  90 02                              bcc @abs_b
  522 A:f787  a9 04                              lda #$04             ; or in b = %001 into aaa001cc
  523 A:f789                           @abs_b    
  523 A:f789  05 47                              ora opb
  524 A:f78b  4c 3c f7                           jmp finish_asm

  526 A:f78e                                    ;
  527 A:f78e                                    ; asm_indexed: select one of the indexed option.
  528 A:f78e                                    ; First examine if it is x or y,
  529 A:f78e                                    ; the abs or zero
  530 A:f78e                                    ; input: a - current in char
  531 A:f78e                           asm_indexed 
  531 A:f78e  c9 59                              cmp #'Y'
  532 A:f790  f0 33                              beq @idx_y
  533 A:f792  a6 42                              ldx a4l
  534 A:f794  bd c6 f5                           lda opmodes,x
  535 A:f797  c9 05                              cmp #$05             ; types 2-4, 0 and 1 ignored
  536 A:f799  30 07                              bmi @has_idx_x
  537 A:f79b  c9 0a                              cmp #$0a
  538 A:f79d  f0 03                              beq @has_idx_x
  539 A:f79f                           @err      
  539 A:f79f  4c cb f4                           jmp syntaxerr
  540 A:f7a2                           @has_idx_x 
  540 A:f7a2  a5 46                              lda adrh                ; zero or absolute?
  541 A:f7a4  d0 0f                              bne @abs_x                ; weed out stx/sty
  542 A:f7a6                                    ;
  543 A:f7a6                                    ; zpg,X
  544 A:f7a6                                    ;
  545 A:f7a6  e0 1e                              cpx #$1e             ; ldx hh,x no
  546 A:f7a8  f0 f5                              beq @err
  547 A:f7aa  e0 30                              cpx #$30             ; stx hh,x no
  548 A:f7ac  f0 f1                              beq @err
  549 A:f7ae  a9 14                              lda #$14             ; default: abs. Or in b = %101 into aaa101cc
  550 A:f7b0                           @wrapup   
  550 A:f7b0  05 47                              ora opb
  551 A:f7b2  4c 3c f7                           jmp finish_asm
  552 A:f7b5                                    ;
  553 A:f7b5                                    ; abs,X
  554 A:f7b5                           @abs_x    
  554 A:f7b5  e0 1e                              cpx #$1e             ; ldx hhhh,x no
  555 A:f7b7  f0 e6                              beq @err
  556 A:f7b9  e0 30                              cpx #$30             ; stx hhhh,x no
  557 A:f7bb  f0 e2                              beq @err
  558 A:f7bd  e0 31                              cpx #$31             ; sty hhhh,x no
  559 A:f7bf  f0 de                              beq @err
  560 A:f7c1  a9 34                              lda #$34             ; default: abs. Or in b = %111 into aaa111cc
  561 A:f7c3  d0 eb                              bne @wrapup
  562 A:f7c5                           @idx_y    
  562 A:f7c5  e0 1f                              cpx #$1f             ; ldy hhh,y no
  563 A:f7c7  f0 d6                              beq @err
  564 A:f7c9  e0 31                              cpx #$31             ; sty hhh,y no
  565 A:f7cb  f0 d2                              beq @err
  566 A:f7cd  a5 46                              lda adrh
  567 A:f7cf  d0 0b                              bne @abs_y
  568 A:f7d1  bd c6 f5                           lda opmodes,x
  569 A:f7d4  c9 0a                              cmp #$0a
  570 A:f7d6  30 c7                              bmi @err
  571 A:f7d8  a9 14                              lda #$14             ; default: abs. Or in b = %101 into aaa101cc
  572 A:f7da  d0 d4                              bne @wrapup
  573 A:f7dc                           @abs_y    
  573 A:f7dc  bd c6 f5                           lda opmodes,x
  574 A:f7df  c9 04                              cmp #$04
  575 A:f7e1  30 06                              bmi @abs_y_low
  576 A:f7e3  c9 0a                              cmp #$0a
  577 A:f7e5  f0 06                              beq @abs_y_ldx
  578 A:f7e7  d0 b6                              bne @err
  579 A:f7e9                           @abs_y_low 
  579 A:f7e9  a9 18                              lda #$18             ; default: abs. Or in b = %110 into aaa110cc
  580 A:f7eb  d0 c3                              bne @wrapup
  581 A:f7ed                           @abs_y_ldx 
  581 A:f7ed  a9 1c                              lda #$1c             ; default: abs. Or in b = %111 into aaa111cc
  582 A:f7ef  d0 bf                              bne @wrapup

  584 A:f7f1                           bar_ldx   
  584 A:f7f1                                    

  586 A:f7f1                                    ;
  587 A:f7f1                                    ; (hh),reg
  588 A:f7f1                                    ;
  589 A:f7f1                           indir_reg 
  589 A:f7f1  4c 3c f7                           jmp finish_asm
  590 A:f7f4                                    ;
  591 A:f7f4                                    ; check if mnemonic allows zero page address mode
  592 A:f7f4                                    ; input:
  593 A:f7f4                                    ;   x - opcode index
  594 A:f7f4                                    ;   a - opmode for index
  595 A:f7f4                                    ; return c=1 if mode available
  596 A:f7f4                           chk_zero_abs 
  596 A:f7f4  c9 08                              cmp #$08
  597 A:f7f6  f0 10                              beq @ret0
  598 A:f7f8  c9 09                              cmp #$09
  599 A:f7fa  f0 0c                              beq @ret0
  600 A:f7fc  a5 46                              lda adrh
  601 A:f7fe  f0 0a                              beq @ret1
  602 A:f800                           @ldxy     
  602 A:f800  e0 1e                              cpx #$1e             ; ldx and ldy with direct address only work with zero page. throw error if adr out of zero
  603 A:f802  f0 08                              beq @err
  604 A:f804  e0 1f                              cpx #$1f
  605 A:f806  f0 04                              beq @err
  606 A:f808                           @ret0     
  606 A:f808  18                                 clc 
  607 A:f809  60                                 rts 
  608 A:f80a                           @ret1     
  608 A:f80a  38                                 sec 
  609 A:f80b  60                                 rts 
  610 A:f80c                           @err      
  610 A:f80c  4c cb f4                           jmp syntaxerr

rom.s


   65 A:f80f                                    ;
   66 A:f80f                                    ; print zero terminated string
   67 A:f80f                                    ; max 255 chars.
   68 A:f80f                                    ; input:
   69 A:f80f                                    ;   string address in a5l/h
   70 A:f80f                           print     
   70 A:f80f  a0 00                              ldy #$00
   71 A:f811                           @loop     
   71 A:f811  b1 44                              lda (a5l),y
   72 A:f813  f0 06                              beq @fin
   73 A:f815  20 7f fd                           jsr cout
   74 A:f818  c8                                 iny 
   75 A:f819  d0 f6                              bne @loop
   76 A:f81b                           @fin      
   76 A:f81b  60                                 rts 
   77 A:f81c                                    ;
   78 A:f81c                                    ; Emulator exit
   79 A:f81c                                    ; terminate by setting PC to $FFFF, which should not happen in normal operation.
   80 A:f81c                                    ;
   81 A:f81c                           exit      
   81 A:f81c  4c ff ff                           jmp $ffff
   82 A:f81f                                    ;
   83 A:f81f                                    ; getline vector.
   84 A:f81f                                    ;
   85 A:f81f                           getlnv    
   85 A:f81f  6c 28 00                           jmp (rdline)
   86 A:f822                           stdin     
   86 A:f822  ad 18 c0                           lda termin
   87 A:f825  60                                 rts 
   88 A:f826                                    ;
   89 A:f826                                    ; readline from stdio
   90 A:f826                                    ; this will block until line is read
   91 A:f826                                    ; this way it uses standard readline
   92 A:f826                                    ; funcionality hostside.
   93 A:f826                                    ;
   94 A:f826                           stdrdln   
   94 A:f826  98                                 tya 
   95 A:f827  48                                 pha 
   96 A:f828  a5 33                              lda prompt                ; set prompt
   97 A:f82a  8d 1a c0                           sta termp
   98 A:f82d  a0 ff                              ldy #$ff
   99 A:f82f                           loop      
   99 A:f82f  c8                                 iny 
  100 A:f830  ad 19 c0                           lda terml
  101 A:f833  99 00 02                           sta in,y
  102 A:f836  d0 f7                              bne loop
  103 A:f838  a9 0a                              lda #k_entr
  104 A:f83a  99 00 02                           sta in,y
  105 A:f83d  68                                 pla 
  106 A:f83e  a8                                 tay 
  107 A:f83f  60                                 rts 
  108 A:f840                           stdout    
  108 A:f840  8d 12 c0                           sta termout
  109 A:f843  60                                 rts 
  110 A:f844                           nxtcol    
  110 A:f844  a5 30                              lda color                ; increment color by 3
  111 A:f846  18                                 clc 
  112 A:f847  69 03                              adc #$03
  113 A:f849                           setcol    
  113 A:f849  29 0f                              and #$0f             ; sets color = 17*A mod 16
  114 A:f84b  85 30                              sta color
  115 A:f84d  0a                                 asl 
  116 A:f84e  0a                                 asl 
  117 A:f84f  0a                                 asl 
  118 A:f850  0a                                 asl                    ; << 4 = *16
  119 A:f851  05 30                              ora color                ; + 1
  120 A:f853  85 30                              sta color
  121 A:f855  60                                 rts 
  122 A:f856                           selnibl   
  122 A:f856  90 04                              bcc rtmaskz                ; if even, use low nibble else use high nibble (was scrn2)
  123 A:f858  4a                                 lsr 
  124 A:f859  4a                                 lsr 
  125 A:f85a  4a                                 lsr                    ; shift high nibble into low nibble
  126 A:f85b  4a                                 lsr 
  127 A:f85c                           rtmaskz   
  127 A:f85c  29 0f                              and #$0f             ; mask lower 4 bits
  128 A:f85e  60                                 rts 
  129 A:f85f                           insds1    
  129 A:f85f  a6 3a                              ldx pcl                ; print pcl,h
  130 A:f861  a4 3b                              ldy pch
  131 A:f863  20 28 fd                           jsr pryx2
  132 A:f866  20 25 f9                           jsr prblnk                ; followed by a blank
  133 A:f869  a1 3a                              lda (pcl,x)
  134 A:f86b                           insds2    
  134 A:f86b  a8                                 tay 
  135 A:f86c  4a                                 lsr                    ; even / odd test
  136 A:f86d  90 09                              bcc ieven
  137 A:f86f  6a                                 ror                    ; bit 1 test
  138 A:f870  b0 10                              bcs err                ; xxxxxx11 invalid opcode
  139 A:f872  c9 a2                              cmp #$a2
  140 A:f874  f0 0c                              beq err                ; opcode 89 invalid
  141 A:f876  29 87                              and #$87             ; mask bits
  142 A:f878                           ieven     
  142 A:f878  4a                                 lsr                    ; lsb into carry for l/r test
  143 A:f879  aa                                 tax 
  144 A:f87a  bd 3f f9                           lda fmt1,x              ; get format index byte
  145 A:f87d  20 56 f8                           jsr selnibl                ; r/l h-byte on carry
  146 A:f880  d0 04                              bne getfmt
  147 A:f882                           err       
  147 A:f882  a0 80                              ldy #$80             ; substitute $80 for invalid ops
  148 A:f884  a9 00                              lda #$00             ; set print format index to 0
  149 A:f886                           getfmt    
  149 A:f886  aa                                 tax 
  150 A:f887  bd 83 f9                           lda fmt2,x              ; index into print format table
  151 A:f88a  85 2e                              sta format                ; save for addr field formatting
  152 A:f88c  29 03                              and #$03             ; mask for 2-bit length
  153 A:f88e                                    ; (P=1 byte, 1=2 byte, 2=3 byte)
  154 A:f88e  85 2f                              sta length
  155 A:f890  98                                 tya                    ; opcode
  156 A:f891  29 8f                              and #$8f             ; mask for 1xxx1010 test
  157 A:f893  aa                                 tax                    ;  save it
  158 A:f894  98                                 tya                    ; opcode to a again
  159 A:f895  a0 03                              ldy #$03
  160 A:f897  e0 8a                              cpx #$8a
  161 A:f899  f0 0b                              beq mnndx3
  162 A:f89b                           mnndx1    
  162 A:f89b  4a                                 lsr 
  163 A:f89c  90 08                              bcc mnndx3                ; form index into mnemonic tble
  164 A:f89e  4a                                 lsr 
  165 A:f89f                           mnndx2    
  165 A:f89f  4a                                 lsr                    ; 1)  1xxx1010 => 00101xxx
  166 A:f8a0  09 20                              ora #$20             ; 2)  xxxyyy01 => 00111xxx
  167 A:f8a2  88                                 dey                    ; 3)  xxxyyy10 => 00110xxx
  168 A:f8a3  d0 fa                              bne mnndx2                ; 4)  xxxyy100 => 00100xxx
  169 A:f8a5  c8                                 iny                    ; 5)  xxxxx000 => 000xxxxx
  170 A:f8a6                           mnndx3    
  170 A:f8a6  88                                 dey 
  171 A:f8a7  d0 f2                              bne mnndx1
  172 A:f8a9  60                                 rts 
  173 A:f8aa  ff ff ff                           .byt $ff,$ff,$ff  ; ???
  174 A:f8ad                           instdsp   
  174 A:f8ad  20 5f f8                           jsr insds1                ; gen fmt, len bytes
  175 A:f8b0  48                                 pha                    ; save mnemonic table index
  176 A:f8b1                           prntop    
  176 A:f8b1  b1 3a                              lda (pcl),y
  177 A:f8b3  20 6c fd                           jsr prbyte
  178 A:f8b6  a2 01                              ldx #$01             ; print 2 blanks
  179 A:f8b8                           prntbl    
  179 A:f8b8  20 27 f9                           jsr prbl2
  180 A:f8bb  c4 2f                              cpy length                ; print inst (1-3 bytes)
  181 A:f8bd  c8                                 iny                    ; in a 12 char field
  182 A:f8be  90 f1                              bcc prntop
  183 A:f8c0  a2 03                              ldx #$03             ; char count for mnemonic print
  184 A:f8c2  c0 04                              cpy #$04
  185 A:f8c4  90 f2                              bcc prntbl
  186 A:f8c6  68                                 pla                    ; recover mnemonic index
  187 A:f8c7  a8                                 tay 
  188 A:f8c8  b9 9d f9                           lda mneml,y
  189 A:f8cb  85 2c                              sta lmnem                ; fetch 3 char mnemonic
  190 A:f8cd  b9 dd f9                           lda mnemr,y              ;   (packed in 2 bytes, only chars A-Z
  191 A:f8d0  85 2d                              sta rmnem
  192 A:f8d2                           prmn1     
  192 A:f8d2  a9 00                              lda #$00
  193 A:f8d4  a0 05                              ldy #$05
  194 A:f8d6                           prnm2     
  194 A:f8d6  06 2d                              asl rmnem                ; shift 5 bits of
  195 A:f8d8  26 2c                              rol lmnem                ;   character into Accu
  196 A:f8da  2a                                 rol                    ;      (clears carry)
  197 A:f8db  88                                 dey 
  198 A:f8dc  d0 f8                              bne prnm2
  199 A:f8de  69 3f                              adc #'?'             ; add "?" offset
  200 A:f8e0  20 7f fd                           jsr cout                ; output a char of mnem
  201 A:f8e3  ca                                 dex 
  202 A:f8e4  d0 ec                              bne prmn1
  203 A:f8e6  20 25 f9                           jsr prblnk                ; output 3 blanks
  204 A:f8e9  a4 2f                              ldy length
  205 A:f8eb  a2 06                              ldx #$06             ; count for 6 format bits
  206 A:f8ed                           pradr1    
  206 A:f8ed  e0 03                              cpx #$03
  207 A:f8ef  f0 1c                              beq pradr5                ; if x=3 then addr
  208 A:f8f1                           pradr2    
  208 A:f8f1  06 2e                              asl format
  209 A:f8f3  90 0e                              bcc pradr3
  210 A:f8f5  bd 90 f9                           lda char1-1,x
  211 A:f8f8  20 7f fd                           jsr cout
  212 A:f8fb  bd 96 f9                           lda char2-1,x
  213 A:f8fe  f0 03                              beq pradr3
  214 A:f900  20 7f fd                           jsr cout
  215 A:f903                           pradr3    
  215 A:f903  ca                                 dex 
  216 A:f904  d0 e7                              bne pradr1
  217 A:f906  60                                 rts 
  218 A:f907                           pradr4    
  218 A:f907  88                                 dey 
  219 A:f908  30 e7                              bmi pradr2
  220 A:f90a  20 6c fd                           jsr prbyte
  221 A:f90d                           pradr5    
  221 A:f90d  a5 2e                              lda format
  222 A:f90f  c9 e8                              cmp #$e8             ; handle relative address mode
  223 A:f911  b1 3a                              lda (pcl),y            ;  special (print target, not offset)
  224 A:f913  90 f2                              bcc pradr4
  225 A:f915                           reladr    
  225 A:f915  20 33 f9                           jsr pcadj3
  226 A:f918  aa                                 tax                    ; pcl,pch+offset+1 to a,y
  227 A:f919  e8                                 inx 
  228 A:f91a  d0 01                              bne prntyx                ; +1 to y,x
  229 A:f91c  c8                                 iny 
  230 A:f91d                                    ;
  231 A:f91d                                    ; print y and x  as 4 digit hex number
  232 A:f91d                                    ;
  233 A:f91d                           prntyx    
  233 A:f91d  98                                 tya 
  234 A:f91e                           prntax    
  234 A:f91e  20 6c fd                           jsr prbyte                ; output target adr
  235 A:f921                           prntx     
  235 A:f921  8a                                 txa                    ;    of branch and return
  236 A:f922  4c 6c fd                           jmp prbyte
  237 A:f925                           prblnk    
  237 A:f925  a2 03                              ldx #$03             ; blank count
  238 A:f927                           prbl2     
  238 A:f927  a9 20                              lda #' '             ; load a space
  239 A:f929                           prbl3     
  239 A:f929  20 7f fd                           jsr cout                ; output a blank
  240 A:f92c  ca                                 dex 
  241 A:f92d  d0 f8                              bne prbl2
  242 A:f92f  60                                 rts 
  243 A:f930                           pcadj     
  243 A:f930  38                                 sec                    ; 0=1-byte, 1=2-byte,
  244 A:f931                           pcadj2    
  244 A:f931  a5 2f                              lda length                ;   2=3-byte
  245 A:f933                           pcadj3    
  245 A:f933  a4 3b                              ldy pch
  246 A:f935  aa                                 tax                    ; test displacement sign
  247 A:f936  10 01                              bpl pcadj4                ;   (for rel branch)
  248 A:f938  88                                 dey 
  249 A:f939                           pcadj4    
  249 A:f939  65 3a                              adc pcl
  250 A:f93b  90 01                              bcc rts2                ; pcl+LENGTH(or Displc.)+1 to A
  251 A:f93d  c8                                 iny                    ;   carry inot y (pch)
  252 A:f93e                           rts2      
  252 A:f93e  60                                 rts 
  253 A:f93f                                    ;
  254 A:f93f                                    ; fmt1 bytes:   XXXXXXY0 instructions
  255 A:f93f                                    ;       if Y=0: then left half byte
  256 A:f93f                                    ;       if Y=1  then right half byte
  257 A:f93f                                    ;                    (X=index)
  258 A:f93f                           fmt1      
  258 A:f93f  04 20 54 30 0d                     .byt $04,$20,$54,$30,$0d
  259 A:f944  80 04 90 03 22                     .byt $80,$04,$90,$03,$22
  260 A:f949  54 33 0d 80 04                     .byt $54,$33,$0d,$80,$04
  261 A:f94e  90 04 20 54 33                     .byt $90,$04,$20,$54,$33
  262 A:f953  0d 80 04 90 04                     .byt $0d,$80,$04,$90,$04
  263 A:f958  20 54 3b 0d 80                     .byt $20,$54,$3b,$0d,$80
  264 A:f95d  04 90 00 22 44                     .byt $04,$90,$00,$22,$44
  265 A:f962  33 0d c8 44 00                     .byt $33,$0d,$c8,$44,$00
  266 A:f967  11 22 44 33 0d                     .byt $11,$22,$44,$33,$0d
  267 A:f96c  c8 44 a9 01 22                     .byt $c8,$44,$a9,$01,$22
  268 A:f971  44 33 0d 80 04                     .byt $44,$33,$0d,$80,$04
  269 A:f976  90 01 22 44 33                     .byt $90,$01,$22,$44,$33
  270 A:f97b  0d 80 04 90                        .byt $0d,$80,$04,$90
  271 A:f97f  26 31 87 9a                        .byt $26,$31,$87,$9a; ZZXXXXY01 instructions
  272 A:f983                           fmt2      
  272 A:f983  00                                 .byt $00              ; ERR
  273 A:f984  21                                 .byt $21              ; IMM
  274 A:f985  81                                 .byt $81              ; Z-PAGE
  275 A:f986  82                                 .byt $82              ; ABS
  276 A:f987  00                                 .byt $00              ; IMPLIED
  277 A:f988  00                                 .byt $00              ; ACCUMULATOR
  278 A:f989  59                                 .byt $59              ; (ZPAG,X)
  279 A:f98a  4d                                 .byt $4d              ; (ZPAG),Y
  280 A:f98b  91                                 .byt $91              ; ZPAG,X
  281 A:f98c  92                                 .byt $92              ; ABS,X
  282 A:f98d  86                                 .byt $86              ; ABS,Y
  283 A:f98e  4a                                 .byt $4a              ; (ABS)
  284 A:f98f  85                                 .byt $85              ; ZPAG,Y
  285 A:f990  9d                                 .byt $9d              ; RELATIVE
  286 A:f991                           char1     
  286 A:f991  2c 29 2c 23 28 24                  .byt ',',')',',','#','(','$'
  287 A:f997                           char2     
  287 A:f997  59 00 58 24 24 00                  .byt 'Y',0,"X$$",0
  288 A:f99d                                    ;
  289 A:f99d                                    ; mneml is of form:
  290 A:f99d                                    ; (A) XXXXX000
  291 A:f99d                                    ; (B) XXXYY100
  292 A:f99d                                    ; (C) 1XXX1010
  293 A:f99d                                    ; (D) XXXYYY10
  294 A:f99d                                    ; (E) XXXYYY01
  295 A:f99d                                    ;     (X=index)
  296 A:f99d                           mneml     
  296 A:f99d  1c 8a 1c 23 5d 8b                  .byt $1c,$8a,$1c,$23,$5d,$8b
  297 A:f9a3  1b a1 9d 8a 1d 23                  .byt $1b,$a1,$9d,$8a,$1d,$23
  298 A:f9a9  9d 8b 1d a1 00 29                  .byt $9d,$8b,$1d,$a1,$00,$29
  299 A:f9af  19 ae 69 a8 19 23                  .byt $19,$ae,$69,$a8,$19,$23
  300 A:f9b5  24 53 1b 23 24 53                  .byt $24,$53,$1b,$23,$24,$53
  301 A:f9bb  19 a1                              .byt $19,$a1        ; (A) Format Above
  302 A:f9bd  00 1a 5b 5b a5 69                  .byt $00,$1a,$5b,$5b,$a5,$69
  303 A:f9c3  24 24                              .byt $24,$24        ; (B) Format
  304 A:f9c5  ae ae a8 ad 29 00                  .byt $ae,$ae,$a8,$ad,$29,$00
  305 A:f9cb  7c 00                              .byt $7c,$00        ; (C) Format
  306 A:f9cd  15 9c 6d 9c a5 69                  .byt $15,$9c,$6d,$9c,$a5,$69
  307 A:f9d3  29 53                              .byt $29,$53        ; (D) Format
  308 A:f9d5  84 13 34 11 a5 69                  .byt $84,$13,$34,$11,$a5,$69
  309 A:f9db  23 a0                              .byt $23,$a0        ; (E) Format
  310 A:f9dd                           mnemr     
  310 A:f9dd  d8 62 5a 48 26 62                  .byt $d8,$62,$5a,$48,$26,$62
  311 A:f9e3  94 88 54 44 c8 54                  .byt $94,$88,$54,$44,$c8,$54
  312 A:f9e9  68 44 e8 94 00 b4                  .byt $68,$44,$e8,$94,$00,$b4
  313 A:f9ef  08 84 74 b4 28 6e                  .byt $08,$84,$74,$b4,$28,$6e
  314 A:f9f5  74 f4 cc 4a 72 f2                  .byt $74,$f4,$cc,$4a,$72,$f2
  315 A:f9fb  a4 8a                              .byt $a4,$8a        ; (A) Format
  316 A:f9fd  00 aa a2 a2 74 74                  .byt $00,$aa,$a2,$a2,$74,$74
  317 A:fa03  74 72                              .byt $74,$72        ; (B) Format
  318 A:fa05  44 68 b2 32 b2 00                  .byt $44,$68,$b2,$32,$b2,$00
  319 A:fa0b  22 00                              .byt $22,$00        ; (C) Format
  320 A:fa0d  1a 1a 26 26 72 72                  .byt $1a,$1a,$26,$26,$72,$72
  321 A:fa13  88 c8                              .byt $88,$c8        ; (D) Format
  322 A:fa15  c4 ca 26 48 44 44                  .byt $c4,$ca,$26,$48,$44,$44
  323 A:fa1b  a2 c8                              .byt $a2,$c8        ; (E) Format
  324 A:fa1d  ff ff ff                           .byt $ff,$ff,$ff
  325 A:fa20                                    ;
  326 A:fa20                                    ; monitor stepping
  327 A:fa20                                    ; this is nice... it emulates itself to execute a program stepwise
  328 A:fa20                                    ;
  329 A:fa20                           step      
  329 A:fa20  20 ad f8                           jsr instdsp                ; disassemble one instruction
  330 A:fa23  68                                 pla                    ;   at (pcl,h)
  331 A:fa24  85 2c                              sta rtnl                ; adjust to user
  332 A:fa26  68                                 pla                    ;   stack, save
  333 A:fa27  85 2d                              sta rtnh                ;   return address
  334 A:fa29  a2 08                              ldx #$08
  335 A:fa2b                           xqinit    
  335 A:fa2b  bd ed fa                           lda initbl-1,x        ; init xeq (execute) area
  336 A:fa2e  95 3c                              sta xqt,x
  337 A:fa30  ca                                 dex 
  338 A:fa31  d0 f8                              bne xqinit
  339 A:fa33  a1 3a                              lda (pcl,x)            ; user opcode byte
  340 A:fa35  f0 42                              beq xbrk                ; special if BRK
  341 A:fa37  a4 2f                              ldy length                ; LEN from disassembly
  342 A:fa39  c9 20                              cmp #$20
  343 A:fa3b  f0 59                              beq xjsr                ; handle jsr, rts, jmp,
  344 A:fa3d  c9 60                              cmp #$60             ;   jmp (), rti special
  345 A:fa3f  f0 45                              beq xrts
  346 A:fa41  c9 4c                              cmp #$4c
  347 A:fa43  f0 5c                              beq xjmp
  348 A:fa45  c9 6c                              cmp #$6c
  349 A:fa47  f0 59                              beq xjmpat
  350 A:fa49  c9 40                              cmp #$40
  351 A:fa4b  f0 35                              beq xrti
  352 A:fa4d  29 1f                              and #$1f             ; TODO comment
  353 A:fa4f  49 14                              eor #$14
  354 A:fa51  c9 04                              cmp #$04             ; copy user instruction to xeq area
  355 A:fa53  f0 02                              beq xq2                ;   with trailing nops
  356 A:fa55                           xq1       
  356 A:fa55  b1 3a                              lda (pcl),y            ; change rel branch
  357 A:fa57                           xq2       
  357 A:fa57  99 3c 00                           sta xqtnz,y              ;   disp to 4 for
  358 A:fa5a  88                                 dey                    ;   jmp to branch or
  359 A:fa5b  10 f8                              bpl xq1                ;   nbranch from xeq
  360 A:fa5d  20 1a ff                           jsr restore                ; restore user reg contents
  361 A:fa60  4c 3c 00                           jmp xqtnz                ; xeq (execute) user op from RAM
  362 A:fa63                           irqvec    
  362 A:fa63  85 45                              sta acc                ;    (return to nbranch)
  363 A:fa65  68                                 pla                    ; fetch p status register into a
  364 A:fa66  48                                 pha                    ; * * IRQ handler
  365 A:fa67  0a                                 asl 
  366 A:fa68  0a                                 asl 
  367 A:fa69  0a                                 asl                    ; put B flag in high bit
  368 A:fa6a  30 03                              bmi break                ; if set, handle BRK
  369 A:fa6c  6c fe 03                           jmp (irqloc)              ; user routine vector in RAM
  370 A:fa6f                           break     
  370 A:fa6f  28                                 plp 
  371 A:fa70  20 27 ff                           jsr sav1                ; save regs on break
  372 A:fa73  68                                 pla                    ; including pc
  373 A:fa74  85 3a                              sta pcl
  374 A:fa76  68                                 pla 
  375 A:fa77  85 3b                              sta pch
  376 A:fa79                           xbrk      
  376 A:fa79  20 5f f8                           jsr insds1                ; print user pc
  377 A:fa7c  20 b7 fa                           jsr rgdsp1                ;   and registers
  378 A:fa7f  4c 43 ff                           jmp mon                ; go to monitor
  379 A:fa82                           xrti      
  379 A:fa82  18                                 clc 
  380 A:fa83  68                                 pla                    ; simulate rti by expecting
  381 A:fa84  85 48                              sta status                ;    status from stack, then rts
  382 A:fa86                           xrts      
  382 A:fa86  68                                 pla                    ; rts simulation
  383 A:fa87  85 3a                              sta pcl                ;   extract pc from stack
  384 A:fa89  68                                 pla                    ; and update pc by 1 (LEN=0)
  385 A:fa8a                           pcinc2    
  385 A:fa8a  85 3b                              sta pch
  386 A:fa8c                           pcinc3    
  386 A:fa8c  a5 2f                              lda length                ; update pc by LEN
  387 A:fa8e  20 33 f9                           jsr pcadj3
  388 A:fa91  84 3b                              sty pch
  389 A:fa93  18                                 clc                    ; short unconditional jump
  390 A:fa94  90 14                              bcc newpcl                ;  CLC BCC #rel
  391 A:fa96                           xjsr      
  391 A:fa96  18                                 clc 
  392 A:fa97  20 31 f9                           jsr pcadj2                ; update pc and push
  393 A:fa9a  aa                                 tax                    ;   onto stack for
  394 A:fa9b  98                                 tya                    ;   JSR simulate
  395 A:fa9c  48                                 pha 
  396 A:fa9d  8a                                 txa 
  397 A:fa9e  48                                 pha 
  398 A:fa9f  a0 02                              ldy #$02
  399 A:faa1                           xjmp      
  399 A:faa1  18                                 clc 
  400 A:faa2                           xjmpat    
  400 A:faa2  b1 3a                              lda (pcl),Y
  401 A:faa4  aa                                 tax                    ; load pc for jump,
  402 A:faa5  88                                 dey                    ;   (JMP) simulate
  403 A:faa6  b1 3a                              lda (pcl),y
  404 A:faa8  86 3b                              stx pch
  405 A:faaa                           newpcl    
  405 A:faaa  85 3a                              sta pcl
  406 A:faac  b0 f3                              bcs xjmp
  407 A:faae                           rtnjmp    
  407 A:faae  a5 2d                              lda rtnh
  408 A:fab0  48                                 pha 
  409 A:fab1  a5 2c                              lda rtnl
  410 A:fab3  48                                 pha 
  411 A:fab4                           regdsp    
  411 A:fab4  20 20 fd                           jsr crout                ; display user reg
  412 A:fab7                           rgdsp1    
  412 A:fab7  a9 45                              lda #<acc              ;  contents with
  413 A:fab9  85 40                              sta a3l                ;  labels
  414 A:fabb  a9 00                              lda #>acc
  415 A:fabd  85 41                              sta a3h
  416 A:fabf  a2 fb                              ldx #$fb
  417 A:fac1                           rdsp1     
  417 A:fac1  a9 20                              lda #' '
  418 A:fac3  20 7f fd                           jsr cout                ; output space
  419 A:fac6  bd fb f9                           lda rtbl-$fb,x        ; register name (x has FB so base address = rtbl - FB)
  420 A:fac9  20 7f fd                           jsr cout
  421 A:facc  a9 3d                              lda #'='             ; '='
  422 A:face  20 7f fd                           jsr cout
  423 A:fad1  b5 4a                              lda acc+5,x
  424 A:fad3  20 6c fd                           jsr prbyte
  425 A:fad6  e8                                 inx 
  426 A:fad7  30 e8                              bmi rdsp1
  427 A:fad9  60                                 rts 
  428 A:fada                           branch    
  428 A:fada  18                                 clc                    ; branch taken,
  429 A:fadb  a0 01                              ldy #$01             ;  add LEN+2 to pc
  430 A:fadd  b1 3a                              lda (pcl),y
  431 A:fadf  20 33 f9                           jsr pcadj3
  432 A:fae2  85 3a                              sta pcl
  433 A:fae4  98                                 tya 
  434 A:fae5  38                                 sec 
  435 A:fae6  b0 a2                              bcs pcinc2
  436 A:fae8                           nbranch   
  436 A:fae8  20 25 ff                           jsr save                ; normal return after
  437 A:faeb  38                                 sec                    ;   xeq user of
  438 A:faec  b0 9e                              bcs pcinc3                ; go update pc
  439 A:faee                           initbl    
  439 A:faee  ea                                 nop 
  440 A:faef  ea                                 nop                    ; dummy fill for
  441 A:faf0  4c e8 fa                           jmp nbranch                ;   xeq area
  442 A:faf3  4c da fa                           jmp branch
  443 A:faf6                           rtbl      
  443 A:faf6  41                                 .byt 'A'
  444 A:faf7  58                                 .byt 'X'
  445 A:faf8  59                                 .byt 'Y'
  446 A:faf9  50                                 .byt 'P'
  447 A:fafa  53                                 .byt 'S'
  448 A:fafb                           pread     
  448 A:fafb  ad 70 c0                           lda ptrig                ; paddle read; trigger paddles
  449 A:fafe  a0 00                              ldy #$00             ; init count
  450 A:fb00  ea                                 nop                    ; compensate timing for first count
  451 A:fb01  ea                                 nop                    ; 2 x 2 cycles
  452 A:fb02                           pread2    
  452 A:fb02  bd 61 c0                           lda paddl0,x              ; count y-reg
  453 A:fb05  10 04                              bpl rts2d                ;    every 12 usec
  454 A:fb07  c8                                 iny 
  455 A:fb08  d0 f8                              bne pread2                ;    exit at 255 max
  456 A:fb0a  88                                 dey 
  457 A:fb0b                           rts2d     
  457 A:fb0b  60                                 rts 
  458 A:fb0c                           init      
  458 A:fb0c  a9 00                              lda #$00             ; clr status for debug
  459 A:fb0e  85 48                              sta status                ;   software
  460 A:fb10                           settxt    
  460 A:fb10  a9 00                              lda #$00             ;   full screen window
  461 A:fb12                           setwnd    
  461 A:fb12  85 22                              sta wndtop                ; set for 40 col window
  462 A:fb14  a9 00                              lda #$00             ;    top in accu,
  463 A:fb16  85 20                              sta wndlft                ;    bottom at line 24
  464 A:fb18  ad 17 c0                           lda termww                ; get terminal window width
  465 A:fb1b  85 21                              sta wndwdth
  466 A:fb1d  ad 16 c0                           lda termwh                ; get terminal window height
  467 A:fb20  85 23                              sta wndbtm
  468 A:fb22  38                                 sec 
  469 A:fb23  e9 01                              sbc #$01             ; last possible row in window
  470 A:fb25                           tabv      
  470 A:fb25  85 25                              sta cv                ; vtabs to row in accu
  471 A:fb27  60                                 rts 
  472 A:fb28                           mulpm     
  472 A:fb28  20 6c fb                           jsr md1                ; abs value of ac, aux
  473 A:fb2b                           mul       
  473 A:fb2b  a0 10                              ldy #$10             ; index for 16 bits
  474 A:fb2d                           mul2      
  474 A:fb2d  a5 50                              lda acl                ; acx * aux + xtnd
  475 A:fb2f  4a                                 lsr                    ;  to ac, xtnd
  476 A:fb30  90 0c                              bcc mul4                ; if no carry,
  477 A:fb32  18                                 clc                    ;   no partial product
  478 A:fb33  a2 fe                              ldx #$fe
  479 A:fb35                           mul3      
  479 A:fb35  b5 54                              lda xtndl+2,x        ; add multiplicant (aux)
  480 A:fb37  75 56                              adc auxl+2,x        ;   to partial product
  481 A:fb39  95 54                              sta xtndl+2,x        ;     (xtnd)
  482 A:fb3b  e8                                 inx 
  483 A:fb3c  d0 f7                              bne mul3
  484 A:fb3e                           mul4      
  484 A:fb3e  a2 03                              ldx #$03
  485 A:fb40                           mul5      
  485 A:fb40  76 50                              ror acl,x              ; orig DFB #$76, #$50 ?!? maybe a bug in their assembler software
  486 A:fb42  ca                                 dex 
  487 A:fb43  10 fb                              bpl mul5
  488 A:fb45  88                                 dey 
  489 A:fb46  d0 e5                              bne mul2
  490 A:fb48  60                                 rts 
  491 A:fb49                           divpm     
  491 A:fb49  20 6c fb                           jsr md1                ; abs value of ac, aux
  492 A:fb4c                           div       
  492 A:fb4c  a0 10                              ldy #$10             ; index for 16 bits
  493 A:fb4e                           div2      
  493 A:fb4e  06 51                              asl ach
  494 A:fb50  26 51                              rol ach
  495 A:fb52  26 52                              rol xtndl                ; xtnd/aux
  496 A:fb54  26 53                              rol xtndh                ;   to ac.
  497 A:fb56  38                                 sec 
  498 A:fb57  a5 52                              lda xtndl
  499 A:fb59  e5 54                              sbc auxl                ; mod to xtnd
  500 A:fb5b  aa                                 tax 
  501 A:fb5c  a5 53                              lda xtndh
  502 A:fb5e  e5 55                              sbc auxh
  503 A:fb60  90 06                              bcc div3
  504 A:fb62  86 52                              stx xtndl
  505 A:fb64  85 53                              sta xtndh
  506 A:fb66  e6 50                              inc acl
  507 A:fb68                           div3      
  507 A:fb68  88                                 dey 
  508 A:fb69  d0 e3                              bne div2
  509 A:fb6b  60                                 rts 
  510 A:fb6c                           md1       
  510 A:fb6c  a0 00                              ldy #$00             ; abs value of ac, aux
  511 A:fb6e  84 2f                              sty sign                ;   with result sign
  512 A:fb70  a2 54                              ldx #auxl               ;   in lsb of sign
  513 A:fb72  20 77 fb                           jsr md2
  514 A:fb75  a2 50                              ldx #acl
  515 A:fb77                           md2       
  515 A:fb77  b5 01                              lda loc1,x              ; x specifies ac or aux
  516 A:fb79  10 0d                              bpl mdrts
  517 A:fb7b  38                                 sec 
  518 A:fb7c                           md3       
  518 A:fb7c  98                                 tya 
  519 A:fb7d  f5 00                              sbc loc0,x              ; compl specified reg
  520 A:fb7f  95 00                              sta loc0,x              ;   if negative
  521 A:fb81  98                                 tya 
  522 A:fb82  f5 01                              sbc loc1,x
  523 A:fb84  95 01                              sta loc1,x
  524 A:fb86  e6 2f                              inc sign
  525 A:fb88                           mdrts     
  525 A:fb88  60                                 rts 

  527 A:fb89                           bell1     
  527 A:fb89  a9 07                              lda #k_ctl_g               ; output bell and return
  528 A:fb8b  8d 12 c0                           sta termout                ; pit to term directly here...
  529 A:fb8e  60                                 rts 
  530 A:fb8f  ea ff 10 00 00 24 2c ...           .dsb $10,$ea
  531 A:fb9f                           rts2b     
  531 A:fb9f  60                                 rts 
  532 A:fba0                                    ;
  533 A:fba0                                    ; Store terminal char output and advance screen cursor
  534 A:fba0                                    ;
  535 A:fba0                           stoadv    
  535 A:fba0  a4 25                              ldy cv                ; cursor y index to y register
  536 A:fba2  8c 10 c0                           sty termcy                ; set terminal cursor y
  537 A:fba5  a4 24                              ldy ch                ; cursor h index to y register
  538 A:fba7  8c 11 c0                           sty termcx                ; set terminal cursor x
  539 A:fbaa  a4 32                              ldy invflg                ;
  540 A:fbac  8c 13 c0                           sty termesc                ; invflg has the command byte for the char attribute normal or reverse
  541 A:fbaf  8d 12 c0                           sta termout                ; output char
  542 A:fbb2                                    ;
  543 A:fbb2                                    ; advance cursor
  544 A:fbb2                                    ;
  545 A:fbb2                                    ; add next line routine if cursor proceeds to right margin
  546 A:fbb2                                    ;
  547 A:fbb2                           advance   
  547 A:fbb2  e6 24                              inc ch                ; increment cursor h index
  548 A:fbb4  a5 24                              lda ch                ;   (move right)
  549 A:fbb6  c5 21                              cmp wndwdth                ; beyond window width?
  550 A:fbb8  b0 4e                              bcs cr                ;   yes, cr to next line
  551 A:fbba                           rts3      
  551 A:fbba  60                                 rts                    ; no, return
  552 A:fbbb                                    ;
  553 A:fbbb                                    ; Video out
  554 A:fbbb                                    ;
  555 A:fbbb                                    ; Write character to terminal I/O
  556 A:fbbb                                    ;
  557 A:fbbb                           vidout    
  557 A:fbbb  c9 20                              cmp #' '             ; control char?
  558 A:fbbd  b0 e1                              bcs stoadv                ;   no, output it
  559 A:fbbf  c9 0a                              cmp #k_entr               ; CR?  0x1D | 0x80
  560 A:fbc1  f0 45                              beq cr                ;   yes
  561 A:fbc3  c9 0a                              cmp #k_lf               ; LF?
  562 A:fbc5  f0 45                              beq lf                ;   yes
  563 A:fbc7  c9 08                              cmp #k_bs               ; backspace (CTRL-H)?
  564 A:fbc9  d0 be                              bne bell1                ;   no, check for bell
  565 A:fbcb                           bs        
  565 A:fbcb  c6 24                              dec ch                ; decrement cursor h index
  566 A:fbcd  10 eb                              bpl rts3                ; if pos, ok, else move up
  567 A:fbcf  a5 21                              lda wndwdth                ; set ch to wndwdth-1
  568 A:fbd1  85 24                              sta ch
  569 A:fbd3  c6 24                              dec ch                ; rightmost screen position
  570 A:fbd5                           up        
  570 A:fbd5  a5 22                              lda wndtop                ; cursor v index
  571 A:fbd7  c5 25                              cmp cv
  572 A:fbd9  b0 02                              bcs rts4                ; if top line then return
  573 A:fbdb  c6 25                              dec cv                ; decr cursor v
  574 A:fbdd                           rts4      
  574 A:fbdd  60                                 rts 
  575 A:fbde                           esc1      
  575 A:fbde  49 1b                              eor #k_esc               ; esc?
  576 A:fbe0  f0 1c                              beq home                ;   if so, do home and clear
  577 A:fbe2  e9 02                              sbc #$02             ; esc-a or -b check
  578 A:fbe4  30 cc                              bmi advance                ;   a, advance
  579 A:fbe6  f0 e3                              beq bs                ;   b, backspace
  580 A:fbe8  e9 02                              sbc #$02             ; esc-c or -d check
  581 A:fbea  30 20                              bmi lf                ;   c, down
  582 A:fbec  f0 e7                              beq up                ;   d, go up
  583 A:fbee  e9 02                              sbc #$02             ; esc-e or -f check
  584 A:fbf0  90 2a                              bcc clreol                ;   e, clear to end of line
  585 A:fbf2  d0 e9                              bne rts4                ;   not f, return
  586 A:fbf4                           clreop    
  586 A:fbf4  a4 24                              ldy ch                ; cursor h to y
  587 A:fbf6  a5 25                              lda cv                ; cursor v to a
  588 A:fbf8                           cleop1    
  588 A:fbf8  48                                 pha                    ; save current line on stk
  589 A:fbf9  a9 00                              lda #t_cls               ; clear screen command
  590 A:fbfb  8d 13 c0                           sta termesc                ; send to terminal
  591 A:fbfe                           home      
  591 A:fbfe  a5 22                              lda wndtop                ; init cursor v
  592 A:fc00  85 25                              sta cv                ;   and h-indices
  593 A:fc02  a0 00                              ldy #$00
  594 A:fc04  84 24                              sty ch                ; then clear to end of page
  595 A:fc06  f0 f0                              beq cleop1
  596 A:fc08                           cr        
  596 A:fc08  a9 00                              lda #$00             ; cursor to left of index
  597 A:fc0a  85 24                              sta ch
  598 A:fc0c                           lf        
  598 A:fc0c  e6 25                              inc cv                ; incr cursor v (down 1 line)
  599 A:fc0e  a5 25                              lda cv
  600 A:fc10  c5 23                              cmp wndbtm                ; off screen?
  601 A:fc12  90 c9                              bcc rts4                ;   no, done
  602 A:fc14  c6 25                              dec cv                ; decr cursor v (back to bottom)
  603 A:fc16                           scroll    
  603 A:fc16  a9 03                              lda #t_scr               ; scroll command
  604 A:fc18  8d 13 c0                           sta termesc                ; let the terminal scroll.
  605 A:fc1b  60                                 rts 
  606 A:fc1c                           clreol    
  606 A:fc1c  a9 01                              lda #t_cll               ; clear to eol command
  607 A:fc1e  8d 13 c0                           sta termesc                ; execute
  608 A:fc21  60                                 rts 
  609 A:fc22                           wait      
  609 A:fc22  38                                 sec 
  610 A:fc23                           wait2     
  610 A:fc23  48                                 pha 
  611 A:fc24                           wait3     
  611 A:fc24  e9 01                              sbc #$01
  612 A:fc26  d0 fc                              bne wait3                ; 1.02.4 uSec
  613 A:fc28  68                                 pla                    ; (13+2712*A+512*A*A) on 1 MHz
  614 A:fc29  e9 01                              sbc #$01
  615 A:fc2b  d0 f6                              bne wait2                ; busy, busy, busy waiting
  616 A:fc2d  60                                 rts 
  617 A:fc2e                           nxta4     
  617 A:fc2e  e6 42                              inc a4l                ; incr 2-byte a4
  618 A:fc30  d0 02                              bne nxta1                ;  and a1
  619 A:fc32  e6 43                              inc a4h
  620 A:fc34                           nxta1     
  620 A:fc34  a5 3c                              lda a1l                ; incr 2-byte a1
  621 A:fc36  c5 3e                              cmp a2l
  622 A:fc38  a5 3d                              lda a1h                ;   and compare to a2
  623 A:fc3a  e5 3f                              sbc a2h
  624 A:fc3c  e6 3c                              inc a1l                ;  carry set if >=
  625 A:fc3e  d0 02                              bne rts4b
  626 A:fc40  e6 3d                              inc a1h
  627 A:fc42                           rts4b     
  627 A:fc42  60                                 rts 
  628 A:fc43                           headr     
  628 A:fc43  a0 4b                              ldy #$4b             ; write or skip A * 256 'long 1'
  629 A:fc45  20 55 fc                           jsr zerdly                ;   half cycles
  630 A:fc48  d0 f9                              bne headr                ;     (650 usec each)
  631 A:fc4a  69 fe                              adc #$fe
  632 A:fc4c  b0 f5                              bcs headr                ; then a 'short 0'
  633 A:fc4e  a0 21                              ldy #$21             ;    (400 usec)
  634 A:fc50                           wrbit     
  634 A:fc50  20 55 fc                           jsr zerdly                ; write two half cycles
  635 A:fc53  c8                                 iny                    ;   of 250 usec ('0')
  636 A:fc54  c8                                 iny                    ;   or 500 usec ('0')
  637 A:fc55                           zerdly    
  637 A:fc55  88                                 dey                    ; it means 'zero delay'
  638 A:fc56  d0 fd                              bne zerdly
  639 A:fc58  90 05                              bcc wrtape                ; y is count for
  640 A:fc5a  a0 32                              ldy #$32             ;   timing loop
  641 A:fc5c                           onedly    
  641 A:fc5c  88                                 dey                    ; 'ones delay'
  642 A:fc5d  d0 fd                              bne onedly
  643 A:fc5f                           wrtape    
  643 A:fc5f  48                                 pha 
  644 A:fc60  a4 26                              ldy tpdir
  645 A:fc62  b9 20 c0                           lda tapeout,y              ; y=0 - tape out, y=1 - tape in
  646 A:fc65  68                                 pla 
  647 A:fc66  a0 2c                              ldy #$2c
  648 A:fc68  ca                                 dex 
  649 A:fc69  60                                 rts 
  650 A:fc6a                           rdbyte    
  650 A:fc6a  a2 08                              ldx #$08             ; 8 bits to read
  651 A:fc6c                           rdbyt2    
  651 A:fc6c  48                                 pha                    ; read two transitions
  652 A:fc6d  20 78 fc                           jsr rd2bit                ;   (find edge)
  653 A:fc70  68                                 pla 
  654 A:fc71  2a                                 rol                    ; next bit
  655 A:fc72  a0 3a                              ldy #$3a             ; count for samples
  656 A:fc74  ca                                 dex 
  657 A:fc75  d0 f5                              bne rdbyt2
  658 A:fc77  60                                 rts 
  659 A:fc78                           rd2bit    
  659 A:fc78  20 7b fc                           jsr rdbit
  660 A:fc7b                           rdbit     
  660 A:fc7b  88                                 dey                    ; decr y until
  661 A:fc7c  ad 21 c0                           lda tapein                ;   tape transition
  662 A:fc7f  45 2f                              eor lastin
  663 A:fc81  10 f8                              bpl rdbit
  664 A:fc83  45 2f                              eor lastin
  665 A:fc85  85 2f                              sta lastin
  666 A:fc87  c0 80                              cpy #$80             ; set carry on y register
  667 A:fc89  60                                 rts 
  668 A:fc8a                           charout   
  668 A:fc8a  a4 25                              ldy cv                ; cursor y index to y register
  669 A:fc8c  8c 10 c0                           sty termcy                ; set terminal cursor y
  670 A:fc8f  a4 24                              ldy ch                ; cursor h index to y register
  671 A:fc91  8c 11 c0                           sty termcx                ; set terminal cursor x
  672 A:fc94  8d 12 c0                           sta termout                ; output char
  673 A:fc97  60                                 rts 
  674 A:fc98                           rdkey     
  674 A:fc98  a0 06                              ldy #t_blnk               ; set screen to flash
  675 A:fc9a  8c 13 c0                           sty termesc
  676 A:fc9d  ad 12 c0                           lda termout                ; get char at cursor pos.
  677 A:fca0  20 8a fc                           jsr charout
  678 A:fca3  a0 04                              ldy #t_norm               ; set screen back to normal after
  679 A:fca5  8c 13 c0                           sty termesc
  680 A:fca8  6c 38 00                           jmp (kswl)              ; go to user key-in
  681 A:fcab                           keyin     
  681 A:fcab  e6 4e                              inc rndl
  682 A:fcad  d0 02                              bne keyin2                ; inc random number
  683 A:fcaf  e6 4f                              inc rndh
  684 A:fcb1                           keyin2    
  684 A:fcb1  ad 00 c0                           lda kbd
  685 A:fcb4  f0 f5                              beq keyin                ; busy waiting loop until key != 0...
  686 A:fcb6  20 8a fc                           jsr charout                ; replace flashing screen
  687 A:fcb9  2c 01 c0                           bit kbdstrb                ; clear key strobe
  688 A:fcbc  60                                 rts 
  689 A:fcbd                           esc       
  689 A:fcbd  20 98 fc                           jsr rdkey                ; get keycode
  690 A:fcc0  20 de fb                           jsr esc1                ;  handle esc function
  691 A:fcc3                           rdchar    
  691 A:fcc3  20 98 fc                           jsr rdkey                ; read key
  692 A:fcc6  c9 1b                              cmp #k_esc               ; ESC?
  693 A:fcc8  f0 f3                              beq esc                ;   yes, don't return
  694 A:fcca  60                                 rts 
  695 A:fccb                           notcr     
  695 A:fccb  a5 32                              lda invflg
  696 A:fccd  48                                 pha 
  697 A:fcce  a9 04                              lda #t_norm
  698 A:fcd0  85 32                              sta invflg                ; echo user line
  699 A:fcd2  bd 00 02                           lda in,x              ;   non inverse
  700 A:fcd5  20 7f fd                           jsr cout
  701 A:fcd8  68                                 pla 
  702 A:fcd9  85 32                              sta invflg
  703 A:fcdb  bd 00 02                           lda in,x
  704 A:fcde  c9 08                              cmp #k_bs               ; check for edit keys
  705 A:fce0  f0 20                              beq bckspc                ;  bs, ctrl-x
  706 A:fce2  c9 18                              cmp #k_ctl_x
  707 A:fce4  f0 0a                              beq cancel
  708 A:fce6  e0 f8                              cpx #$f8             ; margin?
  709 A:fce8  90 03                              bcc notcr1
  710 A:fcea  20 15 ff                           jsr bell                ; yes, sound bell
  711 A:fced                           notcr1    
  711 A:fced  e8                                 inx                    ; advance input index
  712 A:fcee  d0 16                              bne nxtchar
  713 A:fcf0                           cancel    
  713 A:fcf0  a9 5c                              lda #'\'             ; backslash after cancelled LTN?
  714 A:fcf2  20 7f fd                           jsr cout
  715 A:fcf5                           getlnz    
  715 A:fcf5  20 20 fd                           jsr crout                ; output cr
  716 A:fcf8                           getln     
  716 A:fcf8  6c 28 00                           jmp (rdline)
  717 A:fcfb                           getlnw    
  717 A:fcfb  a5 33                              lda prompt
  718 A:fcfd  20 7f fd                           jsr cout                ; output prompt char
  719 A:fd00  a2 01                              ldx #$01             ; init input index
  720 A:fd02                           bckspc    
  720 A:fd02  8a                                 txa                    ;   will backspace to u
  721 A:fd03  f0 f0                              beq getlnz
  722 A:fd05  ca                                 dex 
  723 A:fd06                           nxtchar   
  723 A:fd06  20 c3 fc                           jsr rdchar
  724 A:fd09  c9 15                              cmp #k_ctl_u               ; use screen char
  725 A:fd0b  d0 03                              bne captst                ;  for ctrl-u
  726 A:fd0d  ad 12 c0                           lda termout                ; get char under cursor
  727 A:fd10                           captst    
  727 A:fd10  c9 60                              cmp #$60
  728 A:fd12  90 02                              bcc addinp                ; convert to caps; for now..
  729 A:fd14  29 df                              and #$df
  730 A:fd16                           addinp    
  730 A:fd16  9d 00 02                           sta in,x              ; add to input buffer
  731 A:fd19  c9 0a                              cmp #k_entr
  732 A:fd1b  d0 ae                              bne notcr
  733 A:fd1d  20 1c fc                           jsr clreol                ; clear to eol if cr

  735 A:fd20                           crout     
  735 A:fd20  a9 0a                              lda #k_entr
  736 A:fd22  d0 5b                              bne cout                ; branches always ?!?
  737 A:fd24                           pra1      
  737 A:fd24  a4 3d                              ldy a1h                ; print CR,A1 in hex
  738 A:fd26  a6 3c                              ldx a1l
  739 A:fd28                                    ;
  740 A:fd28                                    ; print address header at start of line
  741 A:fd28                                    ; yyxx-
  742 A:fd28                                    ;
  743 A:fd28                           pryx2     
  743 A:fd28  20 20 fd                           jsr crout
  744 A:fd2b  20 1d f9                           jsr prntyx
  745 A:fd2e  a0 00                              ldy #$00
  746 A:fd30  a9 2d                              lda #'-'             ; print '-'
  747 A:fd32  4c 7f fd                           jmp cout
  748 A:fd35                                    ;
  749 A:fd35                                    ; Examine 8 bytes at address
  750 A:fd35                                    ; Triggered by command xxxx.yyyy
  751 A:fd35                                    ;
  752 A:fd35                           xam8      
  752 A:fd35  a5 3c                              lda a1l
  753 A:fd37  09 07                              ora #$07             ; set to finish at
  754 A:fd39  85 3e                              sta a2l                ;   mod 8=7
  755 A:fd3b  a5 3d                              lda a1h
  756 A:fd3d  85 3f                              sta a2h
  757 A:fd3f                           mod8chk   
  757 A:fd3f  a5 3c                              lda a1l
  758 A:fd41  29 07                              and #$07
  759 A:fd43  d0 03                              bne dataout
  760 A:fd45                                    ;
  761 A:fd45                                    ; Examine byte at address
  762 A:fd45                                    ;
  763 A:fd45                           xam       
  763 A:fd45  20 24 fd                           jsr pra1
  764 A:fd48                           dataout   
  764 A:fd48  a9 20                              lda #' '
  765 A:fd4a  20 7f fd                           jsr cout                ; output blank
  766 A:fd4d  b1 3c                              lda (a1l),y
  767 A:fd4f  20 6c fd                           jsr prbyte                ; print byte in hex
  768 A:fd52  20 34 fc                           jsr nxta1
  769 A:fd55  90 e8                              bcc mod8chk                ; check if time to,
  770 A:fd57  60                                 rts                    ;  print address
  771 A:fd58                           xampm     
  771 A:fd58  4a                                 lsr                    ; determine if mon
  772 A:fd59  90 ea                              bcc xam                ;  mode is xam
  773 A:fd5b  4a                                 lsr                    ;  add or sub
  774 A:fd5c  4a                                 lsr 
  775 A:fd5d  a5 3e                              lda a2l
  776 A:fd5f  90 02                              bcc add
  777 A:fd61  49 ff                              eor #$ff             ; sub - form 2's complement
  778 A:fd63                           add       
  778 A:fd63  65 3c                              adc a1l
  779 A:fd65  48                                 pha 
  780 A:fd66  a9 3d                              lda #'='             ; print '=' the result
  781 A:fd68  20 7f fd                           jsr cout
  782 A:fd6b  68                                 pla 
  783 A:fd6c                                    ;
  784 A:fd6c                                    ; print byte as 2 hex digits
  785 A:fd6c                                    ;
  786 A:fd6c                           prbyte    
  786 A:fd6c  48                                 pha                    ; save a for second half
  787 A:fd6d  4a                                 lsr                    ; shift 4 high digits into low nibble, destroys accu
  788 A:fd6e  4a                                 lsr 
  789 A:fd6f  4a                                 lsr 
  790 A:fd70  4a                                 lsr 
  791 A:fd71  20 77 fd                           jsr prhexz                ; first hex per subroutine,
  792 A:fd74  68                                 pla                    ;   second hex direct, reuse rts for prbyte
  793 A:fd75                           prhex     
  793 A:fd75  29 0f                              and #$0f             ; print hex digit in accu
  794 A:fd77                                    ;
  795 A:fd77                                    ; print lower accu nibble as hex number
  796 A:fd77                                    ;
  797 A:fd77                           prhexz    
  797 A:fd77  09 30                              ora #$30             ;   lsb's
  798 A:fd79  c9 3a                              cmp #$3a
  799 A:fd7b  90 02                              bcc cout
  800 A:fd7d  69 06                              adc #$06             ; afterwards, flow into cout
  801 A:fd7f                                    ;
  802 A:fd7f                                    ; Character out to screen
  803 A:fd7f                                    ; go through cswl zero page vector
  804 A:fd7f                                    ;
  805 A:fd7f                           cout      
  805 A:fd7f  6c 36 00                           jmp (cswl)              ; vector to user output routine
  806 A:fd82                                    ;
  807 A:fd82                                    ; Standard cswl character out routine
  808 A:fd82                                    ;
  809 A:fd82                           cout1     
  809 A:fd82  84 35                              sty ysav1                ; save the y register
  810 A:fd84  48                                 pha                    ; save A
  811 A:fd85  20 bb fb                           jsr vidout                ; output a as ascii
  812 A:fd88  68                                 pla                    ; restore A
  813 A:fd89  a4 35                              ldy ysav1                ; restore y and return
  814 A:fd8b  60                                 rts 
  815 A:fd8c                                    ;
  816 A:fd8c                                    ; on blank / return, execute preceding command
  817 A:fd8c                                    ;
  818 A:fd8c                           bli       
  818 A:fd8c  c6 34                              dec ysav
  819 A:fd8e  f0 a5                              beq xam8
  820 A:fd90                           blank     
  820 A:fd90  ca                                 dex                    ; blank to mon
  821 A:fd91  d0 16                              bne setmdz                ; after blank
  822 A:fd93  c9 3a                              cmp #':'             ; data store mode?
  823 A:fd95  d0 c1                              bne xampm                ;   no, xam, add or sub
  824 A:fd97                           stor      
  824 A:fd97  85 31                              sta mode                ; keep in store mode
  825 A:fd99  a5 3e                              lda a2l
  826 A:fd9b  91 40                              sta (a3l),y            ; store as low byte as (a3)
  827 A:fd9d  e6 40                              inc a3l
  828 A:fd9f  d0 02                              bne rts5                ; incr a3, return
  829 A:fda1  e6 41                              inc a3h
  830 A:fda3                           rts5      
  830 A:fda3  60                                 rts 
  831 A:fda4                                    ;
  832 A:fda4                                    ; set the command mode
  833 A:fda4                                    ;
  834 A:fda4                           setmode   
  834 A:fda4  a4 34                              ldy ysav                ; save converted colon, '+',
  835 A:fda6  b9 ff 01                           lda in-1,y          ;  '-', '.' as mode.
  836 A:fda9                           setmdz    
  836 A:fda9  85 31                              sta mode
  837 A:fdab  60                                 rts 
  838 A:fdac                                    ;
  839 A:fdac                                    ; '<' command for move / verify
  840 A:fdac                                    ; initialize zero page variables for following V/M command
  841 A:fdac                                    ;
  842 A:fdac                           lt        
  842 A:fdac  a2 01                              ldx #$01
  843 A:fdae                           lt2       
  843 A:fdae  b5 3e                              lda a2l,x              ; copy a2 (2 bytes) to
  844 A:fdb0  95 42                              sta a4l,x              ;   a4 and a5
  845 A:fdb2  95 44                              sta a5l,x
  846 A:fdb4  ca                                 dex 
  847 A:fdb5  10 f7                              bpl lt2
  848 A:fdb7  60                                 rts 
  849 A:fdb8                                    ;
  850 A:fdb8                                    ; copy memory range
  851 A:fdb8                                    ;
  852 A:fdb8                           move      
  852 A:fdb8  b1 3c                              lda (a1l),y            ; move (a1 to a2) to
  853 A:fdba  91 42                              sta (a4l),y            ;   (a4)
  854 A:fdbc  20 2e fc                           jsr nxta4                ; y is set to 0 in zmode. there is no address
  855 A:fdbf  90 f7                              bcc move                ;  mode for zero indirect without y, and move
  856 A:fdc1  60                                 rts                    ;  must work with ranges > 255
  857 A:fdc2                                    ;
  858 A:fdc2                                    ; verify that two memory ranges have same content
  859 A:fdc2                                    ;
  860 A:fdc2                           vfy       
  860 A:fdc2  b1 3c                              lda (a1l),y            ; verify (a1 to a2) with
  861 A:fdc4  d1 42                              cmp (a4l),y            ;   (a4)
  862 A:fdc6  f0 1c                              beq vfyok
  863 A:fdc8  20 24 fd                           jsr pra1
  864 A:fdcb  b1 3c                              lda (a1l),y
  865 A:fdcd  20 6c fd                           jsr prbyte
  866 A:fdd0  a9 20                              lda #' '             ; space
  867 A:fdd2  20 7f fd                           jsr cout
  868 A:fdd5  a9 28                              lda #'('             ; '('
  869 A:fdd7  20 7f fd                           jsr cout
  870 A:fdda  b1 42                              lda (a4l),y
  871 A:fddc  20 6c fd                           jsr prbyte
  872 A:fddf  a9 29                              lda #')'             ; ')'
  873 A:fde1  20 7f fd                           jsr cout
  874 A:fde4                           vfyok     
  874 A:fde4  20 2e fc                           jsr nxta4
  875 A:fde7  90 d9                              bcc vfy
  876 A:fde9  60                                 rts 
  877 A:fdea                                    ;
  878 A:fdea                                    ; list memory range as assembler
  879 A:fdea                                    ;
  880 A:fdea                           list      
  880 A:fdea  20 01 fe                           jsr a1pc                ; move a1 (2 bytes) to
  881 A:fded  a9 14                              lda #$14             ;  pc if specified and
  882 A:fdef                           list2     
  882 A:fdef  48                                 pha                    ;  dissemble 20 instructions
  883 A:fdf0  20 ad f8                           jsr instdsp
  884 A:fdf3  20 30 f9                           jsr pcadj                ; adjust pc each instruction
  885 A:fdf6  85 3a                              sta pcl
  886 A:fdf8  84 3b                              sty pch
  887 A:fdfa  68                                 pla 
  888 A:fdfb  38                                 sec 
  889 A:fdfc  e9 01                              sbc #$01             ; next 20 instr.
  890 A:fdfe  d0 ef                              bne list2
  891 A:fe00  60                                 rts 
  892 A:fe01                           a1pc      
  892 A:fe01  8a                                 txa                    ; if user specified address
  893 A:fe02  f0 07                              beq a1pcrts                ;   copy from a1 to pc
  894 A:fe04                           a1pclp    
  894 A:fe04  b5 3c                              lda a1l,X
  895 A:fe06  95 3a                              sta pcl,x
  896 A:fe08  ca                                 dex 
  897 A:fe09  10 f9                              bpl a1pclp
  898 A:fe0b                           a1pcrts   
  898 A:fe0b  60                                 rts 
  899 A:fe0c                                    ;
  900 A:fe0c                                    ; set inverse character mode
  901 A:fe0c                                    ;
  902 A:fe0c                           setinv    
  902 A:fe0c  a0 05                              ldy #t_inv               ; set for inverse video
  903 A:fe0e  d0 02                              bne setiflg
  904 A:fe10                                    ;
  905 A:fe10                                    ; set norml character mode
  906 A:fe10                                    ;
  907 A:fe10                           setnorm   
  907 A:fe10  a0 04                              ldy #t_norm               ; set for normal video
  908 A:fe12                           setiflg   
  908 A:fe12  84 32                              sty invflg
  909 A:fe14  60                                 rts 
  910 A:fe15                                    ;
  911 A:fe15                                    ; Switch terminal configuration
  912 A:fe15                                    ; Terminal mode in $C01F is 0 when in screen mode,
  913 A:fe15                                    ; and 1 when in stdio mode
  914 A:fe15                                    ;
  915 A:fe15                           termsw    
  915 A:fe15                                    
  916 A:fe15  60                                 rts 
  917 A:fe16                                    ;
  918 A:fe16                                    ; set input port to standard keyboard
  919 A:fe16                                    ;
  920 A:fe16                           setkbd    
  920 A:fe16  a9 00                              lda #$00             ; simulate port #0 input
  921 A:fe18                           inport    
  921 A:fe18  85 3e                              sta a2l                ;   specified (keyin routine)
  922 A:fe1a                           inprt     
  922 A:fe1a                                     .( 
  923 A:fe1a  a2 38                              ldx #kswl
  924 A:fe1c  ad 1f c0                           lda termmd                ; window mode - 0, stdio mode - 1
  925 A:fe1f  d0 09                              bne inprt3                ; stdio
  926 A:fe21  a0 ab                              ldy #<keyin
  927 A:fe23  a9 fc                              lda #>keyin
  928 A:fe25  85 3f                              sta a2h                ; default msb
  929 A:fe27  4c 6a fe                           jmp ioprt
  930 A:fe2a                           inprt3    
  930 A:fe2a  a0 22                              ldy #<stdin              ; load stdout vector
  931 A:fe2c  a9 f8                              lda #>stdin              ; y lsb of cout1 standard vector
  932 A:fe2e  85 3f                              sta a2h                ; default msb
  933 A:fe30  4c 6a fe                           jmp ioprt
  934 A:fe33                                     .) 
  935 A:fe33                                    ;
  936 A:fe33                                    ; set input port to standard keyboard
  937 A:fe33                                    ;
  938 A:fe33                           setrdl    
  938 A:fe33  a9 00                              lda #$00             ; simulate port #0 input
  939 A:fe35                           rdport    
  939 A:fe35  85 3e                              sta a2l                ;   specified (keyin routine)
  940 A:fe37                           rdprt     
  940 A:fe37                                     .( 
  941 A:fe37  a2 28                              ldx #rdline
  942 A:fe39  ad 1f c0                           lda termmd                ; window mode - 0, stdio mode - 1
  943 A:fe3c  d0 09                              bne rdprt3                ; stdio
  944 A:fe3e  a0 fb                              ldy #<getlnw
  945 A:fe40  a9 fc                              lda #>getlnw
  946 A:fe42  85 3f                              sta a2h                ; default msb
  947 A:fe44  4c 6a fe                           jmp ioprt
  948 A:fe47                           rdprt3    
  948 A:fe47  a0 26                              ldy #<stdrdln              ; load stdout vector
  949 A:fe49  a9 f8                              lda #>stdrdln              ; y lsb of cout1 standard vector
  950 A:fe4b  85 3f                              sta a2h                ; default msb
  951 A:fe4d  4c 6a fe                           jmp ioprt
  952 A:fe50                                     .) 
  953 A:fe50                                    ;
  954 A:fe50                                    ; Set output port to standard terminal
  955 A:fe50                                    ;
  956 A:fe50                           setvid    
  956 A:fe50  a9 00                              lda #$00             ; simulate port #0 output
  957 A:fe52                           outport   
  957 A:fe52  85 3e                              sta a2l                ;   specified (cout routine)
  958 A:fe54                           outprt    
  958 A:fe54                                     .( 
  959 A:fe54  a2 36                              ldx #cswl               ; x has zero page location for cout vector
  960 A:fe56  ad 1f c0                           lda termmd                ; window mode - 0, stdio mode - 1
  961 A:fe59  d0 09                              bne outprt3                ; stdio
  962 A:fe5b  a0 82                              ldy #<cout1
  963 A:fe5d  a9 fd                              lda #>cout1
  964 A:fe5f  85 3f                              sta a2h                ; default msb
  965 A:fe61  4c 6a fe                           jmp ioprt
  966 A:fe64                           outprt3   
  966 A:fe64  a0 40                              ldy #<stdout              ; load stdout vector
  967 A:fe66  a9 f8                              lda #>stdout              ; y lsb of cout1 standard vector
  968 A:fe68  85 3f                              sta a2h                ; default msb
  969 A:fe6a                                     .) 
  970 A:fe6a                                    ;
  971 A:fe6a                                    ; set either internal or peripheral port
  972 A:fe6a                                    ; a2l contains a port number 0-7
  973 A:fe6a                                    ; a2l = 0 - use internal port
  974 A:fe6a                                    ; a2l > 0 - It is a peripheral, the msb of the address is
  975 A:fe6a                                    ; 0xCn where n is peripheral #1-7
  976 A:fe6a                                    ;
  977 A:fe6a                           ioprt     
  977 A:fe6a  a5 3e                              lda a2l                ; set ram in/out vectors
  978 A:fe6c  29 0f                              and #$0f
  979 A:fe6e  f0 06                              beq ioprt1
  980 A:fe70  09 c0                              ora #>ioadr              ; high byte
  981 A:fe72  a0 00                              ldy #$00
  982 A:fe74  f0 02                              beq ioprt2
  983 A:fe76                           ioprt1    
  983 A:fe76  a5 3f                              lda a2h
  984 A:fe78                           ioprt2    
  984 A:fe78  94 00                              sty loc0,x
  985 A:fe7a  95 01                              sta loc1,x
  986 A:fe7c  60                                 rts 
  987 A:fe7d                                    ;
  988 A:fe7d                                    ; execute installed language
  989 A:fe7d                                    ;
  990 A:fe7d                           x_lang    
  990 A:fe7d  4c 00 e0                           jmp lang
  991 A:fe80                                    ; soft entry vector for installed language
  992 A:fe80                           bascont   
  992 A:fe80  4c 03 e0                           jmp lang2
  993 A:fe83                           go        
  993 A:fe83  20 01 fe                           jsr a1pc                ; adr to pc if specified
  994 A:fe86  20 1a ff                           jsr restore                ; restore meta registers
  995 A:fe89  6c 3a 00                           jmp (pcl)              ; go to user subroutine
  996 A:fe8c                           regz      
  996 A:fe8c  4c b4 fa                           jmp regdsp                ; jump to register display
  997 A:fe8f                                    ;
  998 A:fe8f                                    ; trace command
  999 A:fe8f                                    ;
 1000 A:fe8f                           trace     
 1000 A:fe8f  c6 34                              dec ysav
 1001 A:fe91                           stepz     
 1001 A:fe91  20 01 fe                           jsr a1pc                ; adr to pc if specified
 1002 A:fe94  4c 20 fa                           jmp step                ; take one step
 1003 A:fe97                                    ;
 1004 A:fe97                                    ; execute user command
 1005 A:fe97                                    ; 
 1006 A:fe97                           usr       
 1006 A:fe97  4c f8 03                           jmp usradr                ; to usr subroutine at usradr
 1007 A:fe9a                                    ;
 1008 A:fe9a                                    ; write memory range to tape OUT
 1009 A:fe9a                                    ;
 1010 A:fe9a                           write     
 1010 A:fe9a  a9 00                              lda #$00             ; set header to WRITE
 1011 A:fe9c  85 26                              sta tpdir
 1012 A:fe9e  a9 40                              lda #$40
 1013 A:fea0  20 43 fc                           jsr headr                ; write 10-sec header
 1014 A:fea3  a0 27                              ldy #$27
 1015 A:fea5                           wr1       
 1015 A:fea5  a2 00                              ldx #$00
 1016 A:fea7  41 3c                              eor (a1l,x)
 1017 A:fea9  48                                 pha 
 1018 A:feaa  a1 3c                              lda (a1l,x)
 1019 A:feac  20 c1 fe                           jsr wrbyte
 1020 A:feaf  20 34 fc                           jsr nxta1
 1021 A:feb2  a0 1d                              ldy #$1d
 1022 A:feb4  68                                 pla 
 1023 A:feb5  90 ee                              bcc wr1
 1024 A:feb7  a0 22                              ldy #$22
 1025 A:feb9  20 c1 fe                           jsr wrbyte
 1026 A:febc  ad 22 c0                           lda tapecls                ; close tape
 1027 A:febf  f0 54                              beq bell                ; sound bell and return
 1028 A:fec1                           wrbyte    
 1028 A:fec1  a2 10                              ldx #$10
 1029 A:fec3                           wrbyt2    
 1029 A:fec3  0a                                 asl 
 1030 A:fec4  20 50 fc                           jsr wrbit
 1031 A:fec7  d0 fa                              bne wrbyt2
 1032 A:fec9  60                                 rts 
 1033 A:feca                                    ;
 1034 A:feca                                    ; execute command line
 1035 A:feca                                    ;
 1036 A:feca                           crmon     
 1036 A:feca  20 8c fd                           jsr bli                ; handle CR as blank
 1037 A:fecd  68                                 pla                    ;  then pop stack
 1038 A:fece  68                                 pla                    ; and return to mon
 1039 A:fecf  d0 76                              bne monz
 1040 A:fed1                                    ;
 1041 A:fed1                                    ; read memory area from tape IN
 1042 A:fed1                                    ;
 1043 A:fed1                                    ; first synchronize timing with the header block,
 1044 A:fed1                                    ; Then read bytes and check checksum
 1045 A:fed1                                    ; 1s and 0s have different lengths, so number and frequency 
 1046 A:fed1                                    ; of machine cycles is important for executing this
 1047 A:fed1                                    ;
 1048 A:fed1                           read      
 1048 A:fed1  a9 01                              lda #$01             ; set header to READ
 1049 A:fed3  85 26                              sta tpdir
 1050 A:fed5  20 78 fc                           jsr rd2bit                ; find tapein edge
 1051 A:fed8  a9 16                              lda #$16
 1052 A:feda  20 43 fc                           jsr headr                ; delay 3.5s
 1053 A:fedd  85 2e                              sta chksum                ; init checksum = $FF
 1054 A:fedf  20 78 fc                           jsr rd2bit                ; find tapein edge
 1055 A:fee2                           rd2       
 1055 A:fee2  a0 24                              ldy #$24             ; look for sync bit
 1056 A:fee4  20 7b fc                           jsr rdbit                ; (short 0)
 1057 A:fee7  b0 f9                              bcs rd2                ; loop until found
 1058 A:fee9  20 7b fc                           jsr rdbit                ; skip second sync h-cycle
 1059 A:feec  a0 3b                              ldy #$3b             ; index for 0/1 test
 1060 A:feee                           rd3       
 1060 A:feee  20 6a fc                           jsr rdbyte                ; read a byte
 1061 A:fef1  81 3c                              sta (a1l,x)            ; store at (a1)
 1062 A:fef3  45 2e                              eor chksum
 1063 A:fef5  85 2e                              sta chksum                ; update running checksum
 1064 A:fef7  20 34 fc                           jsr nxta1                ; incr a1, compare to a2
 1065 A:fefa  a0 35                              ldy #$35             ; compensate 0/1 index
 1066 A:fefc  90 f0                              bcc rd3                ; loop until done
 1067 A:fefe  20 6a fc                           jsr rdbyte                ; read chksum byte
 1068 A:ff01  ac 22 c0                           ldy tapecls                ; close tape
 1069 A:ff04  c5 2e                              cmp chksum
 1070 A:ff06  f0 0d                              beq bell                ; good, sound bell and return
 1071 A:ff08                                    ;
 1072 A:ff08                                    ; print "ERR" and beep
 1073 A:ff08                                    ;
 1074 A:ff08                           prerr     
 1074 A:ff08  a9 c5                              lda #$c5             ; 'E'
 1075 A:ff0a  20 7f fd                           jsr cout                ; print "ERR" then bell
 1076 A:ff0d  a9 d2                              lda #$d2             ; 'R'
 1077 A:ff0f  20 7f fd                           jsr cout
 1078 A:ff12  20 7f fd                           jsr cout
 1079 A:ff15                                    ;
 1080 A:ff15                                    ; ring the terminal bell
 1081 A:ff15                                    ;
 1082 A:ff15                           bell      
 1082 A:ff15  a9 07                              lda #k_ctl_g               ; output bell and return
 1083 A:ff17  4c 7f fd                           jmp cout                ; reuse cout rts directly here...
 1084 A:ff1a                                    ;
 1085 A:ff1a                                    ; restore registers from zero page storage
 1086 A:ff1a                                    ;
 1087 A:ff1a                           restore   
 1087 A:ff1a  a5 48                              lda status                ; restore 6502 register contents
 1088 A:ff1c  48                                 pha                    ;  used by debug software
 1089 A:ff1d  a5 45                              lda acc
 1090 A:ff1f                           restr1    
 1090 A:ff1f  a6 46                              ldx xreg
 1091 A:ff21  a4 47                              ldy yreg
 1092 A:ff23  28                                 plp 
 1093 A:ff24  60                                 rts 
 1094 A:ff25                                    ;
 1095 A:ff25                                    ; save 6502 reg contents to zero page storage
 1096 A:ff25                                    ;
 1097 A:ff25                           save      
 1097 A:ff25  85 45                              sta acc
 1098 A:ff27                           sav1      
 1098 A:ff27  86 46                              stx xreg
 1099 A:ff29  84 47                              sty yreg
 1100 A:ff2b  08                                 php 
 1101 A:ff2c  68                                 pla 
 1102 A:ff2d  85 48                              sta status
 1103 A:ff2f  ba                                 tsx 
 1104 A:ff30  86 49                              stx spnt
 1105 A:ff32  d8                                 cld 
 1106 A:ff33  60                                 rts 
 1107 A:ff34                                    ;
 1108 A:ff34                                    ; 6502 reset vector
 1109 A:ff34                                    ;
 1110 A:ff34                           reset     
 1110 A:ff34  20 10 fe                           jsr setnorm
 1111 A:ff37  20 0c fb                           jsr init
 1112 A:ff3a  20 50 fe                           jsr setvid
 1113 A:ff3d  20 16 fe                           jsr setkbd
 1114 A:ff40  20 33 fe                           jsr setrdl
 1115 A:ff43                                    ;
 1116 A:ff43                                    ; Monitor entry point
 1117 A:ff43                                    ;
 1118 A:ff43                           mon       
 1118 A:ff43  d8                                 cld 
 1119 A:ff44  20 15 ff                           jsr bell
 1120 A:ff47                           monz      
 1120 A:ff47  a9 2a                              lda #'*'             ; Monitor prompt
 1121 A:ff49  85 33                              sta prompt
 1122 A:ff4b  20 f5 fc                           jsr getlnz                ; get line
 1123 A:ff4e  20 aa ff                           jsr zmode                ; clear monitor mode, scan idx
 1124 A:ff51                                    ;
 1125 A:ff51                                    ; get the next item from input line
 1126 A:ff51                                    ;
 1127 A:ff51                           nxtitm    
 1127 A:ff51  20 85 ff                           jsr getnum                ; get item, non-hex
 1128 A:ff54  84 34                              sty ysav
 1129 A:ff56  a0 19                              ldy #$19             ; x-reg=0 if no hex input
 1130 A:ff58                                    ;
 1131 A:ff58                                    ; look up command subroutine for current character
 1132 A:ff58                                    ;
 1133 A:ff58                           chrsrch   
 1133 A:ff58  88                                 dey 
 1134 A:ff59  30 e8                              bmi mon                ; not found, go to mon
 1135 A:ff5b  d9 af ff                           cmp chrtbl,y              ; find cmnd char in table
 1136 A:ff5e  d0 f8                              bne chrsrch
 1137 A:ff60  20 9c ff                           jsr tosub                ; found call corresponding subroutine
 1138 A:ff63  a4 34                              ldy ysav
 1139 A:ff65  4c 51 ff                           jmp nxtitm
 1140 A:ff68                                    ;
 1141 A:ff68                                    ; save one digit from input
 1142 A:ff68                                    ; input:
 1143 A:ff68                                    ;    a - 0x00 - 0x0F
 1144 A:ff68                                    ;
 1145 A:ff68                           dig       
 1145 A:ff68  a2 03                              ldx #$03
 1146 A:ff6a  0a                                 asl 
 1147 A:ff6b  0a                                 asl                    ; shift hex digit to upper nibble
 1148 A:ff6c  0a                                 asl 
 1149 A:ff6d  0a                                 asl                    ; now it is 0x00-0xF0
 1150 A:ff6e                           nxtbit    
 1150 A:ff6e  0a                                 asl                    ; transport the high bit to carry
 1151 A:ff6f  26 3e                              rol a2l                ; rotate carry into low byte of a2,
 1152 A:ff71  26 3f                              rol a2h                ;   carry from a2l to a2h
 1153 A:ff73  ca                                 dex                    ; repeat 4 times until new digit shifted into lowest nibble of a2
 1154 A:ff74  10 f8                              bpl nxtbit
 1155 A:ff76                           nxtbas    
 1155 A:ff76  a5 31                              lda mode                ; x is $FF here
 1156 A:ff78  d0 06                              bne nxtbs2                ;   if mode is zero
 1157 A:ff7a  b5 3f                              lda a2h,x              ;    then copy a2 to
 1158 A:ff7c  95 3d                              sta a1h,x              ;     a1 and a3
 1159 A:ff7e  95 41                              sta a3h,x
 1160 A:ff80                           nxtbs2    
 1160 A:ff80  e8                                 inx                    ;   repeat once for l,h pair
 1161 A:ff81  f0 f3                              beq nxtbas
 1162 A:ff83  d0 06                              bne nxtchr
 1163 A:ff85                                    ;
 1164 A:ff85                                    ; getnum read command
 1165 A:ff85                                    ; input: y - pointer to current input char
 1166 A:ff85                                    ; result:
 1167 A:ff85                                    ;   a - mode (non-hex char after number)
 1168 A:ff85                                    ;   x - (changed)
 1169 A:ff85                                    ;   y - pointer to next char
 1170 A:ff85                                    ;   (a2) - number found or 0x0000
 1171 A:ff85                                    ;
 1172 A:ff85                           getnum    
 1172 A:ff85  a2 00                              ldx #$00             ;  clear A2
 1173 A:ff87  86 3f                              stx a2h
 1174 A:ff89  86 3e                              stx a2l
 1175 A:ff8b                           nxtchr    
 1175 A:ff8b  b9 00 02                           lda in,y              ; get char
 1176 A:ff8e  c8                                 iny 
 1177 A:ff8f  49 30                              eor #$30             ; $30 0 -> $00; $39 9 -> $09; $41 A -> $71; $20 -> $10...
 1178 A:ff91  c9 0a                              cmp #$0a
 1179 A:ff93  90 d3                              bcc dig                ; if hex digit
 1180 A:ff95  69 88                              adc #$88             ; c=1, $76 F + $88 + 1 = $FF; $71 A + $88 + 1 = $FA
 1181 A:ff97  c9 fa                              cmp #$fa
 1182 A:ff99  b0 cd                              bcs dig                ; if not a digit a now has ch eor #$30 + $B9
 1183 A:ff9b  60                                 rts 
 1184 A:ff9c                                    ;
 1185 A:ff9c                                    ; Go to command routine
 1186 A:ff9c                                    ;
 1187 A:ff9c                           tosub     
 1187 A:ff9c  98                                 tya 
 1188 A:ff9d  0a                                 asl                    ; subroutine table has 16 bit addresses now.
 1189 A:ff9e  a8                                 tay                    ; to much fumbling making them all stay on page $FE
 1190 A:ff9f  b9 c8 ff                           lda subtbl,y              ; Push high order subroutine address on stack
 1191 A:ffa2  c8                                 iny 
 1192 A:ffa3  48                                 pha 
 1193 A:ffa4  b9 c8 ff                           lda subtbl,y              ; Push low order subroutine address on stack
 1194 A:ffa7  48                                 pha 
 1195 A:ffa8  a5 31                              lda mode                ;  old mode to A
 1196 A:ffaa                                    ;
 1197 A:ffaa                                    ; clear the y flag and the current mode for next subsequence
 1198 A:ffaa                                    ;
 1199 A:ffaa                           zmode     
 1199 A:ffaa  a0 00                              ldy #$00             ; clear y
 1200 A:ffac  84 31                              sty mode                ; clear mode
 1201 A:ffae  60                                 rts                    ; go to command subroutine previously pushed on the stack
 1202 A:ffaf                                    ;
 1203 A:ffaf                                    ; macros for command line parser used in mon and asm
 1204 A:ffaf                                    ;

 1207 A:ffaf                           chrtbl    
 1207 A:ffaf  9a                                 .byt ((('!'^$30)+$89)&$ff)
 1208 A:ffb0  ea                                 .byt ((('Q'^$30)+$89)&$ff)
 1209 A:ffb1  bc                                 .byt (((k_ctl_c^$30)+$89)&$ff)
 1210 A:ffb2  b2                                 .byt (((k_ctl_y^$30)+$89)&$ff)
 1211 A:ffb3  be                                 .byt (((k_ctl_e^$30)+$89)&$ff)
 1212 A:ffb4  ed                                 .byt ((('T'^$30)+$89)&$ff)
 1213 A:ffb5  ef                                 .byt ((('V'^$30)+$89)&$ff)
 1214 A:ffb6  c4                                 .byt (((k_ctl_k^$30)+$89)&$ff)
 1215 A:ffb7  ec                                 .byt ((('S'^$30)+$89)&$ff)
 1216 A:ffb8  a9                                 .byt (((k_ctl_p^$30)+$89)&$ff)
 1217 A:ffb9  bb                                 .byt (((k_ctl_b^$30)+$89)&$ff)
 1218 A:ffba  a6                                 .byt ((('-'^$30)+$89)&$ff)
 1219 A:ffbb  a4                                 .byt ((('+'^$30)+$89)&$ff)
 1220 A:ffbc  06                                 .byt ((('M'^$30)+$89)&$ff)
 1221 A:ffbd  95                                 .byt ((('<'^$30)+$89)&$ff)
 1222 A:ffbe  07                                 .byt ((('N'^$30)+$89)&$ff)
 1223 A:ffbf  02                                 .byt ((('I'^$30)+$89)&$ff)
 1224 A:ffc0  05                                 .byt ((('L'^$30)+$89)&$ff)
 1225 A:ffc1  f0                                 .byt ((('W'^$30)+$89)&$ff)
 1226 A:ffc2  00                                 .byt ((('G'^$30)+$89)&$ff)
 1227 A:ffc3  eb                                 .byt ((('R'^$30)+$89)&$ff)
 1228 A:ffc4  93                                 .byt (((':'^$30)+$89)&$ff)
 1229 A:ffc5  a7                                 .byt ((('.'^$30)+$89)&$ff)
 1230 A:ffc6  c3                                 .byt (((k_entr^$30)+$89)&$ff)
 1231 A:ffc7  99                                 .byt (((' '^$30)+$89)&$ff)
 1232 A:ffc8                                    ; Monitor commands:
 1233 A:ffc8                                    ; '!'           enter mini assembler
 1234 A:ffc8                                    ; 'Q'           terminate emulator by jumping to $FFFF. When PC=$FFFF, the cpu loop terminates.
 1235 A:ffc8                                    ; ctrl-c        bascont
 1236 A:ffc8                                    ; ctrl-y        usr
 1237 A:ffc8                                    ; ctrl-e        regz
 1238 A:ffc8                                    ; 'T'           trace
 1239 A:ffc8                                    ; 'V'           vfy
 1240 A:ffc8                                    ; ctrl-k        inprt
 1241 A:ffc8                                    ; 'S'           stepz
 1242 A:ffc8                                    ; ctrl-p        outprt
 1243 A:ffc8                                    ; ctrl-b        x_lang
 1244 A:ffc8                                    ; '-'           setmode
 1245 A:ffc8                                    ; '+'           setmode
 1246 A:ffc8                                    ; 'M'           move
 1247 A:ffc8                                    ; '<'           lt
 1248 A:ffc8                                    ; 'N'           setnorm
 1249 A:ffc8                                    ; 'I'           setinv
 1250 A:ffc8                                    ; 'L'           list
 1251 A:ffc8                                    ; 'W'           write
 1252 A:ffc8                                    ; 'G'           go
 1253 A:ffc8                                    ; 'R'           read
 1254 A:ffc8                                    ; colon         write area addr1,addr2
 1255 A:ffc8                                    ; '.'           hexdump addr1,addr2
 1256 A:ffc8                                    ; enter         execute monitor command line
 1257 A:ffc8                                    ; ' '           add preceding command to line
 1258 A:ffc8                                    ;
 1259 A:ffc8                                    ; table must have msb first lsb second
 1260 A:ffc8                                    ;
 1261 A:ffc8                           subtbl    
 1261 A:ffc8  f4 f7                              .byt >asm_entry,<asm_entry          ; ! - Enter assembler
 1262 A:ffca  f8 1c                              .byt >exit,<exit          ; Q - Quit emulator
 1263 A:ffcc  fe 80                              .byt >bascont,<bascont          ; CTL-C - exit moitor to installed language
 1264 A:ffce  fe 97                              .byt >usr,<usr          ; CTL-Y - execute user command at vector %3F8
 1265 A:ffd0  fe 8c                              .byt >regz,<regz          ; CTL-E - examine registers
 1266 A:ffd2  fe 8f                              .byt >trace,<trace          ; "T" - Trace until reset or brk
 1267 A:ffd4  fd c2                              .byt >vfy,<vfy          ; "V" - Verify memory range
 1268 A:ffd6  fe 1a                              .byt >inprt,<inprt          ; [0-7] CTL-K - input from keyboard (0) or peripheral card 1-7
 1269 A:ffd8  fe 91                              .byt >stepz,<stepz          ; "S" - Step
 1270 A:ffda  fe 54                              .byt >outprt,<outprt          ; [0-7] CTL-P - send output to video (0) or printer peripheral 1-7
 1271 A:ffdc  fe 7d                              .byt >x_lang,<x_lang          ; CTL-B -
 1272 A:ffde  fd a4                              .byt >setmode,<setmode          ; "-" - hexadecimal substraction
 1273 A:ffe0  fd a4                              .byt >setmode,<setmode          ; "+" - hexadecimal addition
 1274 A:ffe2  fd b8                              .byt >move,<move          ; "M" - mpve memory range
 1275 A:ffe4  fd ac                              .byt >lt,<lt          ; "< aaaa.bbbb M|V" - Move / compare memory range
 1276 A:ffe6  fe 10                              .byt >setnorm,<setnorm          ; "N" - set to normal output
 1277 A:ffe8  fe 0c                              .byt >setinv,<setinv          ; "I" - set to inverse output
 1278 A:ffea  fd ea                              .byt >list,<list          ; "L" - list preceding memory add
 1279 A:ffec  fe 9a                              .byt >write,<write          ; "aaaa.bbbb W" - Save memory range on tape
 1280 A:ffee  fe 83                              .byt >go,<go          ; "aaaa G" - Run program as subroutine at aaaa
 1281 A:fff0  fe d1                              .byt >read,<read          ; "aaaa.bbbb R" - Read memory range from tape
 1282 A:fff2  fd a4                              .byt >setmode,<setmode          ; colon xx yy... - change current location. to given ehx bytes
 1283 A:fff4  fd a4                              .byt >setmode,<setmode          ; ".yyyy" - examine bytes between after current position and yyyy
 1284 A:fff6  fe ca                              .byt >crmon,<crmon          ; enter - starts evaluation of commands in input line
 1285 A:fff8  fd 90                              .byt >blank,<blank          ; space separator
 1286 A:fffa                                    ;
 1287 A:fffa                                    ; 6502 fixed system vectors. Must start at 0xFFFA
 1288 A:fffa                                    ; .org not working here, adjusting with
 1289 A:fffa                                    ; .dsb block "keep_aligned" above
 1290 A:fffa                                    ;
 1291 A:fffa                           sysvec_nmi 
 1291 A:fffa  fb 03                              .word nmiloc                ; nmi vector set up in RAM by reset routine
 1292 A:fffc                           sysvec_reset 
 1292 A:fffc  34 ff                              .word reset                ; reset vector
 1293 A:fffe                           sysvec_irq 
 1293 A:fffe  63 fa                              .word irqvec                ; irq vector in rom
