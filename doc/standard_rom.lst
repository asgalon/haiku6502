
rom.s

    1 A:1000                                    ;
    2 A:1000                                    ; haiku6502 ROM
    3 A:1000                                    ;
    4 A:1000                                    ; Annotated and modified emulator ROM using orig_monitor_rom.s as a template.
    5 A:1000                                    ; This code is only for academic purposes.
    6 A:1000                                    ; This file is compatible with xa assembler and is not relocatable.
    7 A:1000                                    ; Care has to be taken to keep the "go" jump table addresses area on page 0xFE or else it will cease to work this way.
    8 A:1000                                    ; There are a few nifty tricks in the original assembler code to save a few bytes here and there that probably
    9 A:1000                                    ; would not have been done this way were there more than 12KB address space available for ROM.
   10 A:1000                                    ;
   11 A:1000                                    ; The following modifications have been made:
   12 A:1000                                    ;
   13 A:1000                                    ; - fixed character mapping. ASCII chars are now ASCII chars in the right code points.
   14 A:1000                                    ; - removed memory mapped text and graphics screens. The screen is now a terminal peripheral controlled
   15 A:1000                                    ;   through I/O ports 0xC010-0xC01F
   16 A:1000                                    ; - keyboard strobe is now in 0xC001, to make space for more i/o control addresses
   17 A:1000                                    ; - removed screen address calculations, no longer needed with sane terminal cursor coordinates that
   18 A:1000                                    ;   are no longer aligned with cathode ray tube electronic beam scan sequence.
   19 A:1000                                    ; - Bell just sends a CTL-G to terminal
   20 A:1000                                    ; - Tape in/out write/reads the memory directly to the tape file, without square wave frequency modulated encoding.
   21 A:1000                                    ; - The screen size is taken from the terminal dimensions. Size is no longer restricted to 1KB text pages.
   22 A:1000                                    ; - Lo-Res and Hi-Res graphics modes are gone for now since they don't work too well with the standard ncurses based
   23 A:1000                                    ;   terminal peripheral. A graphics terminal peripheral could be added, though.
   24 A:1000                                    ; - The peripheral system is not completed, especially emulator interrupt management is rudimentary. So peripheral
   25 A:1000                                    ;   rom areas can be addressed, but the extension rom area 0xC800-0xC8FF needs work. This does not ffect this rom,
   26 A:1000                                    ;   though...
   27 A:1000                                    ; - Added 'Q' command to monitor to terminate emulator via jump to address $FFFF
   28 A:1000                                    ; - Added Mni-Assembler command as '!', '*' returns from mini-assembler to monitor
   29 A:1000                                    ; - Mini-Assembler resurrected following mostly the manual description. It is a complete new implementation in asm.s
   30 A:1000                                    ; The monitor part works pretty much the same as described in the Apple II Reference Manual. It has a nice disassembler.
   31 A:1000                                    ; It provides RAM editing as hex dump only for now.
   32 A:1000                                    ;
   33 A:1000                                    ; Memory layout:
   34 A:1000                                    ;
   35 A:1000                                    ; 0x0000-0x00FF Zero page
   36 A:1000                                    ; 0x0100-9x01FF Stack
   37 A:1000                                    ; 0x0200-0x02FF text buffer
   38 A:1000                                    ; 0x0300-0x03FF system vars & vectors
   39 A:1000                                    ; 0x0400-0xBFFF free RAM
   40 A:1000                                    ; 0xC000-0xCFFF I/O
   41 A:1000                                    ; 0xD000-0xFFFF ROM; thereof
   42 A:1000                                    ;               0xD000 - 0xF500 Reserved for language modules
   43 A:1000                                    ;               0xF4BF - 0xF800 Mini-Assembler (asm.s)
   44 A:1000                                    ;               0xF800 - 0xFFFF System Monitor ROM
   45 A:1000                                    ;               0xFFFA - 0xFFFF Hardwired 6502 NMI, Reset and IRQ vectors, have to be kept at fixed addresses.
   46 A:1000                                    ; On Reset, the program counter is loaded from 0xFFFC and 0xFFFD. all addresses with least
   47 A:1000                                    ; significant (lsb,low) byte first.
   48 A:1000                                    ;
   49 A:1000                                    ; TODO Fix remaining bugs, cleanup code.
   50 A:1000                                    ;

   52 A:1000                                     .include "symbols.inc"

symbols.inc

    1 A:1000                                    ; common symbol definitions, based on
    2 A:1000                                    ; 1979 Apple ][ Reference Manual, Monitor ROM Listing

    4 A:1000                                    loc0=$00
    5 A:1000                                    loc1=$01
    6 A:1000                                    wndlft=$20
    7 A:1000                                    wndwdth=$21
    8 A:1000                                    wndtop=$22
    9 A:1000                                    wndbtm=$23
   10 A:1000                                    ch=$24
   11 A:1000                                    cv=$25

   13 A:1000                                    rdline=$28           ; vector for readline
   14 A:1000                                    rdlinh=$29           ;   msb
   15 A:1000                                    h2=$2c
   16 A:1000                                    lmnem=$2c
   17 A:1000                                    rtnl=$2c
   18 A:1000                                    v2=$2d
   19 A:1000                                    rmnem=$2d
   20 A:1000                                    rtnh=$2d
   21 A:1000                                    mask=$2e
   22 A:1000                                    chksum=$2e
   23 A:1000                                    format=$2e

   25 A:1000                                    length=$2f
   26 A:1000                                    sign=$2f
   27 A:1000                                    color=$30
   28 A:1000                                    mode=$31
   29 A:1000                                    invflg=$32
   30 A:1000                                    prompt=$33
   31 A:1000                                    ysav=$34
   32 A:1000                                    ysav1=$35
   33 A:1000                                    cswl=$36           ; CSW character out vector
   34 A:1000                                    cswh=$37
   35 A:1000                                    kswl=$38           ; keyboard input vector
   36 A:1000                                    kswh=$39
   37 A:1000                                    pcl=$3a
   38 A:1000                                    pch=$3b
   39 A:1000                                    xqt=$3c
   40 A:1000                                    xqtnz=$3c
   41 A:1000                                    a1l=$3c
   42 A:1000                                    a1h=$3d
   43 A:1000                                    a2l=$3e
   44 A:1000                                    a2h=$3f
   45 A:1000                                    a3l=$40
   46 A:1000                                    a3h=$41
   47 A:1000                                    a4l=$42
   48 A:1000                                    mnem=$42           ; temp mnemonic index
   49 A:1000                                    a4h=$43
   50 A:1000                                    cmdlen=$43           ; instruction length for assembler, 1-3 bytes
   51 A:1000                                    a5l=$44
   52 A:1000                                    opcode=$44           ; temp opcode for assembler
   53 A:1000                                    a5h=$45
   54 A:1000                                    adrl=$45           ; low address byte for assembler
   55 A:1000                                    acc=$45
   56 A:1000                                    adrh=$46           ; high address byte for assembler
   57 A:1000                                    xreg=$46
   58 A:1000                                    opb=$47           ; opcode 'b' bits
   59 A:1000                                    yreg=$47
   60 A:1000                                    status=$48
   61 A:1000                                    spnt=$49
   62 A:1000                                    rndl=$4e           ; pseudo-random
   63 A:1000                                    rndh=$4f
   64 A:1000                                    acl=$50
   65 A:1000                                    ach=$51
   66 A:1000                                    xtndl=$52
   67 A:1000                                    xtndh=$53
   68 A:1000                                    auxl=$54
   69 A:1000                                    opmode=$54
   70 A:1000                                    auxh=$55
   71 A:1000                                    in=$0200           ; input buffer base
   72 A:1000                                    usradr=$03f8
   73 A:1000                                    nmiloc=$03fb
   74 A:1000                                    irqloc=$03fe

   76 A:1000                                    ioadr=$c000
   77 A:1000                                    kbd=$c000
   78 A:1000                                    kbdstrb=$c001
   79 A:1000                                    rnd=$c00f           ; random byte RO

   81 A:1000                                    termcy=$c010           ; terminal cursor y   RW
   82 A:1000                                    termcx=$c011           ; terminal cursor x   RW
   83 A:1000                                    termout=$c012           ; termout character under cursor RW
   84 A:1000                                    termesc=$c013           ; terminal connamd byte W
   85 A:1000                                    termea1=$c014           ; terminal command argl   (bad design, will change)
   86 A:1000                                    termea2=$c015           ; terminal command argh
   87 A:1000                                    termwh=$c016           ; temrinal window height
   88 A:1000                                    termww=$c017           ; terminal window width
   89 A:1000                                    termin=$c018
   90 A:1000                                    terml=$c019           ; stdio mode next line char of 0 terminated string. R
   91 A:1000                                    termp=$c01a           ; stdio mode next line char of 0 terminated string. RW
   92 A:1000                                    termmd=$c01f           ; terminal mode, RO. #$00 - screen, #$01 - stdio

   94 A:1000                                    tapeio=$c020           ; read/write byte from/to tape file
   95 A:1000                                    tapecls=$c021

   97 A:1000                                    spkr=$c030
   98 A:1000                                    paddl0=$c061
   99 A:1000                                    ptrig=$c070

  101 A:1000                                    ;
  102 A:1000                                    ;  Ecape commands for terminal:
  103 A:1000                                    ;
  104 A:1000                                    t_cls=$00           ; Clear screen
  105 A:1000                                    t_cll=$01           ; clear from cursor to end of line
  106 A:1000                                    t_clb=$02           ; clear from cursor to end of line
  107 A:1000                                    t_scr=$03           ; scroll one line up
  108 A:1000                                    t_norm=$04           ; normal chars
  109 A:1000                                    t_inv=$05           ; inverse chars
  110 A:1000                                    t_blnk=$06           ; blinking chars
  111 A:1000                                    t_qcch=$07           ; query current character under cursor

  113 A:1000                                    ; t_qy    = $04   ; query terminal cursor y; for result read terminl,h
  114 A:1000                                    ; t_qx    = $05   ; query terminal cursor x; for result read terminl,h

  116 A:1000                                    ; characters
  117 A:1000                                    k_ctl_a=$01
  118 A:1000                                    k_ctl_b=$02
  119 A:1000                                    k_ctl_c=$03
  120 A:1000                                    k_ctl_d=$04
  121 A:1000                                    k_ctl_e=$05
  122 A:1000                                    k_ctl_f=$06
  123 A:1000                                    k_ctl_g=$07
  124 A:1000                                    k_bs=$08
  125 A:1000                                    k_tab=$09
  126 A:1000                                    k_lf=$0a
  127 A:1000                                    k_ctl_k=$0b
  128 A:1000                                    k_ctl_l=$0c
  129 A:1000                                    k_cr=$0a
  130 A:1000                                    k_ctl_n=$0e
  131 A:1000                                    k_ctl_o=$0f
  132 A:1000                                    k_ctl_p=$10
  133 A:1000                                    k_ctl_q=$11
  134 A:1000                                    k_ctl_r=$12
  135 A:1000                                    k_ctl_s=$13
  136 A:1000                                    k_ctl_t=$14
  137 A:1000                                    k_ctl_u=$15
  138 A:1000                                    k_ctl_v=$16
  139 A:1000                                    k_ctl_w=$17
  140 A:1000                                    k_ctl_x=$18
  141 A:1000                                    k_ctl_y=$19
  142 A:1000                                    k_ctl_z=$1a
  143 A:1000                                    k_esc=$1b
  144 A:1000                                    k_entr=k_cr
  145 A:1000                                    gr_top='+'
  146 A:1000                                    gr_btm='_'
  147 A:1000                                    colon=$3a
  148 A:1000                                    gr_grid=$61

rom.s


   54 A:1000                                     *= $d000              ; ROM start address
   55 A:d000  00 ff 00 10 00 24 2c ...           .dsb $1000,$00        ; first filler, 4KB low ROM
   56 A:e000                           lang      
   56 A:e000  20 06 e0                           jsr lang_init
   57 A:e003                           lang2     
   57 A:e003  4c 07 e0                           jmp lang_cont
   58 A:e006                           lang_init 
   58 A:e006  60                                 rts 
   59 A:e007                           lang_cont 
   59 A:e007  00 ff 03 15 00 24 2c ...           .dsb $1503,$00        ; filler up to F800

   61 A:f50a                                     .include "asm.s"

asm.s

    1 A:f50a                                    ;
    2 A:f50a                                    ; Mini-Assembler
    3 A:f50a                                    ;
    4 A:f50a                                    ; Assembles single instruction at the program cursor into machine code.
    5 A:f50a                                    ; Following the syntax documented in the Apple II Reference manual
    6 A:f50a                                    ;
    7 A:f50a                                    ; xa assembler seems to have some obscure problems with block markers, so everything
    8 A:f50a                                    ; is on top level. I tried with block proc and (, but tht produced sntax errors far, far away
    9 A:f50a                                    ; Solution would be to use a different assembler. but they all have their quirks.
   10 A:f50a                                    ;
   11 A:f50a                           nextch    
   11 A:f50a  c8                                 iny 
   12 A:f50b  b9 00 02                           lda in,y
   13 A:f50e  60                                 rts 
   14 A:f50f                                    ;
   15 A:f50f                                    ; consume blanks and $ signs,
   16 A:f50f                                    ; since all numbers are hex
   17 A:f50f                                    ; returns first non ignored char in a
   18 A:f50f                                    ;
   19 A:f50f                           eatblp    
   19 A:f50f  c8                                 iny 
   20 A:f510                           eatblank  
   20 A:f510  b9 00 02                           lda in,y
   21 A:f513  c9 20                              cmp #' '
   22 A:f515  f0 f8                              beq eatblp
   23 A:f517  c9 24                              cmp #'$'
   24 A:f519  f0 f4                              beq eatblp
   25 A:f51b  60                                 rts 
   26 A:f51c                                    ; get code for menmonic
   27 A:f51c                                    ; input: a has first letter.
   28 A:f51c                                    ; return: mnem index in x
   29 A:f51c                           syntaxerr 
   29 A:f51c  20 15 ff                           jsr bell
   30 A:f51f  a9 20                              lda #' '
   31 A:f521                           @blnks    
   31 A:f521  20 c2 fd                           jsr cout
   32 A:f524  88                                 dey 
   33 A:f525  10 fa                              bpl @blnks
   34 A:f527  a9 5e                              lda #'^'
   35 A:f529  20 c2 fd                           jsr cout
   36 A:f52c  a6 49                              ldx spnt                ; restore entry point stack position
   37 A:f52e  9a                                 txs 
   38 A:f52f  4c 55 f5                           jmp asmz

   40 A:f532                           setaddr   
   40 A:f532  20 aa ff                           jsr zmode                ; clear (reused) monitor mode, scan idx
   41 A:f535  20 85 ff                           jsr getnum
   42 A:f538  88                                 dey                    ; recover non-digit item
   43 A:f539  60                                 rts 
   44 A:f53a                           hasaddr   
   44 A:f53a  a0 04                              ldy #$04             ; look at first 5 chars, beginning with last
   45 A:f53c                           @hadrlp   
   45 A:f53c  b9 00 02                           lda in,y
   46 A:f53f  c9 3a                              cmp #':'
   47 A:f541  f0 ef                              beq setaddr                ; if so, set current address
   48 A:f543  88                                 dey 
   49 A:f544  10 f6                              bpl @hadrlp
   50 A:f546  a0 00                              ldy #$00             ; no address found, reset 'in' pointer
   51 A:f548  60                                 rts 
   52 A:f549                                    ;
   53 A:f549                                    ; Mini-Assembler entry point.
   54 A:f549                                    ;
   55 A:f549                           asm_entry 
   55 A:f549  d8                                 cld                    ; who knows where we came from... bcd mode tends to confuse hex based arithmetics.
   56 A:f54a                                    ;
   57 A:f54a                                    ; save stack pointer to spnt to return to clean state
   58 A:f54a                                    ; when processing syntax errors
   59 A:f54a                                    ; from deeper subroutine level.
   60 A:f54a                                    ; very crude exception handling.
   61 A:f54a                                    ; This makes it possible to handle syntax errors in subroutines
   62 A:f54a                                    ; without too much overhead - process is aborted and asm returns to prompt.
   63 A:f54a                                    ;
   64 A:f54a  ba                                 tsx 
   65 A:f54b  86 49                              stx spnt
   66 A:f54d  a5 3c                              lda a1l
   67 A:f54f  85 3a                              sta pcl
   68 A:f551  a5 3d                              lda a1h
   69 A:f553  85 3b                              sta pch
   70 A:f555                                    ;
   71 A:f555                                    ; main assembler loop
   72 A:f555                                    ;
   73 A:f555                           asmz      
   73 A:f555  a9 21                              lda #'!'
   74 A:f557  85 33                              sta prompt                ; set prompt to '!'
   75 A:f559  20 63 fd                           jsr crout
   76 A:f55c  a4 3d                              ldy a1h                ; print CR,A1 in hex
   77 A:f55e  a6 3c                              ldx a1l
   78 A:f560  20 a7 f9                           jsr prntyx                ; output cr and address
   79 A:f563  20 a9 f8                           jsr getlnv
   80 A:f566  20 aa ff                           jsr zmode
   81 A:f569  20 3a f5                           jsr hasaddr                ; see if line has address label "%x:"
   82 A:f56c  a2 01                              ldx #$01
   83 A:f56e                           @setpcl   
   83 A:f56e  b5 3c                              lda a1l,x
   84 A:f570  95 3a                              sta pcl,x
   85 A:f572  ca                                 dex 
   86 A:f573  10 f9                              bpl @setpcl

   88 A:f575  20 10 f5                           jsr eatblank                ; skip whitespace
   89 A:f578  c9 0a                              cmp #k_entr               ; empty line, return to prompt
   90 A:f57a  f0 d9                              beq asmz

   92 A:f57c                                    ;
   93 A:f57c                                    ; on '*' return to monitor.
   94 A:f57c                                    ;
   95 A:f57c  c9 2a                              cmp #'*'
   96 A:f57e  d0 03                              bne @procmnm
   97 A:f580  4c 47 ff                           jmp monz
   98 A:f583                                    ;
   99 A:f583                                    ; get the mnemonic from input line
  100 A:f583                                    ;
  101 A:f583                                    ;
  102 A:f583                                    ; get coded mnemonic into a4
  103 A:f583                                    ; ((menm0 & 0x1f) << 10) + ((menm1 & 0x1f) << 5) + (menm2 & 0x1f)
  104 A:f583                                    ; so the opcode forms a word with 13 bits used.
  105 A:f583                                    ; impossible mnemonics produce a syntax error, invalid mnemonics will produce an
  106 A:f583                                    ; unknown opcode
  107 A:f583                                    ;
  108 A:f583                           @procmnm  
  108 A:f583  29 1f                              and #$1f             ; ex.:  PHP                                            'P' = $50 -> $10
  109 A:f585  85 43                              sta a4h                ;
  110 A:f587  a9 00                              lda #$00
  111 A:f589  8d 00 02                           sta in                ; put a zero into first position to mark input buffer old news.
  112 A:f58c  20 0a f5                           jsr nextch                ; $1F useful bits, have to make room for 5 more        `H' = $48, useful $08
  113 A:f58f  0a                                 asl                    ; $3E                                                        $90
  114 A:f590  0a                                 asl                    ; $7C                                                        $20
  115 A:f591  0a                                 asl                    ; $F8                                                        $40
  116 A:f592  0a                                 asl                    ; $01F0 high bit-> carry                                     $80 + 0
  117 A:f593  26 43                              rol a4h                ; $3FF0                                               $20    $80
  118 A:f595  0a                                 asl                    ; $03E0 high bit-> carry                                     $00 + 1
  119 A:f596  26 43                              rol a4h                ; $7FE0                                               $41    $00
  120 A:f598  85 42                              sta a4l                ; $E0 , five lower bits free                                 $00
  121 A:f59a  20 0a f5                           jsr nextch                ; $1F                                                  'P' = $50
  122 A:f59d  29 1f                              and #$1f             ;                                                            $10
  123 A:f59f  05 42                              ora a4l                ;                                                            $10
  124 A:f5a1  85 42                              sta a4l                ;                                                     $41    $10
  125 A:f5a3                                    ;
  126 A:f5a3                                    ; now we have the short form in a4.
  127 A:f5a3                                    ; go on to find the mnemonic in opcodex table
  128 A:f5a3                                    ; and tehn return this index to the opcode lookup tables
  129 A:f5a3  a2 71                              ldx #(opcodez-opcodex-1)+2
  130 A:f5a5                           @firstfail 
  130 A:f5a5  ca                                 dex 
  131 A:f5a6                           @scndfail 
  131 A:f5a6  ca                                 dex 
  132 A:f5a7  10 03                              bpl @cont
  133 A:f5a9  4c 1c f5                           jmp syntaxerr
  134 A:f5ac                           @cont     
  134 A:f5ac  bd c6 f5                           lda opcodex,x     high
  135 A:f5af  c5 43                              cmp a4h
  136 A:f5b1  d0 f2                              bne @firstfail
  137 A:f5b3  ca                                 dex 
  138 A:f5b4  bd c6 f5                           lda opcodex,x     low
  139 A:f5b7  c5 42                              cmp a4l
  140 A:f5b9  d0 eb                              bne @scndfail
  141 A:f5bb  8a                                 txa 
  142 A:f5bc  4a                                 lsr                    ; rest of the tables have bytes not words, so half it.
  143 A:f5bd  85 42                              sta mnem
  144 A:f5bf  c8                                 iny                    ; point to char after mnemonic
  145 A:f5c0                                    ;
  146 A:f5c0                                    ; at this point, we have the address set in a1-a3 and the
  147 A:f5c0                                    ; mnemonic code number in a4l.
  148 A:f5c0                                    ; Now proceed to  evaluate address part.
  149 A:f5c0                                    ; Following modes are possible:
  150 A:f5c0                                    ; - None. Command does not take arguments, it is finished.
  151 A:f5c0                                    ; - Immediate:  #Value
  152 A:f5c0                                    ; - Adr/Rel:    Address
  153 A:f5c0                                    ; - Indexed:    Address,X|Y
  154 A:f5c0                                    ; - indirect:   (Address)
  155 A:f5c0                                    ; - indir. indxd (Address),Y
  156 A:f5c0                                    ; - indexed ind. (Address,X)
  157 A:f5c0  20 10 f5                           jsr eatblank
  158 A:f5c3  4c 07 f7                           jmp eval_arg
  159 A:f5c6                                    ;
  160 A:f5c6                                    ; opcode char mappings
  161 A:f5c6                                    ;
  162 A:f5c6                           opcodex   
  162 A:f5c6                                    
  163 A:f5c6                                     .include "opcodes_compressed.s"

opcodes_compressed.s

    1 A:f5c6                                    ;
    2 A:f5c6                                    ; opcode char mappings
    3 A:f5c6                                    ;
    4 A:f5c6                                    ; mnemonic letters lower 5 bits with first letter left shifted 10 bits,
    5 A:f5c6                                    ; second letter left-shifted 5 bits.
    6 A:f5c6                                    ;
    7 A:f5c6                                    ; python calc_opval.py > opcodes_compressed.s
    8 A:f5c6                                    ;
    9 A:f5c6  83 04                              .word $0483              ; ADC   - $00   ($00)
   10 A:f5c8  c4 05                              .word $05c4              ; AND   - $01   ($02)
   11 A:f5ca  6c 06                              .word $066c              ; ASL   - $02   ($04)
   12 A:f5cc  63 08                              .word $0863              ; BCC   - $03   ($06)
   13 A:f5ce  73 08                              .word $0873              ; BCS   - $04   ($08)
   14 A:f5d0  b1 08                              .word $08b1              ; BEQ   - $05   ($0a)
   15 A:f5d2  34 09                              .word $0934              ; BIT   - $06   ($0c)
   16 A:f5d4  a9 09                              .word $09a9              ; BMI   - $07   ($0e)
   17 A:f5d6  c5 09                              .word $09c5              ; BNE   - $08   ($10)
   18 A:f5d8  0c 0a                              .word $0a0c              ; BPL   - $09   ($12)
   19 A:f5da  4b 0a                              .word $0a4b              ; BRK   - $0a   ($14)
   20 A:f5dc  c3 0a                              .word $0ac3              ; BVC   - $0b   ($16)
   21 A:f5de  d3 0a                              .word $0ad3              ; BVS   - $0c   ($18)
   22 A:f5e0  83 0d                              .word $0d83              ; CLC   - $0d   ($1a)
   23 A:f5e2  84 0d                              .word $0d84              ; CLD   - $0e   ($1c)
   24 A:f5e4  89 0d                              .word $0d89              ; CLI   - $0f   ($1e)
   25 A:f5e6  96 0d                              .word $0d96              ; CLV   - $10   ($20)
   26 A:f5e8  b0 0d                              .word $0db0              ; CMP   - $11   ($22)
   27 A:f5ea  18 0e                              .word $0e18              ; CPX   - $12   ($24)
   28 A:f5ec  19 0e                              .word $0e19              ; CPY   - $13   ($26)
   29 A:f5ee  a3 10                              .word $10a3              ; DEC   - $14   ($28)
   30 A:f5f0  b8 10                              .word $10b8              ; DEX   - $15   ($2a)
   31 A:f5f2  b9 10                              .word $10b9              ; DEY   - $16   ($2c)
   32 A:f5f4  f2 15                              .word $15f2              ; EOR   - $17   ($2e)
   33 A:f5f6  c3 25                              .word $25c3              ; INC   - $18   ($30)
   34 A:f5f8  d8 25                              .word $25d8              ; INX   - $19   ($32)
   35 A:f5fa  d9 25                              .word $25d9              ; INY   - $1a   ($34)
   36 A:f5fc  b0 29                              .word $29b0              ; JMP   - $1b   ($36)
   37 A:f5fe  72 2a                              .word $2a72              ; JSR   - $1c   ($38)
   38 A:f600  81 30                              .word $3081              ; LDA   - $1d   ($3a)
   39 A:f602  98 30                              .word $3098              ; LDX   - $1e   ($3c)
   40 A:f604  99 30                              .word $3099              ; LDY   - $1f   ($3e)
   41 A:f606  72 32                              .word $3272              ; LSR   - $20   ($40)
   42 A:f608  f0 39                              .word $39f0              ; NOP   - $21   ($42)
   43 A:f60a  41 3e                              .word $3e41              ; ORA   - $22   ($44)
   44 A:f60c  01 41                              .word $4101              ; PHA   - $23   ($46)
   45 A:f60e  10 41                              .word $4110              ; PHP   - $24   ($48)
   46 A:f610  81 41                              .word $4181              ; PLA   - $25   ($4a)
   47 A:f612  90 41                              .word $4190              ; PLP   - $26   ($4c)
   48 A:f614  ec 49                              .word $49ec              ; ROL   - $27   ($4e)
   49 A:f616  f2 49                              .word $49f2              ; ROR   - $28   ($50)
   50 A:f618  89 4a                              .word $4a89              ; RTI   - $29   ($52)
   51 A:f61a  93 4a                              .word $4a93              ; RTS   - $2a   ($54)
   52 A:f61c  43 4c                              .word $4c43              ; SBC   - $2b   ($56)
   53 A:f61e  a3 4c                              .word $4ca3              ; SEC   - $2c   ($58)
   54 A:f620  a4 4c                              .word $4ca4              ; SED   - $2d   ($5a)
   55 A:f622  a9 4c                              .word $4ca9              ; SEI   - $2e   ($5c)
   56 A:f624  81 4e                              .word $4e81              ; STA   - $2f   ($5e)
   57 A:f626  98 4e                              .word $4e98              ; STX   - $30   ($60)
   58 A:f628  99 4e                              .word $4e99              ; STY   - $31   ($62)
   59 A:f62a  38 50                              .word $5038              ; TAX   - $32   ($64)
   60 A:f62c  39 50                              .word $5039              ; TAY   - $33   ($66)
   61 A:f62e  78 52                              .word $5278              ; TSX   - $34   ($68)
   62 A:f630  01 53                              .word $5301              ; TXA   - $35   ($6a)
   63 A:f632  13 53                              .word $5313              ; TXS   - $36   ($6c)
   64 A:f634  21 53                              .word $5321              ; TYA   - $37   ($6e)

asm.s

    1 A:f636                           opcodez   
    1 A:f636                                    

  165 A:f636                                    ;
  166 A:f636                                    ; opmode groups
  167 A:f636                                    ;
  168 A:f636                                    ;                                       |Impl|Imm|Abs |Zero|z_x |z_y |a_x |a_y |Rel |ix_ir|ir_ix|Ind
  169 A:f636                                    ; type 0: implied/accu, no arguments    | *  |   |    |    |    |    |    |    |    |     |     |
  170 A:f636                                    ; type 1: relative                      |    |   |(*) |    |    |    |    |    | <- |     |     |
  171 A:f636                                    ; type 2: full in (like adc)            |    | * | *  | *  | *  |    | *  | *  |    | *   | *   |
  172 A:f636                                    ; type 3: full out (without implied)    |    |   | *  | *  | *  |    | *  | *  |    | *   | *   |
  173 A:f636                                    ; type 4: shifting                      | *  |   | *  | *  | *  |    | *  |    |    |     |     |
  174 A:f636                                    ; type 5: cpx                           |    | * | *  | *  |    |    |    |    |    |     |     |
  175 A:f636                                    ; type 6: bit                           |    |   | *  | *  |    |    |    |    |    |     |     |
  176 A:f636                                    ; type 7: dec                           |    |   | *  | *  | *  |    | *  |    |    |     |     |
  177 A:f636                                    ; type 8: jmp                           |    |   | *  |    |    |    |    |    |    |     |     | *
  178 A:f636                                    ; type 9: jsr                           |    |   | *  |    |    |    |    |    |    |     |     |
  179 A:f636                                    ; type a: ldx/ldy changing index reg    |    | * |    | *  | y  | x  | y  | x  |    |     |     |
  180 A:f636                                    ; type b: stx/sty changing index reg    |    |   | *  | *  | y  | x  |    |    |    |     |     |
  181 A:f636                                    ;
  182 A:f636                           opmodes   
  182 A:f636                                    
  183 A:f636  02                                 .byt $02              ; 'ADC'    - 00
  184 A:f637  02                                 .byt $02              ; 'AND'
  185 A:f638  04                                 .byt $04              ; 'ASL'
  186 A:f639  01                                 .byt $01              ; 'BCC'
  187 A:f63a  01                                 .byt $01              ; 'BCS'
  188 A:f63b  01                                 .byt $01              ; 'BEQ'
  189 A:f63c  06                                 .byt $06              ; 'BIT'
  190 A:f63d  01                                 .byt $01              ; 'BMI'
  191 A:f63e  01                                 .byt $01              ; 'BNE'    - 08
  192 A:f63f  01                                 .byt $01              ; 'BPL'
  193 A:f640  00                                 .byt $00              ; 'BRK'
  194 A:f641  01                                 .byt $01              ; 'BVC'
  195 A:f642  01                                 .byt $01              ; 'BVS'
  196 A:f643  00                                 .byt $00              ; 'CLC'
  197 A:f644  00                                 .byt $00              ; 'CLD'
  198 A:f645  00                                 .byt $00              ; 'CLI'
  199 A:f646  00                                 .byt $00              ; 'CLV'    - 10
  200 A:f647  02                                 .byt $02              ; 'CMP'
  201 A:f648  05                                 .byt $05              ; 'CPX'
  202 A:f649  05                                 .byt $05              ; 'CPY'
  203 A:f64a  07                                 .byt $07              ; 'DEC'
  204 A:f64b  00                                 .byt $00              ; 'DEX'
  205 A:f64c  00                                 .byt $00              ; 'DEY'
  206 A:f64d  02                                 .byt $02              ; 'EOR'
  207 A:f64e  07                                 .byt $07              ; 'INC'    - 18
  208 A:f64f  00                                 .byt $00              ; 'INX'
  209 A:f650  00                                 .byt $00              ; 'INY'
  210 A:f651  08                                 .byt $08              ; 'JMP'
  211 A:f652  09                                 .byt $09              ; 'JSR'
  212 A:f653  02                                 .byt $02              ; 'LDA'
  213 A:f654  0a                                 .byt $0a              ; 'LDX'
  214 A:f655  0a                                 .byt $0a              ; 'LDY'
  215 A:f656  04                                 .byt $04              ; 'LSR'    - 20
  216 A:f657  00                                 .byt $00              ; 'NOP'
  217 A:f658  02                                 .byt $02              ; 'ORA'
  218 A:f659  00                                 .byt $00              ; 'PHA'
  219 A:f65a  00                                 .byt $00              ; 'PHP'
  220 A:f65b  00                                 .byt $00              ; 'PLA'
  221 A:f65c  00                                 .byt $00              ; 'PLP'
  222 A:f65d  04                                 .byt $04              ; 'ROL'
  223 A:f65e  04                                 .byt $04              ; 'ROR'    - 28
  224 A:f65f  00                                 .byt $00              ; 'RTI'
  225 A:f660  00                                 .byt $00              ; 'RTS'
  226 A:f661  02                                 .byt $02              ; 'SBC'
  227 A:f662  00                                 .byt $00              ; 'SEC'
  228 A:f663  00                                 .byt $00              ; 'SED'
  229 A:f664  00                                 .byt $00              ; 'SEI'
  230 A:f665  03                                 .byt $03              ; 'STA'
  231 A:f666  0b                                 .byt $0b              ; 'STX'    - 30
  232 A:f667  0b                                 .byt $0b              ; 'STY'
  233 A:f668  00                                 .byt $00              ; 'TAX'
  234 A:f669  00                                 .byt $00              ; 'TAY'
  235 A:f66a  00                                 .byt $00              ; 'TSX'
  236 A:f66b  00                                 .byt $00              ; 'TXA'
  237 A:f66c  00                                 .byt $00              ; 'TXS'
  238 A:f66d  00                                 .byt $00              ; 'TYA'    - 37
  239 A:f66e                           opmodez   
  239 A:f66e                                    
  240 A:f66e                                    ;
  241 A:f66e                                    ;   This is the basic opcodes with bits %aaabbbcc
  242 A:f66e                                    ;   for instructions that only have implied mode
  243 A:f66e                                    ;   the full opcode is given with bbb bits
  244 A:f66e                                    ;   also set to speed up emission.
  245 A:f66e                                    ;   see https:
  246 A:f66e                                    ;
  247 A:f66e                           code_ac   
  247 A:f66e                                    
  248 A:f66e  61                                 .byt $61              ; 'ADC'    - 00
  249 A:f66f  21                                 .byt $21              ; 'AND'
  250 A:f670  02                                 .byt $02              ; 'ASL'
  251 A:f671  90                                 .byt $90              ; 'BCC'
  252 A:f672  b0                                 .byt $b0              ; 'BCS'
  253 A:f673  f0                                 .byt $f0              ; 'BEQ'
  254 A:f674  06                                 .byt $06              ; 'BIT'
  255 A:f675  30                                 .byt $30              ; 'BMI'
  256 A:f676  d0                                 .byt $d0              ; 'BNE'    - 08
  257 A:f677  10                                 .byt $10              ; 'BPL'
  258 A:f678  00                                 .byt $00              ; 'BRK'
  259 A:f679  50                                 .byt $50              ; 'BVC'
  260 A:f67a  70                                 .byt $70              ; 'BVS'
  261 A:f67b  18                                 .byt $18              ; 'CLC'
  262 A:f67c  d8                                 .byt $d8              ; 'CLD'
  263 A:f67d  58                                 .byt $58              ; 'CLI'
  264 A:f67e  b8                                 .byt $b8              ; 'CLV'    - 10
  265 A:f67f  61                                 .byt $61              ; 'CMP'
  266 A:f680  e0                                 .byt $e0              ; 'CPX'
  267 A:f681  c0                                 .byt $c0              ; 'CPY'
  268 A:f682  c2                                 .byt $c2              ; 'DEC'
  269 A:f683  ca                                 .byt $ca              ; 'DEX'
  270 A:f684  88                                 .byt $88              ; 'DEY'
  271 A:f685  41                                 .byt $41              ; 'EOR'
  272 A:f686  e2                                 .byt $e2              ; 'INC'    - 18
  273 A:f687  e8                                 .byt $e8              ; 'INX'
  274 A:f688  c8                                 .byt $c8              ; 'INY'
  275 A:f689  4c                                 .byt $4c              ; 'JMP'
  276 A:f68a  20                                 .byt $20              ; 'JSR'
  277 A:f68b  a1                                 .byt $a1              ; 'LDA'
  278 A:f68c  a2                                 .byt $a2              ; 'LDX'
  279 A:f68d  a0                                 .byt $a0              ; 'LDY'
  280 A:f68e  42                                 .byt $42              ; 'LSR'    - 20
  281 A:f68f  ea                                 .byt $ea              ; 'NOP'
  282 A:f690  01                                 .byt $01              ; 'ORA'
  283 A:f691  48                                 .byt $48              ; 'PHA'
  284 A:f692  08                                 .byt $08              ; 'PHP'
  285 A:f693  68                                 .byt $68              ; 'PLA'
  286 A:f694  28                                 .byt $28              ; 'PLP'
  287 A:f695  22                                 .byt $22              ; 'ROL'
  288 A:f696  62                                 .byt $62              ; 'ROR'    - 28
  289 A:f697  40                                 .byt $40              ; 'RTI'
  290 A:f698  60                                 .byt $60              ; 'RTS'
  291 A:f699  e1                                 .byt $e1              ; 'SBC'
  292 A:f69a  38                                 .byt $38              ; 'SEC'
  293 A:f69b  f8                                 .byt $f8              ; 'SED'
  294 A:f69c  78                                 .byt $78              ; 'SEI'
  295 A:f69d  81                                 .byt $81              ; 'STA'
  296 A:f69e  82                                 .byt $82              ; 'STX'    - 30
  297 A:f69f  80                                 .byt $80              ; 'STY'
  298 A:f6a0  aa                                 .byt $aa              ; 'TAX'
  299 A:f6a1  a8                                 .byt $a8              ; 'TAY'
  300 A:f6a2  ba                                 .byt $ba              ; 'TSX'
  301 A:f6a3  8a                                 .byt $8a              ; 'TXA'
  302 A:f6a4  9a                                 .byt $9a              ; 'TXS'
  303 A:f6a5  98                                 .byt $98              ; 'TYA'    - 37
  304 A:f6a6                           code_az   
  304 A:f6a6                                    

  306 A:f6a6                                    ;
  307 A:f6a6                                    ; print code
  308 A:f6a6                                    ;
  309 A:f6a6                           p_opcode  
  309 A:f6a6  a5 44                              lda opcode
  310 A:f6a8  05 47                              ora opb
  311 A:f6aa  85 44                              sta opcode
  312 A:f6ac  60                                 rts 

  314 A:f6ad                                    ;
  315 A:f6ad                                    ; set instruction length
  316 A:f6ad                                    ; 0, 1 or 2 additional bytes
  317 A:f6ad                                    ; modifies x
  318 A:f6ad                                    ;
  319 A:f6ad                           one_byte  
  319 A:f6ad  a2 00                              ldx #$00
  320 A:f6af  f0 06                              beq setcmdlen                ;always jump
  321 A:f6b1                           two_bytes 
  321 A:f6b1  a2 01                              ldx #$01
  322 A:f6b3  d0 02                              bne setcmdlen                ;always jump
  323 A:f6b5                           three_bytes 
  323 A:f6b5  a2 02                              ldx #$02
  324 A:f6b7                           setcmdlen 
  324 A:f6b7  86 43                              stx cmdlen
  325 A:f6b9  4c b0 f7                           jmp finish_asm                ; done, ready to emit code

  327 A:f6bc                           asm_simple 
  327 A:f6bc  a5 54                              lda opmode
  328 A:f6be  c9 02                              cmp #$02             ; type 0 and 1 do not need address mode specification, use code_a directl
  329 A:f6c0  10 03                              bpl @chk_shft
  330 A:f6c2  4c ad f6                           jmp one_byte
  331 A:f6c5                           @chk_shft 
  331 A:f6c5  c9 04                              cmp #$04             ; deal with accu mode shift operations
  332 A:f6c7  d0 15                              bne loc_err
  333 A:f6c9  a9 08                              lda #$08             ; b = %010 -> aaa010cc
  334 A:f6cb  85 47                              sta opb
  335 A:f6cd  4c ad f6                           jmp one_byte

  337 A:f6d0                           asm_imm   
  337 A:f6d0  a5 54                              lda opmode
  338 A:f6d2  c9 02                              cmp #$02             ; type 2
  339 A:f6d4  f0 0b                              beq asm_imm_ct
  340 A:f6d6  c9 05                              cmp #$05             ; type 5
  341 A:f6d8  f0 07                              beq asm_imm_ct
  342 A:f6da  c9 0a                              cmp #$0a             ; type a
  343 A:f6dc  f0 03                              beq asm_imm_ct
  344 A:f6de                           loc_err   
  344 A:f6de  4c 1c f5                           jmp syntaxerr
  345 A:f6e1                           asm_imm_ct 
  345 A:f6e1  20 f3 f6                           jsr g_adr
  346 A:f6e4  a5 44                              lda opcode
  347 A:f6e6  29 03                              and #$03             ; isolate 'c' bits
  348 A:f6e8  c9 01                              cmp #$01             ; c=3 has b = %010 for imm, others b=000
  349 A:f6ea  d0 02                              bne @zerob
  350 A:f6ec  a9 08                              lda #$08             ; when c= %11 immediate is placed at b=%010
  351 A:f6ee                           @zerob    
  351 A:f6ee  85 47                              sta opb
  352 A:f6f0  4c b1 f6                           jmp two_bytes
  353 A:f6f3                                    ;
  354 A:f6f3                                    ; get the address
  355 A:f6f3                                    ; if byte size is demanded, only the lower byte is used.
  356 A:f6f3                                    ; return the character after the numbers in a
  357 A:f6f3                                    ;
  358 A:f6f3                           g_adr     
  358 A:f6f3  c8                                 iny 
  359 A:f6f4                           g_adr_l   
  359 A:f6f4  20 10 f5                           jsr eatblank                ; get rid of spaces and $
  360 A:f6f7  20 85 ff                           jsr getnum
  361 A:f6fa  88                                 dey 
  362 A:f6fb  a5 3e                              lda a2l
  363 A:f6fd  85 45                              sta adrl
  364 A:f6ff  a5 3f                              lda a2h
  365 A:f701  85 46                              sta adrh
  366 A:f703  b9 00 02                           lda in,y
  367 A:f706  60                                 rts 

  369 A:f707                                    ; So after the mnemonic, there can be three options:
  370 A:f707                                    ; - #
  371 A:f707                                    ; - (
  372 A:f707                                    ; - Address
  373 A:f707                                    ;
  374 A:f707                                    ; After the address there can only be
  375 A:f707                                    ; - ,X|Y  for indexed
  376 A:f707                                    ; - ) for indirect
  377 A:f707                                    ; - ),Y
  378 A:f707                                    ; - ,X)
  379 A:f707                                    ;
  380 A:f707                                    ; Value is $?[\dA-Z]{1,2}
  381 A:f707                                    ; Address is [$?][\dA-Z]{1,4}
  382 A:f707                           eval_arg  
  382 A:f707  a6 42                              ldx mnem                ; load x with opcode index
  383 A:f709  bd 36 f6                           lda opmodes,x              ; mode for x
  384 A:f70c  85 54                              sta opmode                ; for access without x reg
  385 A:f70e  bd 6e f6                           lda code_ac,x              ; bac opcode base for x
  386 A:f711  85 44                              sta opcode                ; for access without x reg
  387 A:f713  a9 00                              lda #$00
  388 A:f715  85 47                              sta opb                ; clear opcode b
  389 A:f717  b9 00 02                           lda in,y
  390 A:f71a  85 31                              sta mode
  391 A:f71c  20 cd f7                           jsr chk_eol                ; end of line
  392 A:f71f  f0 9b                              beq asm_simple                ; nothing there

  394 A:f721  f0 20                              beq @err                ; type 0 does not have any arguments.  Eliminate type 0 from further considerations.
  395 A:f723  b9 00 02                           lda in,y              ; back to input char
  396 A:f726  c9 23                              cmp #'#'
  397 A:f728  f0 a6                              beq asm_imm
  398 A:f72a                                    ;
  399 A:f72a                                    ;
  400 A:f72a                                    ; now parse rest of address to determine address mode and get argument
  401 A:f72a                                    ;
  402 A:f72a                                    ; following options are possible (h = hex digit):
  403 A:f72a                                    ; h{1.4}       absolute or zero             ; case 0: just 4 hex numbers   2 or 3 bytes
  404 A:f72a                                    ; h{1.4},x|y   absolute or zero indexed     ; case 1: ends with ,x|y       2 or 3 bytes
  405 A:f72a                                    ; (h{1,4})     indirect                     ; case 2: starts with (, ends with )  3 bytes
  406 A:f72a                                    ; (h{1,2}),y   post-indexed indirect        ; case 3: starts with (, ends with ),y  2 bytes
  407 A:f72a                                    ; (h{1,2},x)   pre-indexed indirect;       ; case 4: starts with (, ends with ,x)   2 bytes
  408 A:f72a  c9 28                              cmp #'('
  409 A:f72c  f0 23                              beq @indirect
  410 A:f72e                                    ;
  411 A:f72e                                    ; cases 0 and 1
  412 A:f72e                                    ;
  413 A:f72e  20 f4 f6                           jsr g_adr_l
  414 A:f731  b9 00 02                           lda in,y
  415 A:f734  20 cd f7                           jsr chk_eol
  416 A:f737  d0 03                              bne @cont
  417 A:f739  4c f8 f7                           jmp asm_direct                ; no more input -> case 0
  418 A:f73c                           @cont     
  418 A:f73c  20 10 f5                           jsr eatblank
  419 A:f73f  c9 2c                              cmp #','             ; only , x|y possible now
  420 A:f741  f0 03                              beq @reg_indexed                ; -> check reg next
  421 A:f743                           @err      
  421 A:f743  4c 1c f5                           jmp syntaxerr                ; syntax error for weverything else
  422 A:f746                           @reg_indexed 
  422 A:f746  20 0a f5                           jsr nextch
  423 A:f749  20 d4 f7                           jsr chk_xy                ; check if valid reg
  424 A:f74c  d0 f5                              bne @err                ; no, syntax error
  425 A:f74e  4c 14 f8                           jmp asm_indexed                ; yes, handle hhhh,reg (case 1)
  426 A:f751                                    ;
  427 A:f751                                    ; cases 2-4
  428 A:f751                           @indirect 
  428 A:f751  20 f3 f6                           jsr g_adr                ; address comes after the brace in any case left..
  429 A:f754  c9 2c                              cmp #','
  430 A:f756  f0 06                              beq @preindexed                ; ',' can only be (hh,x)  -> case 4
  431 A:f758  c9 29                              cmp #')'             ;
  432 A:f75a  f0 21                              beq @ind_or_pi                ; ) can be indirect or indirect post-indexed (hhhh) or (hh),y
  433 A:f75c  d0 e5                              bne @err                ; else err; we have to close the brace at least.
  434 A:f75e                                    ;
  435 A:f75e                                    ; case 4
  436 A:f75e                                    ;
  437 A:f75e                           @preindexed 
  437 A:f75e  20 0a f5                           jsr nextch
  438 A:f761  c9 58                              cmp #'X'
  439 A:f763  d0 de                              bne @err
  440 A:f765  20 0a f5                           jsr nextch
  441 A:f768  c9 29                              cmp #')'
  442 A:f76a  d0 d7                              bne @err
  443 A:f76c  20 0a f5                           jsr nextch
  444 A:f76f  20 cd f7                           jsr chk_eol
  445 A:f772  d0 cf                              bne @err
  446 A:f774                           @chk23    
  446 A:f774  a5 54                              lda opmode
  447 A:f776  c9 04                              cmp #$04             ; only works for types 2 % 3
  448 A:f778  10 c9                              bpl @err
  449 A:f77a  4c b1 f6                           jmp two_bytes                ; b = 0, no need to change opcode, opb already set for hh,Y
  450 A:f77d                                    ;
  451 A:f77d                                    ; cases 2-3
  452 A:f77d                                    ;
  453 A:f77d                           @ind_or_pi 
  453 A:f77d  20 0a f5                           jsr nextch
  454 A:f780  c9 2c                              cmp #','
  455 A:f782  f0 07                              beq @indir_reg                ; (hh), -> case 3 reg test
  456 A:f784  20 cd f7                           jsr chk_eol
  457 A:f787  f0 17                              beq asm_indirect                ; ->  case 2
  458 A:f789  d0 b8                              bne @err                ; something unexpected in the line
  459 A:f78b                           @indir_reg 
  459 A:f78b  20 0a f5                           jsr nextch
  460 A:f78e  c9 59                              cmp #'Y'
  461 A:f790  d0 b1                              bne @err
  462 A:f792                                    ;
  463 A:f792                                    ; case 3
  464 A:f792                                    ;
  465 A:f792  20 0a f5                           jsr nextch
  466 A:f795  20 cd f7                           jsr chk_eol
  467 A:f798  d0 a9                              bne @err
  468 A:f79a  a9 10                              lda #$10             ; default: abs. Or in b = %100 into aaa100cc
  469 A:f79c  85 47                              sta opb
  470 A:f79e  d0 d4                              bne @chk23                ; only do it if type 2 or 3

  472 A:f7a0                                    ; asm_indirect: this only happens with jmp
  473 A:f7a0                                    ; x must be $1B
  474 A:f7a0                           asm_indirect 
  474 A:f7a0  a5 44                              lda opcode
  475 A:f7a2  c9 4c                              cmp #$4c
  476 A:f7a4  f0 03                              beq @check
  477 A:f7a6  4c 1c f5                           jmp syntaxerr
  478 A:f7a9                           @check    
  478 A:f7a9  a9 20                              lda #$20             ;  Or in  %001.000.00 into 010.011.00
  479 A:f7ab  85 47                              sta opb
  480 A:f7ad  4c b5 f6                           jmp three_bytes
  481 A:f7b0                                    ;
  482 A:f7b0                                    ; wrap up the assembly:
  483 A:f7b0                                    ; emit code bytes to target position,
  484 A:f7b0                                    ; then borrow the system monitors list command
  485 A:f7b0                                    ; to print out the redisassenbled line.
  486 A:f7b0                                    ;
  487 A:f7b0                                    ;
  488 A:f7b0                           finish_asm 
  488 A:f7b0  20 a6 f6                           jsr p_opcode
  489 A:f7b3  a4 43                              ldy cmdlen
  490 A:f7b5                           @loop     
  490 A:f7b5  b9 44 00                           lda opcode,y
  491 A:f7b8  91 3a                              sta (pcl),y
  492 A:f7ba  88                                 dey 
  493 A:f7bb                           @short    
  493 A:f7bb  10 f8                              bpl @loop
  494 A:f7bd  a9 01                              lda #$01             ; disassemble just the one line
  495 A:f7bf  20 32 fe                           jsr list2
  496 A:f7c2  a5 3a                              lda pcl
  497 A:f7c4  85 3c                              sta a1l
  498 A:f7c6  a5 3b                              lda pch
  499 A:f7c8  85 3d                              sta a1h
  500 A:f7ca  4c 55 f5                           jmp asmz
  501 A:f7cd                                    ;
  502 A:f7cd                                    ; check for end of line - eihter ENTER (set to 0x0a) or 0
  503 A:f7cd                                    ; Z set if reached eol
  504 A:f7cd                                    ; imput: current input char in a
  505 A:f7cd                                    ;
  506 A:f7cd                           chk_eol   
  506 A:f7cd  c9 00                              cmp #$00
  507 A:f7cf  f0 02                              beq @fin
  508 A:f7d1  c9 0a                              cmp #k_entr
  509 A:f7d3                           @fin      
  509 A:f7d3  60                                 rts 

  511 A:f7d4                           chk_xy    
  511 A:f7d4  c9 58                              cmp #'X'
  512 A:f7d6  f0 02                              beq @fin
  513 A:f7d8  c9 59                              cmp #'Y'
  514 A:f7da                           @fin      
  514 A:f7da  60                                 rts 
  515 A:f7db                                    ;
  516 A:f7db                                    ; get relative address from pc
  517 A:f7db                                    ; and literal address in a1
  518 A:f7db                                    ; pc now points at rel address byte.
  519 A:f7db                                    ; address only convers -128 - +127,
  520 A:f7db                                    ; if the distance is larger it is an error
  521 A:f7db                                    ;
  522 A:f7db                           get_rel_a 
  522 A:f7db  38                                 sec                    ; set carry for following substraction
  523 A:f7dc  a5 3a                              lda pcl                ;
  524 A:f7de  69 01                              adc #$01             ; add 2 to be relative to pc+2
  525 A:f7e0  e5 3e                              sbc a2l
  526 A:f7e2  85 45                              sta adrl                ; store in low adr
  527 A:f7e4  a5 3b                              lda pch
  528 A:f7e6  e5 3f                              sbc a2h
  529 A:f7e8  30 07                              bmi @chklow
  530 A:f7ea  a5 45                              lda adrl
  531 A:f7ec  30 07                              bmi @chkerr                ; pos > $7f
  532 A:f7ee  4c b1 f6                 @chkok    jmp two_bytes             ; no opb variants for rel branches
  533 A:f7f1  a5 45                    @chklow   lda adrl
  534 A:f7f3  30 f9                              bmi @chkok                ; neg < $80
  535 A:f7f5  4c 1c f5                 @chkerr   jmp syntaxerr             ; done, rel addr in adrl
  536 A:f7f8                                    ;
  537 A:f7f8                                    ; asm_direct: absolute or zero addr
  538 A:f7f8                                    ; if adrh == 0 and operation allows zero mode,
  539 A:f7f8                                    ; use that one. else go for absolute address (16bit)
  540 A:f7f8                                    ; if op does not have that either, throw syntax error
  541 A:f7f8                           asm_direct 
  541 A:f7f8  a5 54                              lda opmode
  542 A:f7fa  c9 01                              cmp #$01             ; relative branch; special treatment -> compute rel. addr. -> type 2 finished
  543 A:f7fc  f0 dd                              beq get_rel_a
  544 A:f7fe  b9 00 02                           lda in,y
  545 A:f801  20 7e f8                           jsr chk_zero_abs                ; from here on, just examine types 3-b. use zero page where possible.
  546 A:f804  90 07                              bcc @abs_b
  547 A:f806  a9 04                              lda #$04             ; or in b = %001 into aaa001cc
  548 A:f808  85 47                              sta opb
  549 A:f80a  4c b1 f6                           jmp two_bytes
  550 A:f80d                           @abs_b    
  550 A:f80d  a9 0c                              lda #$0c             ; abs. Or in b = %011 into aaa011cc
  551 A:f80f  85 47                              sta opb
  552 A:f811  4c b5 f6                           jmp three_bytes

  554 A:f814                                    ;
  555 A:f814                                    ; asm_indexed: select one of the indexed option.
  556 A:f814                                    ; First examine if it is x or y,
  557 A:f814                                    ; the abs or zero
  558 A:f814                                    ; input: a - current in char
  559 A:f814                           asm_indexed 
  559 A:f814  c9 59                              cmp #'Y'
  560 A:f816  f0 33                              beq @idx_y
  561 A:f818  a5 54                              lda opmode
  562 A:f81a  c9 05                              cmp #$05             ; types 2-4, 0 and 1 ignored
  563 A:f81c  30 07                              bmi @has_idx_x
  564 A:f81e  c9 0a                              cmp #$0a
  565 A:f820  f0 03                              beq @has_idx_x
  566 A:f822                           @err      
  566 A:f822  4c 1c f5                           jmp syntaxerr
  567 A:f825                           @has_idx_x 
  567 A:f825  a5 46                              lda adrh                ; zero or absolute?
  568 A:f827  d0 0f                              bne @abs_x                ; weed out stx/sty
  569 A:f829                                    ;
  570 A:f829                                    ; zpg,X
  571 A:f829                                    ;
  572 A:f829  e0 1e                              cpx #$1e             ; ldx hh,x no
  573 A:f82b  f0 f5                              beq @err
  574 A:f82d  e0 30                              cpx #$30             ; stx hh,x no
  575 A:f82f  f0 f1                              beq @err
  576 A:f831  a9 14                              lda #$14             ; default: abs. Or in b = %101 into aaa101cc
  577 A:f833  85 47                              sta opb
  578 A:f835  4c b1 f6                           jmp two_bytes
  579 A:f838                                    ;
  580 A:f838                                    ; abs,X
  581 A:f838                           @abs_x    
  581 A:f838  e0 1e                              cpx #$1e             ; ldx hhhh,x no
  582 A:f83a  f0 e6                              beq @err
  583 A:f83c  e0 30                              cpx #$30             ; stx hhhh,x no
  584 A:f83e  f0 e2                              beq @err
  585 A:f840  e0 31                              cpx #$31             ; sty hhhh,x no
  586 A:f842  f0 de                              beq @err
  587 A:f844  a9 34                              lda #$34             ; default: abs. Or in b = %111 into aaa111cc
  588 A:f846  85 47                              sta opb
  589 A:f848  4c b5 f6                           jmp three_bytes
  590 A:f84b                           @idx_y    
  590 A:f84b  e0 1f                              cpx #$1f             ; ldy hhh,y no
  591 A:f84d  f0 d3                              beq @err
  592 A:f84f  e0 31                              cpx #$31             ; sty hhh,y no
  593 A:f851  f0 cf                              beq @err
  594 A:f853  a5 46                              lda adrh
  595 A:f855  d0 0d                              bne @abs_y
  596 A:f857  a5 54                              lda opmode
  597 A:f859  c9 0a                              cmp #$0a
  598 A:f85b  30 c5                              bmi @err
  599 A:f85d  a9 14                              lda #$14             ; abs. Or in b = %101 into aaa101cc
  600 A:f85f  85 47                              sta opb
  601 A:f861  4c b1 f6                           jmp two_bytes
  602 A:f864                           @abs_y    
  602 A:f864  a5 54                              lda opmode
  603 A:f866  c9 04                              cmp #$04
  604 A:f868  30 06                              bmi @abs_y_low
  605 A:f86a  c9 0a                              cmp #$0a
  606 A:f86c  f0 06                              beq @abs_y_ldx
  607 A:f86e  d0 b2                              bne @err
  608 A:f870                           @abs_y_low 
  608 A:f870  a9 18                              lda #$18             ; default: abs. Or in b = %110 into aaa110cc
  609 A:f872  d0 02                              bne @abs_y_out
  610 A:f874                           @abs_y_ldx 
  610 A:f874  a9 1c                              lda #$1c             ; default: abs. Or in b = %111 into aaa111cc
  611 A:f876                           @abs_y_out 
  611 A:f876  85 47                              sta opb
  612 A:f878  4c b5 f6                           jmp three_bytes

  614 A:f87b                           bar_ldx   
  614 A:f87b                                    

  616 A:f87b                                    ;
  617 A:f87b                                    ; (hh),reg
  618 A:f87b                                    ;
  619 A:f87b                           indir_reg 
  619 A:f87b  4c b0 f7                           jmp finish_asm
  620 A:f87e                                    ;
  621 A:f87e                                    ; check if mnemonic allows zero page address mode
  622 A:f87e                                    ; input:
  623 A:f87e                                    ;   x - opcode index
  624 A:f87e                                    ;   a - opmode for index
  625 A:f87e                                    ; return c=1 if mode available
  626 A:f87e                           chk_zero_abs 
  626 A:f87e  c9 08                              cmp #$08
  627 A:f880  f0 10                              beq @ret0
  628 A:f882  c9 09                              cmp #$09
  629 A:f884  f0 0c                              beq @ret0
  630 A:f886  a5 46                              lda adrh
  631 A:f888  f0 0a                              beq @ret1
  632 A:f88a                           @ldxy     
  632 A:f88a  e0 1e                              cpx #$1e             ; ldx and ldy with direct address only work with zero page. throw error if adr out of zero
  633 A:f88c  f0 08                              beq @err
  634 A:f88e  e0 1f                              cpx #$1f
  635 A:f890  f0 04                              beq @err
  636 A:f892                           @ret0     
  636 A:f892  18                                 clc 
  637 A:f893  60                                 rts 
  638 A:f894                           @ret1     
  638 A:f894  38                                 sec 
  639 A:f895  60                                 rts 
  640 A:f896                           @err      
  640 A:f896  4c 1c f5                           jmp syntaxerr

rom.s


   63 A:f899                                    ;
   64 A:f899                                    ; print zero terminated string
   65 A:f899                                    ; max 255 chars.
   66 A:f899                                    ; input:
   67 A:f899                                    ;   string address in a5l/h
   68 A:f899                           print     
   68 A:f899  a0 00                              ldy #$00
   69 A:f89b                           @loop     
   69 A:f89b  b1 44                              lda (a5l),y
   70 A:f89d  f0 06                              beq @fin
   71 A:f89f  20 c2 fd                           jsr cout
   72 A:f8a2  c8                                 iny 
   73 A:f8a3  d0 f6                              bne @loop
   74 A:f8a5                           @fin      
   74 A:f8a5  60                                 rts 
   75 A:f8a6                                    ;
   76 A:f8a6                                    ; Emulator exit
   77 A:f8a6                                    ; terminate by setting PC to $FFFF, which should not happen in normal operation.
   78 A:f8a6                                    ;
   79 A:f8a6                           exit      
   79 A:f8a6  4c ff ff                           jmp $ffff
   80 A:f8a9                                    ;
   81 A:f8a9                                    ; getline vector.
   82 A:f8a9                                    ;
   83 A:f8a9                           getlnv    
   83 A:f8a9  6c 28 00                           jmp (rdline)
   84 A:f8ac                           stdin     
   84 A:f8ac  ad 18 c0                           lda termin
   85 A:f8af  60                                 rts 
   86 A:f8b0                                    ;
   87 A:f8b0                                    ; readline from stdio
   88 A:f8b0                                    ; this will block until line is read
   89 A:f8b0                                    ; this way it uses standard readline
   90 A:f8b0                                    ; funcionality hostside.
   91 A:f8b0                                    ;
   92 A:f8b0                           stdrdln   
   92 A:f8b0  98                                 tya 
   93 A:f8b1  48                                 pha 
   94 A:f8b2  a5 33                              lda prompt                ; set prompt
   95 A:f8b4  8d 1a c0                           sta termp
   96 A:f8b7  a0 ff                              ldy #$ff
   97 A:f8b9                           loop      
   97 A:f8b9  c8                                 iny 
   98 A:f8ba  ad 19 c0                           lda terml
   99 A:f8bd  99 00 02                           sta in,y
  100 A:f8c0  d0 f7                              bne loop
  101 A:f8c2  a9 0a                              lda #k_entr
  102 A:f8c4  99 00 02                           sta in,y
  103 A:f8c7  68                                 pla 
  104 A:f8c8  a8                                 tay 
  105 A:f8c9  60                                 rts 
  106 A:f8ca                           stdout    
  106 A:f8ca  8d 12 c0                           sta termout
  107 A:f8cd  60                                 rts 
  108 A:f8ce                           nxtcol    
  108 A:f8ce  a5 30                              lda color                ; increment color by 3
  109 A:f8d0  18                                 clc 
  110 A:f8d1  69 03                              adc #$03
  111 A:f8d3                           setcol    
  111 A:f8d3  29 0f                              and #$0f             ; sets color = 17*A mod 16
  112 A:f8d5  85 30                              sta color
  113 A:f8d7  0a                                 asl 
  114 A:f8d8  0a                                 asl 
  115 A:f8d9  0a                                 asl 
  116 A:f8da  0a                                 asl                    ; << 4 = *16
  117 A:f8db  05 30                              ora color                ; + 1
  118 A:f8dd  85 30                              sta color
  119 A:f8df  60                                 rts 
  120 A:f8e0                           selnibl   
  120 A:f8e0  90 04                              bcc rtmaskz                ; if even, use low nibble else use high nibble (was scrn2)
  121 A:f8e2  4a                                 lsr 
  122 A:f8e3  4a                                 lsr 
  123 A:f8e4  4a                                 lsr                    ; shift high nibble into low nibble
  124 A:f8e5  4a                                 lsr 
  125 A:f8e6                           rtmaskz   
  125 A:f8e6  29 0f                              and #$0f             ; mask lower 4 bits
  126 A:f8e8  60                                 rts 
  127 A:f8e9                           insds1    
  127 A:f8e9  a6 3a                              ldx pcl                ; print pcl,h
  128 A:f8eb  a4 3b                              ldy pch
  129 A:f8ed  20 6b fd                           jsr pryx2
  130 A:f8f0  20 af f9                           jsr prblnk                ; followed by a blank
  131 A:f8f3  a1 3a                              lda (pcl,x)
  132 A:f8f5                           insds2    
  132 A:f8f5  a8                                 tay 
  133 A:f8f6  4a                                 lsr                    ; even / odd test
  134 A:f8f7  90 09                              bcc ieven
  135 A:f8f9  6a                                 ror                    ; bit 1 test
  136 A:f8fa  b0 10                              bcs err                ; xxxxxx11 invalid opcode
  137 A:f8fc  c9 a2                              cmp #$a2
  138 A:f8fe  f0 0c                              beq err                ; opcode 89 invalid
  139 A:f900  29 87                              and #$87             ; mask bits
  140 A:f902                           ieven     
  140 A:f902  4a                                 lsr                    ; lsb into carry for l/r test
  141 A:f903  aa                                 tax 
  142 A:f904  bd c9 f9                           lda fmt1,x              ; get format index byte
  143 A:f907  20 e0 f8                           jsr selnibl                ; r/l h-byte on carry
  144 A:f90a  d0 04                              bne getfmt
  145 A:f90c                           err       
  145 A:f90c  a0 80                              ldy #$80             ; substitute $80 for invalid ops
  146 A:f90e  a9 00                              lda #$00             ; set print format index to 0
  147 A:f910                           getfmt    
  147 A:f910  aa                                 tax 
  148 A:f911  bd 0d fa                           lda fmt2,x              ; index into print format table
  149 A:f914  85 2e                              sta format                ; save for addr field formatting
  150 A:f916  29 03                              and #$03             ; mask for 2-bit length
  151 A:f918                                    ; (P=1 byte, 1=2 byte, 2=3 byte)
  152 A:f918  85 2f                              sta length
  153 A:f91a  98                                 tya                    ; opcode
  154 A:f91b  29 8f                              and #$8f             ; mask for 1xxx1010 test
  155 A:f91d  aa                                 tax                    ;  save it
  156 A:f91e  98                                 tya                    ; opcode to a again
  157 A:f91f  a0 03                              ldy #$03
  158 A:f921  e0 8a                              cpx #$8a
  159 A:f923  f0 0b                              beq mnndx3
  160 A:f925                           mnndx1    
  160 A:f925  4a                                 lsr 
  161 A:f926  90 08                              bcc mnndx3                ; form index into mnemonic tble
  162 A:f928  4a                                 lsr 
  163 A:f929                           mnndx2    
  163 A:f929  4a                                 lsr                    ; 1)  1xxx1010 => 00101xxx
  164 A:f92a  09 20                              ora #$20             ; 2)  xxxyyy01 => 00111xxx
  165 A:f92c  88                                 dey                    ; 3)  xxxyyy10 => 00110xxx
  166 A:f92d  d0 fa                              bne mnndx2                ; 4)  xxxyy100 => 00100xxx
  167 A:f92f  c8                                 iny                    ; 5)  xxxxx000 => 000xxxxx
  168 A:f930                           mnndx3    
  168 A:f930  88                                 dey 
  169 A:f931  d0 f2                              bne mnndx1
  170 A:f933  60                                 rts 
  171 A:f934  ff ff ff                           .byt $ff,$ff,$ff  ; ???
  172 A:f937                           instdsp   
  172 A:f937  20 e9 f8                           jsr insds1                ; gen fmt, len bytes
  173 A:f93a  48                                 pha                    ; save mnemonic table index
  174 A:f93b                           prntop    
  174 A:f93b  b1 3a                              lda (pcl),y
  175 A:f93d  20 af fd                           jsr prbyte
  176 A:f940  a2 01                              ldx #$01             ; print 2 blanks
  177 A:f942                           prntbl    
  177 A:f942  20 b1 f9                           jsr prbl2
  178 A:f945  c4 2f                              cpy length                ; print inst (1-3 bytes)
  179 A:f947  c8                                 iny                    ; in a 12 char field
  180 A:f948  90 f1                              bcc prntop
  181 A:f94a  a2 03                              ldx #$03             ; char count for mnemonic print
  182 A:f94c  c0 04                              cpy #$04
  183 A:f94e  90 f2                              bcc prntbl
  184 A:f950  68                                 pla                    ; recover mnemonic index
  185 A:f951  a8                                 tay 
  186 A:f952  b9 27 fa                           lda mneml,y
  187 A:f955  85 2c                              sta lmnem                ; fetch 3 char mnemonic
  188 A:f957  b9 67 fa                           lda mnemr,y              ;   (packed in 2 bytes, only chars A-Z
  189 A:f95a  85 2d                              sta rmnem
  190 A:f95c                           prmn1     
  190 A:f95c  a9 00                              lda #$00
  191 A:f95e  a0 05                              ldy #$05
  192 A:f960                           prnm2     
  192 A:f960  06 2d                              asl rmnem                ; shift 5 bits of
  193 A:f962  26 2c                              rol lmnem                ;   character into Accu
  194 A:f964  2a                                 rol                    ;      (clears carry)
  195 A:f965  88                                 dey 
  196 A:f966  d0 f8                              bne prnm2
  197 A:f968  69 3f                              adc #'?'             ; add "?" offset
  198 A:f96a  20 c2 fd                           jsr cout                ; output a char of mnem
  199 A:f96d  ca                                 dex 
  200 A:f96e  d0 ec                              bne prmn1
  201 A:f970  20 af f9                           jsr prblnk                ; output 3 blanks
  202 A:f973  a4 2f                              ldy length
  203 A:f975  a2 06                              ldx #$06             ; count for 6 format bits
  204 A:f977                           pradr1    
  204 A:f977  e0 03                              cpx #$03
  205 A:f979  f0 1c                              beq pradr5                ; if x=3 then addr
  206 A:f97b                           pradr2    
  206 A:f97b  06 2e                              asl format
  207 A:f97d  90 0e                              bcc pradr3
  208 A:f97f  bd 1a fa                           lda char1-1,x
  209 A:f982  20 c2 fd                           jsr cout
  210 A:f985  bd 20 fa                           lda char2-1,x
  211 A:f988  f0 03                              beq pradr3
  212 A:f98a  20 c2 fd                           jsr cout
  213 A:f98d                           pradr3    
  213 A:f98d  ca                                 dex 
  214 A:f98e  d0 e7                              bne pradr1
  215 A:f990  60                                 rts 
  216 A:f991                           pradr4    
  216 A:f991  88                                 dey 
  217 A:f992  30 e7                              bmi pradr2
  218 A:f994  20 af fd                           jsr prbyte
  219 A:f997                           pradr5    
  219 A:f997  a5 2e                              lda format
  220 A:f999  c9 e8                              cmp #$e8             ; handle relative address mode
  221 A:f99b  b1 3a                              lda (pcl),y            ;  special (print target, not offset)
  222 A:f99d  90 f2                              bcc pradr4
  223 A:f99f                           reladr    
  223 A:f99f  20 bd f9                           jsr pcadj3
  224 A:f9a2  aa                                 tax                    ; pcl,pch+offset+1 to a,y
  225 A:f9a3  e8                                 inx 
  226 A:f9a4  d0 01                              bne prntyx                ; +1 to y,x
  227 A:f9a6  c8                                 iny 
  228 A:f9a7                                    ;
  229 A:f9a7                                    ; print y and x  as 4 digit hex number
  230 A:f9a7                                    ;
  231 A:f9a7                           prntyx    
  231 A:f9a7  98                                 tya 
  232 A:f9a8                           prntax    
  232 A:f9a8  20 af fd                           jsr prbyte                ; output target adr
  233 A:f9ab                           prntx     
  233 A:f9ab  8a                                 txa                    ;    of branch and return
  234 A:f9ac  4c af fd                           jmp prbyte
  235 A:f9af                           prblnk    
  235 A:f9af  a2 03                              ldx #$03             ; blank count
  236 A:f9b1                           prbl2     
  236 A:f9b1  a9 20                              lda #' '             ; load a space
  237 A:f9b3                           prbl3     
  237 A:f9b3  20 c2 fd                           jsr cout                ; output a blank
  238 A:f9b6  ca                                 dex 
  239 A:f9b7  d0 f8                              bne prbl2
  240 A:f9b9  60                                 rts 
  241 A:f9ba                           pcadj     
  241 A:f9ba  38                                 sec                    ; 0=1-byte, 1=2-byte,
  242 A:f9bb                           pcadj2    
  242 A:f9bb  a5 2f                              lda length                ;   2=3-byte
  243 A:f9bd                           pcadj3    
  243 A:f9bd  a4 3b                              ldy pch
  244 A:f9bf  aa                                 tax                    ; test displacement sign
  245 A:f9c0  10 01                              bpl pcadj4                ;   (for rel branch)
  246 A:f9c2  88                                 dey 
  247 A:f9c3                           pcadj4    
  247 A:f9c3  65 3a                              adc pcl
  248 A:f9c5  90 01                              bcc rts2                ; pcl+LENGTH(or Displc.)+1 to A
  249 A:f9c7  c8                                 iny                    ;   carry inot y (pch)
  250 A:f9c8                           rts2      
  250 A:f9c8  60                                 rts 
  251 A:f9c9                                    ;
  252 A:f9c9                                    ; fmt1 bytes:   XXXXXXY0 instructions
  253 A:f9c9                                    ;       if Y=0: then left half byte
  254 A:f9c9                                    ;       if Y=1  then right half byte
  255 A:f9c9                                    ;                    (X=index)
  256 A:f9c9                           fmt1      
  256 A:f9c9  04 20 54 30 0d                     .byt $04,$20,$54,$30,$0d
  257 A:f9ce  80 04 90 03 22                     .byt $80,$04,$90,$03,$22
  258 A:f9d3  54 33 0d 80 04                     .byt $54,$33,$0d,$80,$04
  259 A:f9d8  90 04 20 54 33                     .byt $90,$04,$20,$54,$33
  260 A:f9dd  0d 80 04 90 04                     .byt $0d,$80,$04,$90,$04
  261 A:f9e2  20 54 3b 0d 80                     .byt $20,$54,$3b,$0d,$80
  262 A:f9e7  04 90 00 22 44                     .byt $04,$90,$00,$22,$44
  263 A:f9ec  33 0d c8 44 00                     .byt $33,$0d,$c8,$44,$00
  264 A:f9f1  11 22 44 33 0d                     .byt $11,$22,$44,$33,$0d
  265 A:f9f6  c8 44 a9 01 22                     .byt $c8,$44,$a9,$01,$22
  266 A:f9fb  44 33 0d 80 04                     .byt $44,$33,$0d,$80,$04
  267 A:fa00  90 01 22 44 33                     .byt $90,$01,$22,$44,$33
  268 A:fa05  0d 80 04 90                        .byt $0d,$80,$04,$90
  269 A:fa09  26 31 87 9a                        .byt $26,$31,$87,$9a; ZZXXXXY01 instructions
  270 A:fa0d                           fmt2      
  270 A:fa0d  00                                 .byt $00              ; ERR
  271 A:fa0e  21                                 .byt $21              ; IMM
  272 A:fa0f  81                                 .byt $81              ; Z-PAGE
  273 A:fa10  82                                 .byt $82              ; ABS
  274 A:fa11  00                                 .byt $00              ; IMPLIED
  275 A:fa12  00                                 .byt $00              ; ACCUMULATOR
  276 A:fa13  59                                 .byt $59              ; (ZPAG,X)
  277 A:fa14  4d                                 .byt $4d              ; (ZPAG),Y
  278 A:fa15  91                                 .byt $91              ; ZPAG,X
  279 A:fa16  92                                 .byt $92              ; ABS,X
  280 A:fa17  86                                 .byt $86              ; ABS,Y
  281 A:fa18  4a                                 .byt $4a              ; (ABS)
  282 A:fa19  85                                 .byt $85              ; ZPAG,Y
  283 A:fa1a  9d                                 .byt $9d              ; RELATIVE
  284 A:fa1b                           char1     
  284 A:fa1b  2c 29 2c 23 28 24                  .byt ',',')',',','#','(','$'
  285 A:fa21                           char2     
  285 A:fa21  59 00 58 24 24 00                  .byt 'Y',0,"X$$",0
  286 A:fa27                                    ;
  287 A:fa27                                    ; mneml is of form:
  288 A:fa27                                    ; (A) XXXXX000
  289 A:fa27                                    ; (B) XXXYY100
  290 A:fa27                                    ; (C) 1XXX1010
  291 A:fa27                                    ; (D) XXXYYY10
  292 A:fa27                                    ; (E) XXXYYY01
  293 A:fa27                                    ;     (X=index)
  294 A:fa27                           mneml     
  294 A:fa27  1c 8a 1c 23 5d 8b                  .byt $1c,$8a,$1c,$23,$5d,$8b
  295 A:fa2d  1b a1 9d 8a 1d 23                  .byt $1b,$a1,$9d,$8a,$1d,$23
  296 A:fa33  9d 8b 1d a1 00 29                  .byt $9d,$8b,$1d,$a1,$00,$29
  297 A:fa39  19 ae 69 a8 19 23                  .byt $19,$ae,$69,$a8,$19,$23
  298 A:fa3f  24 53 1b 23 24 53                  .byt $24,$53,$1b,$23,$24,$53
  299 A:fa45  19 a1                              .byt $19,$a1        ; (A) Format Above
  300 A:fa47  00 1a 5b 5b a5 69                  .byt $00,$1a,$5b,$5b,$a5,$69
  301 A:fa4d  24 24                              .byt $24,$24        ; (B) Format
  302 A:fa4f  ae ae a8 ad 29 00                  .byt $ae,$ae,$a8,$ad,$29,$00
  303 A:fa55  7c 00                              .byt $7c,$00        ; (C) Format
  304 A:fa57  15 9c 6d 9c a5 69                  .byt $15,$9c,$6d,$9c,$a5,$69
  305 A:fa5d  29 53                              .byt $29,$53        ; (D) Format
  306 A:fa5f  84 13 34 11 a5 69                  .byt $84,$13,$34,$11,$a5,$69
  307 A:fa65  23 a0                              .byt $23,$a0        ; (E) Format
  308 A:fa67                           mnemr     
  308 A:fa67  d8 62 5a 48 26 62                  .byt $d8,$62,$5a,$48,$26,$62
  309 A:fa6d  94 88 54 44 c8 54                  .byt $94,$88,$54,$44,$c8,$54
  310 A:fa73  68 44 e8 94 00 b4                  .byt $68,$44,$e8,$94,$00,$b4
  311 A:fa79  08 84 74 b4 28 6e                  .byt $08,$84,$74,$b4,$28,$6e
  312 A:fa7f  74 f4 cc 4a 72 f2                  .byt $74,$f4,$cc,$4a,$72,$f2
  313 A:fa85  a4 8a                              .byt $a4,$8a        ; (A) Format
  314 A:fa87  00 aa a2 a2 74 74                  .byt $00,$aa,$a2,$a2,$74,$74
  315 A:fa8d  74 72                              .byt $74,$72        ; (B) Format
  316 A:fa8f  44 68 b2 32 b2 00                  .byt $44,$68,$b2,$32,$b2,$00
  317 A:fa95  22 00                              .byt $22,$00        ; (C) Format
  318 A:fa97  1a 1a 26 26 72 72                  .byt $1a,$1a,$26,$26,$72,$72
  319 A:fa9d  88 c8                              .byt $88,$c8        ; (D) Format
  320 A:fa9f  c4 ca 26 48 44 44                  .byt $c4,$ca,$26,$48,$44,$44
  321 A:faa5  a2 c8                              .byt $a2,$c8        ; (E) Format
  322 A:faa7  ff ff ff                           .byt $ff,$ff,$ff
  323 A:faaa                                    ;
  324 A:faaa                                    ; monitor stepping
  325 A:faaa                                    ; this is nice... it emulates itself to execute a program stepwise
  326 A:faaa                                    ;
  327 A:faaa                           step      
  327 A:faaa  20 37 f9                           jsr instdsp                ; disassemble one instruction
  328 A:faad  68                                 pla                    ;   at (pcl,h)
  329 A:faae  85 2c                              sta rtnl                ; adjust to user
  330 A:fab0  68                                 pla                    ;   stack, save
  331 A:fab1  85 2d                              sta rtnh                ;   return address
  332 A:fab3  a2 08                              ldx #$08
  333 A:fab5                           xqinit    
  333 A:fab5  bd 77 fb                           lda initbl-1,x        ; init xeq (execute) area
  334 A:fab8  95 3c                              sta xqt,x
  335 A:faba  ca                                 dex 
  336 A:fabb  d0 f8                              bne xqinit
  337 A:fabd  a1 3a                              lda (pcl,x)            ; user opcode byte
  338 A:fabf  f0 42                              beq xbrk                ; special if BRK
  339 A:fac1  a4 2f                              ldy length                ; LEN from disassembly
  340 A:fac3  c9 20                              cmp #$20
  341 A:fac5  f0 59                              beq xjsr                ; handle jsr, rts, jmp,
  342 A:fac7  c9 60                              cmp #$60             ;   jmp (), rti special
  343 A:fac9  f0 45                              beq xrts
  344 A:facb  c9 4c                              cmp #$4c
  345 A:facd  f0 5c                              beq xjmp
  346 A:facf  c9 6c                              cmp #$6c
  347 A:fad1  f0 59                              beq xjmpat
  348 A:fad3  c9 40                              cmp #$40
  349 A:fad5  f0 35                              beq xrti
  350 A:fad7  29 1f                              and #$1f             ; TODO comment
  351 A:fad9  49 14                              eor #$14
  352 A:fadb  c9 04                              cmp #$04             ; copy user instruction to xeq area
  353 A:fadd  f0 02                              beq xq2                ;   with trailing nops
  354 A:fadf                           xq1       
  354 A:fadf  b1 3a                              lda (pcl),y            ; change rel branch
  355 A:fae1                           xq2       
  355 A:fae1  99 3c 00                           sta xqtnz,y              ;   disp to 4 for
  356 A:fae4  88                                 dey                    ;   jmp to branch or
  357 A:fae5  10 f8                              bpl xq1                ;   nbranch from xeq
  358 A:fae7  20 1a ff                           jsr restore                ; restore user reg contents
  359 A:faea  4c 3c 00                           jmp xqtnz                ; xeq (execute) user op from RAM
  360 A:faed                           irqvec    
  360 A:faed  85 45                              sta acc                ;    (return to nbranch)
  361 A:faef  68                                 pla                    ; fetch p status register into a
  362 A:faf0  48                                 pha                    ; * * IRQ handler
  363 A:faf1  0a                                 asl 
  364 A:faf2  0a                                 asl 
  365 A:faf3  0a                                 asl                    ; put B flag in high bit
  366 A:faf4  30 03                              bmi break                ; if set, handle BRK
  367 A:faf6  6c fe 03                           jmp (irqloc)              ; user routine vector in RAM
  368 A:faf9                           break     
  368 A:faf9  28                                 plp 
  369 A:fafa  20 27 ff                           jsr sav1                ; save regs on break
  370 A:fafd  68                                 pla                    ; including pc
  371 A:fafe  85 3a                              sta pcl
  372 A:fb00  68                                 pla 
  373 A:fb01  85 3b                              sta pch
  374 A:fb03                           xbrk      
  374 A:fb03  20 e9 f8                           jsr insds1                ; print user pc
  375 A:fb06  20 41 fb                           jsr rgdsp1                ;   and registers
  376 A:fb09  4c 43 ff                           jmp mon                ; go to monitor
  377 A:fb0c                           xrti      
  377 A:fb0c  18                                 clc 
  378 A:fb0d  68                                 pla                    ; simulate rti by expecting
  379 A:fb0e  85 48                              sta status                ;    status from stack, then rts
  380 A:fb10                           xrts      
  380 A:fb10  68                                 pla                    ; rts simulation
  381 A:fb11  85 3a                              sta pcl                ;   extract pc from stack
  382 A:fb13  68                                 pla                    ; and update pc by 1 (LEN=0)
  383 A:fb14                           pcinc2    
  383 A:fb14  85 3b                              sta pch
  384 A:fb16                           pcinc3    
  384 A:fb16  a5 2f                              lda length                ; update pc by LEN
  385 A:fb18  20 bd f9                           jsr pcadj3
  386 A:fb1b  84 3b                              sty pch
  387 A:fb1d  18                                 clc                    ; short unconditional jump
  388 A:fb1e  90 14                              bcc newpcl                ;  CLC BCC #rel
  389 A:fb20                           xjsr      
  389 A:fb20  18                                 clc 
  390 A:fb21  20 bb f9                           jsr pcadj2                ; update pc and push
  391 A:fb24  aa                                 tax                    ;   onto stack for
  392 A:fb25  98                                 tya                    ;   JSR simulate
  393 A:fb26  48                                 pha 
  394 A:fb27  8a                                 txa 
  395 A:fb28  48                                 pha 
  396 A:fb29  a0 02                              ldy #$02
  397 A:fb2b                           xjmp      
  397 A:fb2b  18                                 clc 
  398 A:fb2c                           xjmpat    
  398 A:fb2c  b1 3a                              lda (pcl),Y
  399 A:fb2e  aa                                 tax                    ; load pc for jump,
  400 A:fb2f  88                                 dey                    ;   (JMP) simulate
  401 A:fb30  b1 3a                              lda (pcl),y
  402 A:fb32  86 3b                              stx pch
  403 A:fb34                           newpcl    
  403 A:fb34  85 3a                              sta pcl
  404 A:fb36  b0 f3                              bcs xjmp
  405 A:fb38                           rtnjmp    
  405 A:fb38  a5 2d                              lda rtnh
  406 A:fb3a  48                                 pha 
  407 A:fb3b  a5 2c                              lda rtnl
  408 A:fb3d  48                                 pha 
  409 A:fb3e                           regdsp    
  409 A:fb3e  20 63 fd                           jsr crout                ; display user reg
  410 A:fb41                           rgdsp1    
  410 A:fb41  a9 45                              lda #<acc              ;  contents with
  411 A:fb43  85 40                              sta a3l                ;  labels
  412 A:fb45  a9 00                              lda #>acc
  413 A:fb47  85 41                              sta a3h
  414 A:fb49  a2 fb                              ldx #$fb
  415 A:fb4b                           rdsp1     
  415 A:fb4b  a9 20                              lda #' '
  416 A:fb4d  20 c2 fd                           jsr cout                ; output space
  417 A:fb50  bd 85 fa                           lda rtbl-$fb,x        ; register name (x has FB so base address = rtbl - FB)
  418 A:fb53  20 c2 fd                           jsr cout
  419 A:fb56  a9 3d                              lda #'='             ; '='
  420 A:fb58  20 c2 fd                           jsr cout
  421 A:fb5b  b5 4a                              lda acc+5,x
  422 A:fb5d  20 af fd                           jsr prbyte
  423 A:fb60  e8                                 inx 
  424 A:fb61  30 e8                              bmi rdsp1
  425 A:fb63  60                                 rts 
  426 A:fb64                           branch    
  426 A:fb64  18                                 clc                    ; branch taken,
  427 A:fb65  a0 01                              ldy #$01             ;  add LEN+2 to pc
  428 A:fb67  b1 3a                              lda (pcl),y
  429 A:fb69  20 bd f9                           jsr pcadj3
  430 A:fb6c  85 3a                              sta pcl
  431 A:fb6e  98                                 tya 
  432 A:fb6f  38                                 sec 
  433 A:fb70  b0 a2                              bcs pcinc2
  434 A:fb72                           nbranch   
  434 A:fb72  20 25 ff                           jsr save                ; normal return after
  435 A:fb75  38                                 sec                    ;   xeq user of
  436 A:fb76  b0 9e                              bcs pcinc3                ; go update pc
  437 A:fb78                           initbl    
  437 A:fb78  ea                                 nop 
  438 A:fb79  ea                                 nop                    ; dummy fill for
  439 A:fb7a  4c 72 fb                           jmp nbranch                ;   xeq area
  440 A:fb7d  4c 64 fb                           jmp branch
  441 A:fb80                           rtbl      
  441 A:fb80  41                                 .byt 'A'
  442 A:fb81  58                                 .byt 'X'
  443 A:fb82  59                                 .byt 'Y'
  444 A:fb83  50                                 .byt 'P'
  445 A:fb84  53                                 .byt 'S'
  446 A:fb85                           pread     
  446 A:fb85  ad 70 c0                           lda ptrig                ; paddle read; trigger paddles
  447 A:fb88  a0 00                              ldy #$00             ; init count
  448 A:fb8a  ea                                 nop                    ; compensate timing for first count
  449 A:fb8b  ea                                 nop                    ; 2 x 2 cycles
  450 A:fb8c                           pread2    
  450 A:fb8c  bd 61 c0                           lda paddl0,x              ; count y-reg
  451 A:fb8f  10 04                              bpl rts2d                ;    every 12 usec
  452 A:fb91  c8                                 iny 
  453 A:fb92  d0 f8                              bne pread2                ;    exit at 255 max
  454 A:fb94  88                                 dey 
  455 A:fb95                           rts2d     
  455 A:fb95  60                                 rts 
  456 A:fb96                           init      
  456 A:fb96  a9 00                              lda #$00             ; clr status for debug
  457 A:fb98  85 48                              sta status                ;   software
  458 A:fb9a                           settxt    
  458 A:fb9a  a9 00                              lda #$00             ;   full screen window
  459 A:fb9c                           setwnd    
  459 A:fb9c  85 22                              sta wndtop                ; set for 40 col window
  460 A:fb9e  a9 00                              lda #$00             ;    top in accu,
  461 A:fba0  85 20                              sta wndlft                ;    bottom at line 24
  462 A:fba2  ad 17 c0                           lda termww                ; get terminal window width
  463 A:fba5  85 21                              sta wndwdth
  464 A:fba7  ad 16 c0                           lda termwh                ; get terminal window height
  465 A:fbaa  85 23                              sta wndbtm
  466 A:fbac  38                                 sec 
  467 A:fbad  e9 01                              sbc #$01             ; last possible row in window
  468 A:fbaf                           tabv      
  468 A:fbaf  85 25                              sta cv                ; vtabs to row in accu
  469 A:fbb1  60                                 rts 
  470 A:fbb2                           mulpm     
  470 A:fbb2  20 f6 fb                           jsr md1                ; abs value of ac, aux
  471 A:fbb5                           mul       
  471 A:fbb5  a0 10                              ldy #$10             ; index for 16 bits
  472 A:fbb7                           mul2      
  472 A:fbb7  a5 50                              lda acl                ; acx * aux + xtnd
  473 A:fbb9  4a                                 lsr                    ;  to ac, xtnd
  474 A:fbba  90 0c                              bcc mul4                ; if no carry,
  475 A:fbbc  18                                 clc                    ;   no partial product
  476 A:fbbd  a2 fe                              ldx #$fe
  477 A:fbbf                           mul3      
  477 A:fbbf  b5 54                              lda xtndl+2,x        ; add multiplicant (aux)
  478 A:fbc1  75 56                              adc auxl+2,x        ;   to partial product
  479 A:fbc3  95 54                              sta xtndl+2,x        ;     (xtnd)
  480 A:fbc5  e8                                 inx 
  481 A:fbc6  d0 f7                              bne mul3
  482 A:fbc8                           mul4      
  482 A:fbc8  a2 03                              ldx #$03
  483 A:fbca                           mul5      
  483 A:fbca  76 50                              ror acl,x              ; orig DFB #$76, #$50 ?!? maybe a bug in their assembler software
  484 A:fbcc  ca                                 dex 
  485 A:fbcd  10 fb                              bpl mul5
  486 A:fbcf  88                                 dey 
  487 A:fbd0  d0 e5                              bne mul2
  488 A:fbd2  60                                 rts 
  489 A:fbd3                           divpm     
  489 A:fbd3  20 f6 fb                           jsr md1                ; abs value of ac, aux
  490 A:fbd6                           div       
  490 A:fbd6  a0 10                              ldy #$10             ; index for 16 bits
  491 A:fbd8                           div2      
  491 A:fbd8  06 51                              asl ach
  492 A:fbda  26 51                              rol ach
  493 A:fbdc  26 52                              rol xtndl                ; xtnd/aux
  494 A:fbde  26 53                              rol xtndh                ;   to ac.
  495 A:fbe0  38                                 sec 
  496 A:fbe1  a5 52                              lda xtndl
  497 A:fbe3  e5 54                              sbc auxl                ; mod to xtnd
  498 A:fbe5  aa                                 tax 
  499 A:fbe6  a5 53                              lda xtndh
  500 A:fbe8  e5 55                              sbc auxh
  501 A:fbea  90 06                              bcc div3
  502 A:fbec  86 52                              stx xtndl
  503 A:fbee  85 53                              sta xtndh
  504 A:fbf0  e6 50                              inc acl
  505 A:fbf2                           div3      
  505 A:fbf2  88                                 dey 
  506 A:fbf3  d0 e3                              bne div2
  507 A:fbf5  60                                 rts 
  508 A:fbf6                           md1       
  508 A:fbf6  a0 00                              ldy #$00             ; abs value of ac, aux
  509 A:fbf8  84 2f                              sty sign                ;   with result sign
  510 A:fbfa  a2 54                              ldx #auxl               ;   in lsb of sign
  511 A:fbfc  20 01 fc                           jsr md2
  512 A:fbff  a2 50                              ldx #acl
  513 A:fc01                           md2       
  513 A:fc01  b5 01                              lda loc1,x              ; x specifies ac or aux
  514 A:fc03  10 0d                              bpl mdrts
  515 A:fc05  38                                 sec 
  516 A:fc06                           md3       
  516 A:fc06  98                                 tya 
  517 A:fc07  f5 00                              sbc loc0,x              ; compl specified reg
  518 A:fc09  95 00                              sta loc0,x              ;   if negative
  519 A:fc0b  98                                 tya 
  520 A:fc0c  f5 01                              sbc loc1,x
  521 A:fc0e  95 01                              sta loc1,x
  522 A:fc10  e6 2f                              inc sign
  523 A:fc12                           mdrts     
  523 A:fc12  60                                 rts 

  525 A:fc13                           bell1     
  525 A:fc13  a9 07                              lda #k_ctl_g               ; output bell and return
  526 A:fc15  8d 12 c0                           sta termout                ; pit to term directly here...
  527 A:fc18  60                                 rts 
  528 A:fc19  ea ff 10 00 00 24 2c ...           .dsb $10,$ea
  529 A:fc29                           rts2b     
  529 A:fc29  60                                 rts 
  530 A:fc2a                                    ;
  531 A:fc2a                                    ; Store terminal char output and advance screen cursor
  532 A:fc2a                                    ;
  533 A:fc2a                           stoadv    
  533 A:fc2a  a4 25                              ldy cv                ; cursor y index to y register
  534 A:fc2c  8c 10 c0                           sty termcy                ; set terminal cursor y
  535 A:fc2f  a4 24                              ldy ch                ; cursor h index to y register
  536 A:fc31  8c 11 c0                           sty termcx                ; set terminal cursor x
  537 A:fc34  a4 32                              ldy invflg                ;
  538 A:fc36  8c 13 c0                           sty termesc                ; invflg has the command byte for the char attribute normal or reverse
  539 A:fc39  8d 12 c0                           sta termout                ; output char
  540 A:fc3c                                    ;
  541 A:fc3c                                    ; advance cursor
  542 A:fc3c                                    ;
  543 A:fc3c                                    ; add next line routine if cursor proceeds to right margin
  544 A:fc3c                                    ;
  545 A:fc3c                           advance   
  545 A:fc3c  e6 24                              inc ch                ; increment cursor h index
  546 A:fc3e  a5 24                              lda ch                ;   (move right)
  547 A:fc40  c5 21                              cmp wndwdth                ; beyond window width?
  548 A:fc42  b0 4e                              bcs cr                ;   yes, cr to next line
  549 A:fc44                           rts3      
  549 A:fc44  60                                 rts                    ; no, return
  550 A:fc45                                    ;
  551 A:fc45                                    ; Video out
  552 A:fc45                                    ;
  553 A:fc45                                    ; Write character to terminal I/O
  554 A:fc45                                    ;
  555 A:fc45                           vidout    
  555 A:fc45  c9 20                              cmp #' '             ; control char?
  556 A:fc47  b0 e1                              bcs stoadv                ;   no, output it
  557 A:fc49  c9 0a                              cmp #k_entr               ; CR?  0x1D | 0x80
  558 A:fc4b  f0 45                              beq cr                ;   yes
  559 A:fc4d  c9 0a                              cmp #k_lf               ; LF?
  560 A:fc4f  f0 45                              beq lf                ;   yes
  561 A:fc51  c9 08                              cmp #k_bs               ; backspace (CTRL-H)?
  562 A:fc53  d0 be                              bne bell1                ;   no, check for bell
  563 A:fc55                           bs        
  563 A:fc55  c6 24                              dec ch                ; decrement cursor h index
  564 A:fc57  10 eb                              bpl rts3                ; if pos, ok, else move up
  565 A:fc59  a5 21                              lda wndwdth                ; set ch to wndwdth-1
  566 A:fc5b  85 24                              sta ch
  567 A:fc5d  c6 24                              dec ch                ; rightmost screen position
  568 A:fc5f                           up        
  568 A:fc5f  a5 22                              lda wndtop                ; cursor v index
  569 A:fc61  c5 25                              cmp cv
  570 A:fc63  b0 02                              bcs rts4                ; if top line then return
  571 A:fc65  c6 25                              dec cv                ; decr cursor v
  572 A:fc67                           rts4      
  572 A:fc67  60                                 rts 
  573 A:fc68                           esc1      
  573 A:fc68  49 1b                              eor #k_esc               ; esc?
  574 A:fc6a  f0 1c                              beq home                ;   if so, do home and clear
  575 A:fc6c  e9 02                              sbc #$02             ; esc-a or -b check
  576 A:fc6e  30 cc                              bmi advance                ;   a, advance
  577 A:fc70  f0 e3                              beq bs                ;   b, backspace
  578 A:fc72  e9 02                              sbc #$02             ; esc-c or -d check
  579 A:fc74  30 20                              bmi lf                ;   c, down
  580 A:fc76  f0 e7                              beq up                ;   d, go up
  581 A:fc78  e9 02                              sbc #$02             ; esc-e or -f check
  582 A:fc7a  90 2a                              bcc clreol                ;   e, clear to end of line
  583 A:fc7c  d0 e9                              bne rts4                ;   not f, return
  584 A:fc7e                           clreop    
  584 A:fc7e  a4 24                              ldy ch                ; cursor h to y
  585 A:fc80  a5 25                              lda cv                ; cursor v to a
  586 A:fc82                           cleop1    
  586 A:fc82  48                                 pha                    ; save current line on stk
  587 A:fc83  a9 00                              lda #t_cls               ; clear screen command
  588 A:fc85  8d 13 c0                           sta termesc                ; send to terminal
  589 A:fc88                           home      
  589 A:fc88  a5 22                              lda wndtop                ; init cursor v
  590 A:fc8a  85 25                              sta cv                ;   and h-indices
  591 A:fc8c  a0 00                              ldy #$00
  592 A:fc8e  84 24                              sty ch                ; then clear to end of page
  593 A:fc90  f0 f0                              beq cleop1
  594 A:fc92                           cr        
  594 A:fc92  a9 00                              lda #$00             ; cursor to left of index
  595 A:fc94  85 24                              sta ch
  596 A:fc96                           lf        
  596 A:fc96  e6 25                              inc cv                ; incr cursor v (down 1 line)
  597 A:fc98  a5 25                              lda cv
  598 A:fc9a  c5 23                              cmp wndbtm                ; off screen?
  599 A:fc9c  90 c9                              bcc rts4                ;   no, done
  600 A:fc9e  c6 25                              dec cv                ; decr cursor v (back to bottom)
  601 A:fca0                           scroll    
  601 A:fca0  a9 03                              lda #t_scr               ; scroll command
  602 A:fca2  8d 13 c0                           sta termesc                ; let the terminal scroll.
  603 A:fca5  60                                 rts 
  604 A:fca6                           clreol    
  604 A:fca6  a9 01                              lda #t_cll               ; clear to eol command
  605 A:fca8  8d 13 c0                           sta termesc                ; execute
  606 A:fcab  60                                 rts 
  607 A:fcac                           wait      
  607 A:fcac  38                                 sec 
  608 A:fcad                           wait2     
  608 A:fcad  48                                 pha 
  609 A:fcae                           wait3     
  609 A:fcae  e9 01                              sbc #$01
  610 A:fcb0  d0 fc                              bne wait3                ; 1.02.4 uSec
  611 A:fcb2  68                                 pla                    ; (13+2712*A+512*A*A) on 1 MHz
  612 A:fcb3  e9 01                              sbc #$01
  613 A:fcb5  d0 f6                              bne wait2                ; busy, busy, busy waiting
  614 A:fcb7  60                                 rts 
  615 A:fcb8                                    ;
  616 A:fcb8                                    ; increment source and target addresses a1 and a4
  617 A:fcb8                                    ; until source reaches a2
  618 A:fcb8                                    ; sets carry when a1 >= a2
  619 A:fcb8                                    ;
  620 A:fcb8                           nxta4     
  620 A:fcb8  e6 42                              inc a4l                ; incr 2-byte a4
  621 A:fcba  d0 02                              bne nxta1                ;  and a1
  622 A:fcbc  e6 43                              inc a4h
  623 A:fcbe                                    ; reuse nxta1 for nxta4...
  624 A:fcbe                                    ;
  625 A:fcbe                                    ;  increment a1 until it reached a2
  626 A:fcbe                                    ;
  627 A:fcbe                           nxta1     
  627 A:fcbe  a5 3c                              lda a1l                ; incr 2-byte a1
  628 A:fcc0  c5 3e                              cmp a2l                ;    set carry if a1l >= a2l
  629 A:fcc2  a5 3d                              lda a1h                ;   and compare to a2
  630 A:fcc4  e5 3f                              sbc a2h                ;  carry set if a1 >= a2
  631 A:fcc6  e6 3c                              inc a1l
  632 A:fcc8  d0 02                              bne rts4b
  633 A:fcca  e6 3d                              inc a1h
  634 A:fccc                           rts4b     
  634 A:fccc  60                                 rts                    ; return carry bit
  635 A:fccd                           charout   
  635 A:fccd  a4 25                              ldy cv                ; cursor y index to y register
  636 A:fccf  8c 10 c0                           sty termcy                ; set terminal cursor y
  637 A:fcd2  a4 24                              ldy ch                ; cursor h index to y register
  638 A:fcd4  8c 11 c0                           sty termcx                ; set terminal cursor x
  639 A:fcd7  8d 12 c0                           sta termout                ; output char
  640 A:fcda  60                                 rts 
  641 A:fcdb                           rdkey     
  641 A:fcdb  a0 06                              ldy #t_blnk               ; set screen to flash
  642 A:fcdd  8c 13 c0                           sty termesc
  643 A:fce0  ad 12 c0                           lda termout                ; get char at cursor pos.
  644 A:fce3  20 cd fc                           jsr charout
  645 A:fce6  a0 04                              ldy #t_norm               ; set screen back to normal after
  646 A:fce8  8c 13 c0                           sty termesc
  647 A:fceb  6c 38 00                           jmp (kswl)              ; go to user key-in
  648 A:fcee                           keyin     
  648 A:fcee  e6 4e                              inc rndl
  649 A:fcf0  d0 02                              bne keyin2                ; inc random number
  650 A:fcf2  e6 4f                              inc rndh
  651 A:fcf4                           keyin2    
  651 A:fcf4  ad 00 c0                           lda kbd
  652 A:fcf7  f0 f5                              beq keyin                ; busy waiting loop until key != 0...
  653 A:fcf9  20 cd fc                           jsr charout                ; replace flashing screen
  654 A:fcfc  2c 01 c0                           bit kbdstrb                ; clear key strobe
  655 A:fcff  60                                 rts 
  656 A:fd00                           esc       
  656 A:fd00  20 db fc                           jsr rdkey                ; get keycode
  657 A:fd03  20 68 fc                           jsr esc1                ;  handle esc function
  658 A:fd06                           rdchar    
  658 A:fd06  20 db fc                           jsr rdkey                ; read key
  659 A:fd09  c9 1b                              cmp #k_esc               ; ESC?
  660 A:fd0b  f0 f3                              beq esc                ;   yes, don't return
  661 A:fd0d  60                                 rts 
  662 A:fd0e                           notcr     
  662 A:fd0e  a5 32                              lda invflg
  663 A:fd10  48                                 pha 
  664 A:fd11  a9 04                              lda #t_norm
  665 A:fd13  85 32                              sta invflg                ; echo user line
  666 A:fd15  bd 00 02                           lda in,x              ;   non inverse
  667 A:fd18  20 c2 fd                           jsr cout
  668 A:fd1b  68                                 pla 
  669 A:fd1c  85 32                              sta invflg
  670 A:fd1e  bd 00 02                           lda in,x
  671 A:fd21  c9 08                              cmp #k_bs               ; check for edit keys
  672 A:fd23  f0 20                              beq bckspc                ;  bs, ctrl-x
  673 A:fd25  c9 18                              cmp #k_ctl_x
  674 A:fd27  f0 0a                              beq cancel
  675 A:fd29  e0 f8                              cpx #$f8             ; margin?
  676 A:fd2b  90 03                              bcc notcr1
  677 A:fd2d  20 15 ff                           jsr bell                ; yes, sound bell
  678 A:fd30                           notcr1    
  678 A:fd30  e8                                 inx                    ; advance input index
  679 A:fd31  d0 16                              bne nxtchar
  680 A:fd33                           cancel    
  680 A:fd33  a9 5c                              lda #'\'             ; backslash after cancelled LTN?
  681 A:fd35  20 c2 fd                           jsr cout
  682 A:fd38                           getlnz    
  682 A:fd38  20 63 fd                           jsr crout                ; output cr
  683 A:fd3b                           getln     
  683 A:fd3b  6c 28 00                           jmp (rdline)
  684 A:fd3e                           getlnw    
  684 A:fd3e  a5 33                              lda prompt
  685 A:fd40  20 c2 fd                           jsr cout                ; output prompt char
  686 A:fd43  a2 01                              ldx #$01             ; init input index
  687 A:fd45                           bckspc    
  687 A:fd45  8a                                 txa                    ;   will backspace to u
  688 A:fd46  f0 f0                              beq getlnz
  689 A:fd48  ca                                 dex 
  690 A:fd49                           nxtchar   
  690 A:fd49  20 06 fd                           jsr rdchar
  691 A:fd4c  c9 15                              cmp #k_ctl_u               ; use screen char
  692 A:fd4e  d0 03                              bne captst                ;  for ctrl-u
  693 A:fd50  ad 12 c0                           lda termout                ; get char under cursor
  694 A:fd53                           captst    
  694 A:fd53  c9 60                              cmp #$60
  695 A:fd55  90 02                              bcc addinp                ; convert to caps; for now..
  696 A:fd57  29 df                              and #$df
  697 A:fd59                           addinp    
  697 A:fd59  9d 00 02                           sta in,x              ; add to input buffer
  698 A:fd5c  c9 0a                              cmp #k_entr
  699 A:fd5e  d0 ae                              bne notcr
  700 A:fd60  20 a6 fc                           jsr clreol                ; clear to eol if cr

  702 A:fd63                           crout     
  702 A:fd63  a9 0a                              lda #k_entr
  703 A:fd65  d0 5b                              bne cout                ; branches always ?!?
  704 A:fd67                           pra1      
  704 A:fd67  a4 3d                              ldy a1h                ; print CR,A1 in hex
  705 A:fd69  a6 3c                              ldx a1l
  706 A:fd6b                                    ;
  707 A:fd6b                                    ; print address header at start of line
  708 A:fd6b                                    ; yyxx-
  709 A:fd6b                                    ;
  710 A:fd6b                           pryx2     
  710 A:fd6b  20 63 fd                           jsr crout
  711 A:fd6e  20 a7 f9                           jsr prntyx
  712 A:fd71  a0 00                              ldy #$00
  713 A:fd73  a9 2d                              lda #'-'             ; print '-'
  714 A:fd75  4c c2 fd                           jmp cout
  715 A:fd78                                    ;
  716 A:fd78                                    ; Examine 8 bytes at address
  717 A:fd78                                    ; Triggered by command xxxx.yyyy
  718 A:fd78                                    ;
  719 A:fd78                           xam8      
  719 A:fd78  a5 3c                              lda a1l
  720 A:fd7a  09 07                              ora #$07             ; set to finish at
  721 A:fd7c  85 3e                              sta a2l                ;   mod 8=7
  722 A:fd7e  a5 3d                              lda a1h
  723 A:fd80  85 3f                              sta a2h
  724 A:fd82                           mod8chk   
  724 A:fd82  a5 3c                              lda a1l
  725 A:fd84  29 07                              and #$07
  726 A:fd86  d0 03                              bne dataout
  727 A:fd88                                    ;
  728 A:fd88                                    ; Examine byte at address
  729 A:fd88                                    ;
  730 A:fd88                           xam       
  730 A:fd88  20 67 fd                           jsr pra1
  731 A:fd8b                           dataout   
  731 A:fd8b  a9 20                              lda #' '
  732 A:fd8d  20 c2 fd                           jsr cout                ; output blank
  733 A:fd90  b1 3c                              lda (a1l),y
  734 A:fd92  20 af fd                           jsr prbyte                ; print byte in hex
  735 A:fd95  20 be fc                           jsr nxta1
  736 A:fd98  90 e8                              bcc mod8chk                ; check if time to,
  737 A:fd9a  60                                 rts                    ;  print address
  738 A:fd9b                           xampm     
  738 A:fd9b  4a                                 lsr                    ; determine if mon
  739 A:fd9c  90 ea                              bcc xam                ;  mode is xam
  740 A:fd9e  4a                                 lsr                    ;  add or sub
  741 A:fd9f  4a                                 lsr 
  742 A:fda0  a5 3e                              lda a2l
  743 A:fda2  90 02                              bcc add
  744 A:fda4  49 ff                              eor #$ff             ; sub - form 2's complement
  745 A:fda6                           add       
  745 A:fda6  65 3c                              adc a1l
  746 A:fda8  48                                 pha 
  747 A:fda9  a9 3d                              lda #'='             ; print '=' the result
  748 A:fdab  20 c2 fd                           jsr cout
  749 A:fdae  68                                 pla 
  750 A:fdaf                                    ;
  751 A:fdaf                                    ; print byte as 2 hex digits
  752 A:fdaf                                    ;
  753 A:fdaf                           prbyte    
  753 A:fdaf  48                                 pha                    ; save a for second half
  754 A:fdb0  4a                                 lsr                    ; shift 4 high digits into low nibble, destroys accu
  755 A:fdb1  4a                                 lsr 
  756 A:fdb2  4a                                 lsr 
  757 A:fdb3  4a                                 lsr 
  758 A:fdb4  20 ba fd                           jsr prhexz                ; first hex per subroutine,
  759 A:fdb7  68                                 pla                    ;   second hex direct, reuse rts for prbyte
  760 A:fdb8                           prhex     
  760 A:fdb8  29 0f                              and #$0f             ; print hex digit in accu
  761 A:fdba                                    ;
  762 A:fdba                                    ; print lower accu nibble as hex number
  763 A:fdba                                    ;
  764 A:fdba                           prhexz    
  764 A:fdba  09 30                              ora #$30             ;   lsb's
  765 A:fdbc  c9 3a                              cmp #$3a
  766 A:fdbe  90 02                              bcc cout
  767 A:fdc0  69 06                              adc #$06             ; afterwards, flow into cout
  768 A:fdc2                                    ;
  769 A:fdc2                                    ; Character out to screen
  770 A:fdc2                                    ; go through cswl zero page vector
  771 A:fdc2                                    ;
  772 A:fdc2                           cout      
  772 A:fdc2  6c 36 00                           jmp (cswl)              ; vector to user output routine
  773 A:fdc5                                    ;
  774 A:fdc5                                    ; Standard cswl character out routine
  775 A:fdc5                                    ;
  776 A:fdc5                           cout1     
  776 A:fdc5  84 35                              sty ysav1                ; save the y register
  777 A:fdc7  48                                 pha                    ; save A
  778 A:fdc8  20 45 fc                           jsr vidout                ; output a as ascii
  779 A:fdcb  68                                 pla                    ; restore A
  780 A:fdcc  a4 35                              ldy ysav1                ; restore y and return
  781 A:fdce  60                                 rts 
  782 A:fdcf                                    ;
  783 A:fdcf                                    ; on blank / return, execute preceding command
  784 A:fdcf                                    ;
  785 A:fdcf                           bli       
  785 A:fdcf  c6 34                              dec ysav
  786 A:fdd1  f0 a5                              beq xam8
  787 A:fdd3                           blank     
  787 A:fdd3  ca                                 dex                    ; blank to mon
  788 A:fdd4  d0 16                              bne setmdz                ; after blank
  789 A:fdd6  c9 3a                              cmp #':'             ; data store mode?
  790 A:fdd8  d0 c1                              bne xampm                ;   no, xam, add or sub
  791 A:fdda                           stor      
  791 A:fdda  85 31                              sta mode                ; keep in store mode
  792 A:fddc  a5 3e                              lda a2l
  793 A:fdde  91 40                              sta (a3l),y            ; store as low byte as (a3)
  794 A:fde0  e6 40                              inc a3l
  795 A:fde2  d0 02                              bne rts5                ; incr a3, return
  796 A:fde4  e6 41                              inc a3h
  797 A:fde6                           rts5      
  797 A:fde6  60                                 rts 
  798 A:fde7                                    ;
  799 A:fde7                                    ; set the command mode
  800 A:fde7                                    ;
  801 A:fde7                           setmode   
  801 A:fde7  a4 34                              ldy ysav                ; save converted colon, '+',
  802 A:fde9  b9 ff 01                           lda in-1,y          ;  '-', '.' as mode.
  803 A:fdec                           setmdz    
  803 A:fdec  85 31                              sta mode
  804 A:fdee  60                                 rts 
  805 A:fdef                                    ;
  806 A:fdef                                    ; '<' command for move / verify
  807 A:fdef                                    ; initialize zero page variables for following V/M command
  808 A:fdef                                    ;
  809 A:fdef                           lt        
  809 A:fdef  a2 01                              ldx #$01
  810 A:fdf1                           lt2       
  810 A:fdf1  b5 3e                              lda a2l,x              ; copy a2 (2 bytes) to
  811 A:fdf3  95 42                              sta a4l,x              ;   a4 and a5
  812 A:fdf5  95 44                              sta a5l,x
  813 A:fdf7  ca                                 dex 
  814 A:fdf8  10 f7                              bpl lt2
  815 A:fdfa  60                                 rts 
  816 A:fdfb                                    ;
  817 A:fdfb                                    ; copy memory range
  818 A:fdfb                                    ;
  819 A:fdfb                           move      
  819 A:fdfb  b1 3c                              lda (a1l),y            ; move (a1 to a2) to
  820 A:fdfd  91 42                              sta (a4l),y            ;   (a4)
  821 A:fdff  20 b8 fc                           jsr nxta4                ; y is set to 0 in zmode. there is no address
  822 A:fe02  90 f7                              bcc move                ;  mode for zero indirect without y, and move
  823 A:fe04  60                                 rts                    ;  must work with ranges > 255
  824 A:fe05                                    ;
  825 A:fe05                                    ; verify that two memory ranges have same content
  826 A:fe05                                    ;
  827 A:fe05                           vfy       
  827 A:fe05  b1 3c                              lda (a1l),y            ; verify (a1 to a2) with
  828 A:fe07  d1 42                              cmp (a4l),y            ;   (a4)
  829 A:fe09  f0 1c                              beq vfyok
  830 A:fe0b  20 67 fd                           jsr pra1
  831 A:fe0e  b1 3c                              lda (a1l),y
  832 A:fe10  20 af fd                           jsr prbyte
  833 A:fe13  a9 20                              lda #' '             ; space
  834 A:fe15  20 c2 fd                           jsr cout
  835 A:fe18  a9 28                              lda #'('             ; '('
  836 A:fe1a  20 c2 fd                           jsr cout
  837 A:fe1d  b1 42                              lda (a4l),y
  838 A:fe1f  20 af fd                           jsr prbyte
  839 A:fe22  a9 29                              lda #')'             ; ')'
  840 A:fe24  20 c2 fd                           jsr cout
  841 A:fe27                           vfyok     
  841 A:fe27  20 b8 fc                           jsr nxta4
  842 A:fe2a  90 d9                              bcc vfy
  843 A:fe2c  60                                 rts 
  844 A:fe2d                                    ;
  845 A:fe2d                                    ; list memory range as assembler
  846 A:fe2d                                    ;
  847 A:fe2d                           list      
  847 A:fe2d  20 44 fe                           jsr a1pc                ; move a1 (2 bytes) to
  848 A:fe30  a9 14                              lda #$14             ;  pc if specified and
  849 A:fe32                           list2     
  849 A:fe32  48                                 pha                    ;  dissemble 20 instructions
  850 A:fe33  20 37 f9                           jsr instdsp
  851 A:fe36  20 ba f9                           jsr pcadj                ; adjust pc each instruction
  852 A:fe39  85 3a                              sta pcl
  853 A:fe3b  84 3b                              sty pch
  854 A:fe3d  68                                 pla 
  855 A:fe3e  38                                 sec 
  856 A:fe3f  e9 01                              sbc #$01             ; next 20 instr.
  857 A:fe41  d0 ef                              bne list2
  858 A:fe43  60                                 rts 
  859 A:fe44                           a1pc      
  859 A:fe44  8a                                 txa                    ; if user specified address
  860 A:fe45  f0 07                              beq a1pcrts                ;   copy from a1 to pc
  861 A:fe47                           a1pclp    
  861 A:fe47  b5 3c                              lda a1l,X
  862 A:fe49  95 3a                              sta pcl,x
  863 A:fe4b  ca                                 dex 
  864 A:fe4c  10 f9                              bpl a1pclp
  865 A:fe4e                           a1pcrts   
  865 A:fe4e  60                                 rts 
  866 A:fe4f                                    ;
  867 A:fe4f                                    ; set inverse character mode
  868 A:fe4f                                    ;
  869 A:fe4f                           setinv    
  869 A:fe4f  a0 05                              ldy #t_inv               ; set for inverse video
  870 A:fe51  d0 02                              bne setiflg
  871 A:fe53                                    ;
  872 A:fe53                                    ; set norml character mode
  873 A:fe53                                    ;
  874 A:fe53                           setnorm   
  874 A:fe53  a0 04                              ldy #t_norm               ; set for normal video
  875 A:fe55                           setiflg   
  875 A:fe55  84 32                              sty invflg
  876 A:fe57  60                                 rts 
  877 A:fe58                                    ;
  878 A:fe58                                    ; Switch terminal configuration
  879 A:fe58                                    ; Terminal mode in $C01F is 0 when in screen mode,
  880 A:fe58                                    ; and 1 when in stdio mode
  881 A:fe58                                    ;
  882 A:fe58                           termsw    
  882 A:fe58                                    
  883 A:fe58  60                                 rts 
  884 A:fe59                                    ;
  885 A:fe59                                    ; set input port to standard keyboard
  886 A:fe59                                    ;
  887 A:fe59                           setkbd    
  887 A:fe59  a9 00                              lda #$00             ; simulate port #0 input
  888 A:fe5b                           inport    
  888 A:fe5b  85 3e                              sta a2l                ;   specified (keyin routine)
  889 A:fe5d                           inprt     
  889 A:fe5d                                     .( 
  890 A:fe5d  a2 38                              ldx #kswl
  891 A:fe5f  ad 1f c0                           lda termmd                ; window mode - 0, stdio mode - 1
  892 A:fe62  d0 09                              bne inprt3                ; stdio
  893 A:fe64  a0 ee                              ldy #<keyin
  894 A:fe66  a9 fc                              lda #>keyin
  895 A:fe68  85 3f                              sta a2h                ; default msb
  896 A:fe6a  4c ad fe                           jmp ioprt
  897 A:fe6d                           inprt3    
  897 A:fe6d  a0 ac                              ldy #<stdin              ; load stdout vector
  898 A:fe6f  a9 f8                              lda #>stdin              ; y lsb of cout1 standard vector
  899 A:fe71  85 3f                              sta a2h                ; default msb
  900 A:fe73  4c ad fe                           jmp ioprt
  901 A:fe76                                     .) 
  902 A:fe76                                    ;
  903 A:fe76                                    ; set input port to standard keyboard
  904 A:fe76                                    ;
  905 A:fe76                           setrdl    
  905 A:fe76  a9 00                              lda #$00             ; simulate port #0 input
  906 A:fe78                           rdport    
  906 A:fe78  85 3e                              sta a2l                ;   specified (keyin routine)
  907 A:fe7a                           rdprt     
  907 A:fe7a                                     .( 
  908 A:fe7a  a2 28                              ldx #rdline
  909 A:fe7c  ad 1f c0                           lda termmd                ; window mode - 0, stdio mode - 1
  910 A:fe7f  d0 09                              bne rdprt3                ; stdio
  911 A:fe81  a0 3e                              ldy #<getlnw
  912 A:fe83  a9 fd                              lda #>getlnw
  913 A:fe85  85 3f                              sta a2h                ; default msb
  914 A:fe87  4c ad fe                           jmp ioprt
  915 A:fe8a                           rdprt3    
  915 A:fe8a  a0 b0                              ldy #<stdrdln              ; load stdout vector
  916 A:fe8c  a9 f8                              lda #>stdrdln              ; y lsb of cout1 standard vector
  917 A:fe8e  85 3f                              sta a2h                ; default msb
  918 A:fe90  4c ad fe                           jmp ioprt
  919 A:fe93                                     .) 
  920 A:fe93                                    ;
  921 A:fe93                                    ; Set output port to standard terminal
  922 A:fe93                                    ;
  923 A:fe93                           setvid    
  923 A:fe93  a9 00                              lda #$00             ; simulate port #0 output
  924 A:fe95                           outport   
  924 A:fe95  85 3e                              sta a2l                ;   specified (cout routine)
  925 A:fe97                           outprt    
  925 A:fe97                                     .( 
  926 A:fe97  a2 36                              ldx #cswl               ; x has zero page location for cout vector
  927 A:fe99  ad 1f c0                           lda termmd                ; window mode - 0, stdio mode - 1
  928 A:fe9c  d0 09                              bne outprt3                ; stdio
  929 A:fe9e  a0 c5                              ldy #<cout1
  930 A:fea0  a9 fd                              lda #>cout1
  931 A:fea2  85 3f                              sta a2h                ; default msb
  932 A:fea4  4c ad fe                           jmp ioprt
  933 A:fea7                           outprt3   
  933 A:fea7  a0 ca                              ldy #<stdout              ; load stdout vector
  934 A:fea9  a9 f8                              lda #>stdout              ; y lsb of cout1 standard vector
  935 A:feab  85 3f                              sta a2h                ; default msb
  936 A:fead                                     .) 
  937 A:fead                                    ;
  938 A:fead                                    ; set either internal or peripheral port
  939 A:fead                                    ; a2l contains a port number 0-7
  940 A:fead                                    ; a2l = 0 - use internal port
  941 A:fead                                    ; a2l > 0 - It is a peripheral, the msb of the address is
  942 A:fead                                    ; 0xCn where n is peripheral #1-7
  943 A:fead                                    ;
  944 A:fead                           ioprt     
  944 A:fead  a5 3e                              lda a2l                ; set ram in/out vectors
  945 A:feaf  29 0f                              and #$0f
  946 A:feb1  f0 06                              beq ioprt1
  947 A:feb3  09 c0                              ora #>ioadr              ; high byte
  948 A:feb5  a0 00                              ldy #$00
  949 A:feb7  f0 02                              beq ioprt2
  950 A:feb9                           ioprt1    
  950 A:feb9  a5 3f                              lda a2h
  951 A:febb                           ioprt2    
  951 A:febb  94 00                              sty loc0,x
  952 A:febd  95 01                              sta loc1,x
  953 A:febf  60                                 rts 
  954 A:fec0                                    ;
  955 A:fec0                                    ; execute installed language
  956 A:fec0                                    ;
  957 A:fec0                           x_lang    
  957 A:fec0  4c 00 e0                           jmp lang
  958 A:fec3                                    ; soft entry vector for installed language
  959 A:fec3                           bascont   
  959 A:fec3  4c 03 e0                           jmp lang2
  960 A:fec6                           go        
  960 A:fec6  20 44 fe                           jsr a1pc                ; adr to pc if specified
  961 A:fec9  20 1a ff                           jsr restore                ; restore meta registers
  962 A:fecc  6c 3a 00                           jmp (pcl)              ; go to user subroutine
  963 A:fecf                           regz      
  963 A:fecf  4c 3e fb                           jmp regdsp                ; jump to register display
  964 A:fed2                                    ;
  965 A:fed2                                    ; trace command
  966 A:fed2                                    ;
  967 A:fed2                           trace     
  967 A:fed2  c6 34                              dec ysav
  968 A:fed4                           stepz     
  968 A:fed4  20 44 fe                           jsr a1pc                ; adr to pc if specified
  969 A:fed7  4c aa fa                           jmp step                ; take one step
  970 A:feda                                    ;
  971 A:feda                                    ; execute user command
  972 A:feda                                    ; 
  973 A:feda                           usr       
  973 A:feda  4c f8 03                           jmp usradr                ; to usr subroutine at usradr
  974 A:fedd                                    ;
  975 A:fedd                                    ; write memory range to tape OUT
  976 A:fedd                                    ;
  977 A:fedd                                    ; "Tape" now writes the content directly into the tape file.
  978 A:fedd                                    ; Without cassette I/O ports writing square waves no longer
  979 A:fedd                                    ; makes sense.
  980 A:fedd                                    ;
  981 A:fedd                           write     
  981 A:fedd  a2 00                              ldx #$00             ; stays zero, a1 is incremented each step. There is no lda(a1) instr.
  982 A:fedf                           @wr1      
  982 A:fedf  a1 3c                              lda (a1l,x)
  983 A:fee1  8d 20 c0                           sta tapeio
  984 A:fee4  20 be fc                           jsr nxta1
  985 A:fee7  90 f6                              bcc @wr1
  986 A:fee9  ad 21 c0                           lda tapecls                ; close tape file
  987 A:feec  4c 15 ff                           jmp bell                ; sound bell and return

  989 A:feef                                    ;
  990 A:feef                                    ; execute command line
  991 A:feef                                    ;
  992 A:feef                           crmon     
  992 A:feef  20 cf fd                           jsr bli                ; handle CR as blank
  993 A:fef2  68                                 pla                    ;  then pop stack
  994 A:fef3  68                                 pla                    ; and return to mon
  995 A:fef4  d0 51                              bne monz
  996 A:fef6                                    ;
  997 A:fef6                                    ; read memory area from tape file
  998 A:fef6                                    ;
  999 A:fef6                                    ; This now just needs to read the content
 1000 A:fef6                                    ; as bytes without complications.
 1001 A:fef6                                    ;
 1002 A:fef6                           read      
 1002 A:fef6  a0 3b                              ldy #$3b             ; index for 0/1 test
 1003 A:fef8                           rd3       
 1003 A:fef8  ad 20 c0                           lda tapeio                ; read a byte
 1004 A:fefb  81 3c                              sta (a1l,x)            ; store at (a1)
 1005 A:fefd  20 be fc                           jsr nxta1                ; incr a1, compare to a2
 1006 A:ff00  90 f6                              bcc rd3                ; loop until done
 1007 A:ff02  ac 21 c0                           ldy tapecls                ; close tape
 1008 A:ff05  4c 15 ff                           jmp bell                ; good, sound bell and return

 1010 A:ff08                                    ;
 1011 A:ff08                                    ; print "ERR" and beep
 1012 A:ff08                                    ;
 1013 A:ff08                           prerr     
 1013 A:ff08  a9 c5                              lda #$c5             ; 'E'
 1014 A:ff0a  20 c2 fd                           jsr cout                ; print "ERR" then bell
 1015 A:ff0d  a9 d2                              lda #$d2             ; 'R'
 1016 A:ff0f  20 c2 fd                           jsr cout
 1017 A:ff12  20 c2 fd                           jsr cout
 1018 A:ff15                                    ;
 1019 A:ff15                                    ; ring the terminal bell
 1020 A:ff15                                    ;
 1021 A:ff15                           bell      
 1021 A:ff15  a9 07                              lda #k_ctl_g               ; output bell and return
 1022 A:ff17  4c c2 fd                           jmp cout                ; reuse cout rts directly here...
 1023 A:ff1a                                    ;
 1024 A:ff1a                                    ; restore registers from zero page storage
 1025 A:ff1a                                    ;
 1026 A:ff1a                           restore   
 1026 A:ff1a  a5 48                              lda status                ; restore 6502 register contents
 1027 A:ff1c  48                                 pha                    ;  used by debug software
 1028 A:ff1d  a5 45                              lda acc
 1029 A:ff1f                           restr1    
 1029 A:ff1f  a6 46                              ldx xreg
 1030 A:ff21  a4 47                              ldy yreg
 1031 A:ff23  28                                 plp 
 1032 A:ff24  60                                 rts 
 1033 A:ff25                                    ;
 1034 A:ff25                                    ; save 6502 reg contents to zero page storage
 1035 A:ff25                                    ;
 1036 A:ff25                           save      
 1036 A:ff25  85 45                              sta acc
 1037 A:ff27                           sav1      
 1037 A:ff27  86 46                              stx xreg
 1038 A:ff29  84 47                              sty yreg
 1039 A:ff2b  08                                 php 
 1040 A:ff2c  68                                 pla 
 1041 A:ff2d  85 48                              sta status
 1042 A:ff2f  ba                                 tsx 
 1043 A:ff30  86 49                              stx spnt
 1044 A:ff32  d8                                 cld 
 1045 A:ff33  60                                 rts 
 1046 A:ff34                                    ;
 1047 A:ff34                                    ; 6502 reset vector
 1048 A:ff34                                    ;
 1049 A:ff34                           reset     
 1049 A:ff34  20 53 fe                           jsr setnorm
 1050 A:ff37  20 96 fb                           jsr init
 1051 A:ff3a  20 93 fe                           jsr setvid
 1052 A:ff3d  20 59 fe                           jsr setkbd
 1053 A:ff40  20 76 fe                           jsr setrdl
 1054 A:ff43                                    ;
 1055 A:ff43                                    ; Monitor entry point
 1056 A:ff43                                    ;
 1057 A:ff43                           mon       
 1057 A:ff43  d8                                 cld 
 1058 A:ff44  20 15 ff                           jsr bell
 1059 A:ff47                           monz      
 1059 A:ff47  a9 2a                              lda #'*'             ; Monitor prompt
 1060 A:ff49  85 33                              sta prompt
 1061 A:ff4b  20 38 fd                           jsr getlnz                ; get line
 1062 A:ff4e  20 aa ff                           jsr zmode                ; clear monitor mode, scan idx
 1063 A:ff51                                    ;
 1064 A:ff51                                    ; get the next item from input line
 1065 A:ff51                                    ;
 1066 A:ff51                           nxtitm    
 1066 A:ff51  20 85 ff                           jsr getnum                ; get item, non-hex
 1067 A:ff54  84 34                              sty ysav
 1068 A:ff56  a0 19                              ldy #$19             ; x-reg=0 if no hex input
 1069 A:ff58                                    ;
 1070 A:ff58                                    ; look up command subroutine for current character
 1071 A:ff58                                    ;
 1072 A:ff58                           chrsrch   
 1072 A:ff58  88                                 dey 
 1073 A:ff59  30 e8                              bmi mon                ; not found, go to mon
 1074 A:ff5b  d9 af ff                           cmp chrtbl,y              ; find cmnd char in table
 1075 A:ff5e  d0 f8                              bne chrsrch
 1076 A:ff60  20 9c ff                           jsr tosub                ; found call corresponding subroutine
 1077 A:ff63  a4 34                              ldy ysav
 1078 A:ff65  4c 51 ff                           jmp nxtitm
 1079 A:ff68                                    ;
 1080 A:ff68                                    ; save one digit from input
 1081 A:ff68                                    ; input:
 1082 A:ff68                                    ;    a - 0x00 - 0x0F
 1083 A:ff68                                    ;
 1084 A:ff68                           dig       
 1084 A:ff68  a2 03                              ldx #$03
 1085 A:ff6a  0a                                 asl 
 1086 A:ff6b  0a                                 asl                    ; shift hex digit to upper nibble
 1087 A:ff6c  0a                                 asl 
 1088 A:ff6d  0a                                 asl                    ; now it is 0x00-0xF0
 1089 A:ff6e                           nxtbit    
 1089 A:ff6e  0a                                 asl                    ; transport the high bit to carry
 1090 A:ff6f  26 3e                              rol a2l                ; rotate carry into low byte of a2,
 1091 A:ff71  26 3f                              rol a2h                ;   carry from a2l to a2h
 1092 A:ff73  ca                                 dex                    ; repeat 4 times until new digit shifted into lowest nibble of a2
 1093 A:ff74  10 f8                              bpl nxtbit
 1094 A:ff76                           nxtbas    
 1094 A:ff76  a5 31                              lda mode                ; x is $FF here
 1095 A:ff78  d0 06                              bne nxtbs2                ;   if mode is zero
 1096 A:ff7a  b5 3f                              lda a2h,x              ;    then copy a2 to
 1097 A:ff7c  95 3d                              sta a1h,x              ;     a1 and a3
 1098 A:ff7e  95 41                              sta a3h,x
 1099 A:ff80                           nxtbs2    
 1099 A:ff80  e8                                 inx                    ;   repeat once for l,h pair
 1100 A:ff81  f0 f3                              beq nxtbas
 1101 A:ff83  d0 06                              bne nxtchr
 1102 A:ff85                                    ;
 1103 A:ff85                                    ; getnum read command
 1104 A:ff85                                    ; input: y - pointer to current input char
 1105 A:ff85                                    ; result:
 1106 A:ff85                                    ;   a - mode (non-hex char after number)
 1107 A:ff85                                    ;   x - (changed)
 1108 A:ff85                                    ;   y - pointer to next char
 1109 A:ff85                                    ;   (a2) - number found or 0x0000
 1110 A:ff85                                    ;
 1111 A:ff85                           getnum    
 1111 A:ff85  a2 00                              ldx #$00             ;  clear A2
 1112 A:ff87  86 3f                              stx a2h
 1113 A:ff89  86 3e                              stx a2l
 1114 A:ff8b                           nxtchr    
 1114 A:ff8b  b9 00 02                           lda in,y              ; get char
 1115 A:ff8e  c8                                 iny 
 1116 A:ff8f  49 30                              eor #$30             ; $30 0 -> $00; $39 9 -> $09; $41 A -> $71; $20 -> $10...
 1117 A:ff91  c9 0a                              cmp #$0a
 1118 A:ff93  90 d3                              bcc dig                ; if hex digit
 1119 A:ff95  69 88                              adc #$88             ; c=1, $76 F + $88 + 1 = $FF; $71 A + $88 + 1 = $FA
 1120 A:ff97  c9 fa                              cmp #$fa
 1121 A:ff99  b0 cd                              bcs dig                ; if not a digit a now has ch eor #$30 + $B9
 1122 A:ff9b  60                                 rts 
 1123 A:ff9c                                    ;
 1124 A:ff9c                                    ; Go to command routine
 1125 A:ff9c                                    ;
 1126 A:ff9c                           tosub     
 1126 A:ff9c  98                                 tya 
 1127 A:ff9d  0a                                 asl                    ; subroutine table has 16 bit addresses now.
 1128 A:ff9e  a8                                 tay                    ; to much fumbling making them all stay on page $FE
 1129 A:ff9f  b9 c8 ff                           lda subtbl,y              ; Push high order subroutine address on stack
 1130 A:ffa2  c8                                 iny 
 1131 A:ffa3  48                                 pha 
 1132 A:ffa4  b9 c8 ff                           lda subtbl,y              ; Push low order subroutine address on stack
 1133 A:ffa7  48                                 pha 
 1134 A:ffa8  a5 31                              lda mode                ;  old mode to A
 1135 A:ffaa                                    ;
 1136 A:ffaa                                    ; clear the y flag and the current mode for next subsequence
 1137 A:ffaa                                    ;
 1138 A:ffaa                           zmode     
 1138 A:ffaa  a0 00                              ldy #$00             ; clear y
 1139 A:ffac  84 31                              sty mode                ; clear mode
 1140 A:ffae  60                                 rts                    ; go to command subroutine previously pushed on the stack
 1141 A:ffaf                                    ;
 1142 A:ffaf                                    ; macros for command line parser used in mon and asm
 1143 A:ffaf                                    ;

 1146 A:ffaf                           chrtbl    
 1146 A:ffaf  9a                                 .byt ((('!'^$30)+$89)&$ff)
 1147 A:ffb0  ea                                 .byt ((('Q'^$30)+$89)&$ff)
 1148 A:ffb1  bc                                 .byt (((k_ctl_c^$30)+$89)&$ff)
 1149 A:ffb2  b2                                 .byt (((k_ctl_y^$30)+$89)&$ff)
 1150 A:ffb3  be                                 .byt (((k_ctl_e^$30)+$89)&$ff)
 1151 A:ffb4  ed                                 .byt ((('T'^$30)+$89)&$ff)
 1152 A:ffb5  ef                                 .byt ((('V'^$30)+$89)&$ff)
 1153 A:ffb6  c4                                 .byt (((k_ctl_k^$30)+$89)&$ff)
 1154 A:ffb7  ec                                 .byt ((('S'^$30)+$89)&$ff)
 1155 A:ffb8  a9                                 .byt (((k_ctl_p^$30)+$89)&$ff)
 1156 A:ffb9  bb                                 .byt (((k_ctl_b^$30)+$89)&$ff)
 1157 A:ffba  a6                                 .byt ((('-'^$30)+$89)&$ff)
 1158 A:ffbb  a4                                 .byt ((('+'^$30)+$89)&$ff)
 1159 A:ffbc  06                                 .byt ((('M'^$30)+$89)&$ff)
 1160 A:ffbd  95                                 .byt ((('<'^$30)+$89)&$ff)
 1161 A:ffbe  07                                 .byt ((('N'^$30)+$89)&$ff)
 1162 A:ffbf  02                                 .byt ((('I'^$30)+$89)&$ff)
 1163 A:ffc0  05                                 .byt ((('L'^$30)+$89)&$ff)
 1164 A:ffc1  f0                                 .byt ((('W'^$30)+$89)&$ff)
 1165 A:ffc2  00                                 .byt ((('G'^$30)+$89)&$ff)
 1166 A:ffc3  eb                                 .byt ((('R'^$30)+$89)&$ff)
 1167 A:ffc4  93                                 .byt (((':'^$30)+$89)&$ff)
 1168 A:ffc5  a7                                 .byt ((('.'^$30)+$89)&$ff)
 1169 A:ffc6  c3                                 .byt (((k_entr^$30)+$89)&$ff)
 1170 A:ffc7  99                                 .byt (((' '^$30)+$89)&$ff)
 1171 A:ffc8                                    ; Monitor commands:
 1172 A:ffc8                                    ; '!'           enter mini assembler
 1173 A:ffc8                                    ; 'Q'           terminate emulator by jumping to $FFFF. When PC=$FFFF, the cpu loop terminates.
 1174 A:ffc8                                    ; ctrl-c        bascont
 1175 A:ffc8                                    ; ctrl-y        usr
 1176 A:ffc8                                    ; ctrl-e        regz
 1177 A:ffc8                                    ; 'T'           trace
 1178 A:ffc8                                    ; 'V'           vfy
 1179 A:ffc8                                    ; ctrl-k        inprt
 1180 A:ffc8                                    ; 'S'           stepz
 1181 A:ffc8                                    ; ctrl-p        outprt
 1182 A:ffc8                                    ; ctrl-b        x_lang
 1183 A:ffc8                                    ; '-'           setmode
 1184 A:ffc8                                    ; '+'           setmode
 1185 A:ffc8                                    ; 'M'           move
 1186 A:ffc8                                    ; '<'           lt
 1187 A:ffc8                                    ; 'N'           setnorm
 1188 A:ffc8                                    ; 'I'           setinv
 1189 A:ffc8                                    ; 'L'           list
 1190 A:ffc8                                    ; 'W'           write
 1191 A:ffc8                                    ; 'G'           go
 1192 A:ffc8                                    ; 'R'           read
 1193 A:ffc8                                    ; colon         write area addr1,addr2
 1194 A:ffc8                                    ; '.'           hexdump addr1,addr2
 1195 A:ffc8                                    ; enter         execute monitor command line
 1196 A:ffc8                                    ; ' '           add preceding command to line
 1197 A:ffc8                                    ;
 1198 A:ffc8                                    ; table must have msb first lsb second
 1199 A:ffc8                                    ;
 1200 A:ffc8                           subtbl    
 1200 A:ffc8  f5 49                              .byt >asm_entry,<asm_entry          ; ! - Enter assembler
 1201 A:ffca  f8 a6                              .byt >exit,<exit          ; Q - Quit emulator
 1202 A:ffcc  fe c3                              .byt >bascont,<bascont          ; CTL-C - exit moitor to installed language
 1203 A:ffce  fe da                              .byt >usr,<usr          ; CTL-Y - execute user command at vector %3F8
 1204 A:ffd0  fe cf                              .byt >regz,<regz          ; CTL-E - examine registers
 1205 A:ffd2  fe d2                              .byt >trace,<trace          ; "T" - Trace until reset or brk
 1206 A:ffd4  fe 05                              .byt >vfy,<vfy          ; "V" - Verify memory range
 1207 A:ffd6  fe 5d                              .byt >inprt,<inprt          ; [0-7] CTL-K - input from keyboard (0) or peripheral card 1-7
 1208 A:ffd8  fe d4                              .byt >stepz,<stepz          ; "S" - Step
 1209 A:ffda  fe 97                              .byt >outprt,<outprt          ; [0-7] CTL-P - send output to video (0) or printer peripheral 1-7
 1210 A:ffdc  fe c0                              .byt >x_lang,<x_lang          ; CTL-B -
 1211 A:ffde  fd e7                              .byt >setmode,<setmode          ; "-" - hexadecimal substraction
 1212 A:ffe0  fd e7                              .byt >setmode,<setmode          ; "+" - hexadecimal addition
 1213 A:ffe2  fd fb                              .byt >move,<move          ; "M" - mpve memory range
 1214 A:ffe4  fd ef                              .byt >lt,<lt          ; "< aaaa.bbbb M|V" - Move / compare memory range
 1215 A:ffe6  fe 53                              .byt >setnorm,<setnorm          ; "N" - set to normal output
 1216 A:ffe8  fe 4f                              .byt >setinv,<setinv          ; "I" - set to inverse output
 1217 A:ffea  fe 2d                              .byt >list,<list          ; "L" - list preceding memory add
 1218 A:ffec  fe dd                              .byt >write,<write          ; "aaaa.bbbb W" - Save memory range on tape
 1219 A:ffee  fe c6                              .byt >go,<go          ; "aaaa G" - Run program as subroutine at aaaa
 1220 A:fff0  fe f6                              .byt >read,<read          ; "aaaa.bbbb R" - Read memory range from tape
 1221 A:fff2  fd e7                              .byt >setmode,<setmode          ; colon xx yy... - change current location. to given ehx bytes
 1222 A:fff4  fd e7                              .byt >setmode,<setmode          ; ".yyyy" - examine bytes between after current position and yyyy
 1223 A:fff6  fe ef                              .byt >crmon,<crmon          ; enter - starts evaluation of commands in input line
 1224 A:fff8  fd d3                              .byt >blank,<blank          ; space separator
 1225 A:fffa                                    ;
 1226 A:fffa                                    ; 6502 fixed system vectors. Must start at 0xFFFA
 1227 A:fffa                                    ; .org not working here, adjusting with
 1228 A:fffa                                    ; .dsb block "keep_aligned" above
 1229 A:fffa                                    ;
 1230 A:fffa                           sysvec_nmi 
 1230 A:fffa  fb 03                              .word nmiloc                ; nmi vector set up in RAM by reset routine
 1231 A:fffc                           sysvec_reset 
 1231 A:fffc  34 ff                              .word reset                ; reset vector
 1232 A:fffe                           sysvec_irq 
 1232 A:fffe  ed fa                              .word irqvec                ; irq vector in rom
