
rom.s

    1 A:1000                                    ;
    2 A:1000                                    ; haiku6502 ROM
    3 A:1000                                    ;
    4 A:1000                                    ; Annotated and modified emulator ROM using orig_monitor_rom.s as a template.
    5 A:1000                                    ; This code is only for academic purposes.
    6 A:1000                                    ; This file is compatible with xa assembler and is not relocatable.
    7 A:1000                                    ; Care has to be taken to keep the "go" jump table addresses area on page 0xFE or else it will cease to work this way.
    8 A:1000                                    ; There are a few nifty tricks in the original assembler code to save a few bytes here and there that probably
    9 A:1000                                    ; would not have been done this way were there more than 12KB address space available for ROM.
   10 A:1000                                    ;
   11 A:1000                                    ; The following modifications have been made
   11 A:1000                                    
   12 A:1000                                    ;
   13 A:1000                                    ; - fixed character mapping. ASCII chars are now ASCII chars in the right code points.
   14 A:1000                                    ; - removed memory mapped text and graphics screens. The screen is now a terminal peripheral controlled
   15 A:1000                                    ;   through I/O ports 0xC010-0xC01F
   16 A:1000                                    ; - keyboard strobe is now in 0xC001, to make space for more i/o control addresses
   17 A:1000                                    ; - removed screen address calculations, no longer needed with sane terminal cursor coordinates that
   18 A:1000                                    ;   are no longer aligned with cathode ray tube electronic beam scan sequence.
   19 A:1000                                    ; - Bell just sends a CTL-G to terminal
   20 A:1000                                    ; - Tape in/out goes to a tape file. with the right sampling rate, it should be possible to read in data tapes.
   21 A:1000                                    ;   not much use though, since the rom routine addresses are now no longer compatible.
   22 A:1000                                    ; - The screen size is taken from the terminal dimensions. Size is no longer restricted to 1KB text pages.
   23 A:1000                                    ; - Lo-Res and Hi-Res graphics modes are gone for now since they don't work too well with the standard ncurses based
   24 A:1000                                    ;   terminal peripheral. A graphics terminal peripheral could be added, though.
   25 A:1000                                    ; - The peripheral system is not completed, especially emulator interrupt management is rudimentary. So peripheral
   26 A:1000                                    ;   rom areas can be addressed, but the extension rom area 0xC800-0xC8FF needs work. This does not ffect this rom,
   27 A:1000                                    ;   though...
   28 A:1000                                    ;
   29 A:1000                                    ; The monitor part works pretty much the same as described in the Apple II Reference Manual. It has a nice disassembler.
   30 A:1000                                    ; It provides RAM editing as hex dump only for now.
   31 A:1000                                    ;
   32 A:1000                                    ; Memory layout
   32 A:1000                                    
   33 A:1000                                    ;
   34 A:1000                                    ; 0x0000-0x00FF Zero page
   35 A:1000                                    ; 0x0100-9x01FF Stack
   36 A:1000                                    ; 0x0200-0x02FF text buffer
   37 A:1000                                    ; 0x0300-0x03FF system vars & vectors
   38 A:1000                                    ; 0x0400-0xBFFF free RAM
   39 A:1000                                    ; 0xC000-0xCFFF I/O
   40 A:1000                                    ; 0xD000-0xFFFF ROM; thereof
   41 A:1000                                    ;               0xD000 - 0xF800 Reserved for language modules
   42 A:1000                                    ;               0xF800 - 0xFFFF System Monitor ROM
   43 A:1000                                    ;               0xFFFA - 0xFFFF Hardwired 6502 NMI, Reset and IRQ vectors, have to be kept at fixed addresses.
   44 A:1000                                    ; On Reset, the program counter is loaded from 0xFFFC and 0xFFFD. all addresses with least
   45 A:1000                                    ; significant (lsb,low) byte first.
   46 A:1000                                    ;
   47 A:1000                                    ; TODO Fix remaining bugs, cleanup code
   48 A:1000                                    ;

   50 A:1000                                     .include "symbols.inc"

symbols.inc

    1 A:1000                                    ; common symbol definitions, borrowed from
    2 A:1000                                    ; 1979 Apple ][ Reference Manual, Monitor ROM Listing

    4 A:1000                                    loc0=$00
    5 A:1000                                    loc1=$01
    6 A:1000                                    wndlft=$20
    7 A:1000                                    wndwdth=$21
    8 A:1000                                    wndtop=$22
    9 A:1000                                    wndbtm=$23
   10 A:1000                                    ch=$24
   11 A:1000                                    cv=$25
   12 A:1000                                    tpdir=$26
   13 A:1000                                    h2=$2c
   14 A:1000                                    lmnem=$2c
   15 A:1000                                    rtnl=$2c
   16 A:1000                                    v2=$2d
   17 A:1000                                    rmnem=$2d
   18 A:1000                                    rtnh=$2d
   19 A:1000                                    mask=$2e
   20 A:1000                                    chksum=$2e
   21 A:1000                                    format=$2e
   22 A:1000                                    lastin=$2f
   23 A:1000                                    length=$2f
   24 A:1000                                    sign=$2f
   25 A:1000                                    color=$30
   26 A:1000                                    mode=$31
   27 A:1000                                    invflg=$32
   28 A:1000                                    prompt=$33
   29 A:1000                                    ysav=$34
   30 A:1000                                    ysav1=$35
   31 A:1000                                    cswl=$36           ; CSW character out vector
   32 A:1000                                    cswh=$37
   33 A:1000                                    kswl=$38           ; keyboard input vector
   34 A:1000                                    kswh=$39
   35 A:1000                                    pcl=$3a
   36 A:1000                                    pch=$3b
   37 A:1000                                    xqt=$3c
   38 A:1000                                    xqtnz=$3c
   39 A:1000                                    a1l=$3c
   40 A:1000                                    a1h=$3d
   41 A:1000                                    a2l=$3e
   42 A:1000                                    a2h=$3f
   43 A:1000                                    a3l=$40
   44 A:1000                                    a3h=$41
   45 A:1000                                    a4l=$42
   46 A:1000                                    a4h=$43
   47 A:1000                                    a5l=$44
   48 A:1000                                    a5h=$45
   49 A:1000                                    acc=$45
   50 A:1000                                    xreg=$46
   51 A:1000                                    yreg=$47
   52 A:1000                                    status=$48
   53 A:1000                                    spnt=$49
   54 A:1000                                    rndl=$4e           ; pseudo-random
   55 A:1000                                    rndh=$4f
   56 A:1000                                    acl=$50
   57 A:1000                                    ach=$51
   58 A:1000                                    xtndl=$52
   59 A:1000                                    xtndh=$53
   60 A:1000                                    auxl=$54
   61 A:1000                                    auxh=$55
   62 A:1000                                    in=$0200           ; input buffer base
   63 A:1000                                    usradr=$03f8
   64 A:1000                                    nmiloc=$03fb
   65 A:1000                                    irqloc=$03fe
   66 A:1000                                    ioadr=$c000
   67 A:1000                                    kbd=$c000
   68 A:1000                                    kbdstrb=$c001
   69 A:1000                                    termcy=$c010           ; terminal cursor y   RW
   70 A:1000                                    termcx=$c011           ; terminal cursor x   RW
   71 A:1000                                    termout=$c012           ; termout character under cursor RW
   72 A:1000                                    termesc=$c013           ; terminal connamd byte W
   73 A:1000                                    termea1=$c014           ; terminal command argl   (bad design, will change)
   74 A:1000                                    termea2=$c015           ; terminal command argh
   75 A:1000                                    termwh=$c016           ; temrinal window height
   76 A:1000                                    termww=$c017           ; terminal window width

   78 A:1000                                    tapeout=$c020
   79 A:1000                                    tapein=$c021
   80 A:1000                                    tapecls=$c022
   81 A:1000                                    spkr=$c030
   82 A:1000                                    paddl0=$c061
   83 A:1000                                    ptrig=$c070

   85 A:1000                                    ;
   86 A:1000                                    ;  Ecape commands for terminal
   86 A:1000                                    
   87 A:1000                                    ;
   88 A:1000                                    t_cls=$00           ; Clear screen
   89 A:1000                                    t_cll=$01           ; clear from cursor to end of line
   90 A:1000                                    t_clb=$02           ; clear from cursor to end of line
   91 A:1000                                    t_scr=$03           ; scroll one line up
   92 A:1000                                    t_norm=$04           ; normal chars
   93 A:1000                                    t_inv=$05           ; inverse chars
   94 A:1000                                    t_blnk=$06           ; blinking chars
   95 A:1000                                    t_qcch=$07           ; query current character under cursor

   97 A:1000                                    ; t_qy    = $04   ; query terminal cursor y; for result read terminl,h
   98 A:1000                                    ; t_qx    = $05   ; query terminal cursor x; for result read terminl,h

  100 A:1000                                    ; characters
  101 A:1000                                    k_ctl_a=$01
  102 A:1000                                    k_ctl_b=$02
  103 A:1000                                    k_ctl_c=$03
  104 A:1000                                    k_ctl_d=$04
  105 A:1000                                    k_ctl_e=$05
  106 A:1000                                    k_ctl_f=$06
  107 A:1000                                    k_ctl_g=$07
  108 A:1000                                    k_bs=$08
  109 A:1000                                    k_tab=$09
  110 A:1000                                    k_lf=$0a
  111 A:1000                                    k_ctl_k=$0b
  112 A:1000                                    k_ctl_l=$0c
  113 A:1000                                    k_cr=$0a
  114 A:1000                                    k_ctl_n=$0e
  115 A:1000                                    k_ctl_o=$0f
  116 A:1000                                    k_ctl_p=$10
  117 A:1000                                    k_ctl_q=$11
  118 A:1000                                    k_ctl_r=$12
  119 A:1000                                    k_ctl_s=$13
  120 A:1000                                    k_ctl_t=$14
  121 A:1000                                    k_ctl_u=$15
  122 A:1000                                    k_ctl_v=$16
  123 A:1000                                    k_ctl_w=$17
  124 A:1000                                    k_ctl_x=$18
  125 A:1000                                    k_ctl_y=$19
  126 A:1000                                    k_ctl_z=$1a
  127 A:1000                                    k_esc=$1b
  128 A:1000                                    k_entr=k_cr
  129 A:1000                                    gr_top='+'
  130 A:1000                                    gr_btm='_'
  131 A:1000                                    gr_grid=$61

rom.s

    1 A:1000                                     *= $d000              ; ROM start address

   52 A:d000  00 ff 00 10 00 24 2c ...           .dsb $1000,$00        ; first filler, 4KB low ROM
   53 A:e000                           lang      
   53 A:e000  20 06 e0                           jsr lang_init
   54 A:e003                           lang2     
   54 A:e003  4c 07 e0                           jmp lang_cont
   55 A:e006                           lang_init 
   55 A:e006  60                                 rts 
   56 A:e007                           lang_cont 
   56 A:e007  00 ff 00 18 00 24 2c ...           .dsb $1800,$00        ; filler up to F800
   57 A:f807                                    ;
   58 A:f807                                    ;  SPACE FREE in last 4k
   59 A:f807                                    ;
   60 A:f807                           keep_aligned 
   60 A:f807                                    
   61 A:f807  00 ff a8 00 00 24 f8 ...           .dsb $a8              ; blank must be on page $FE for jump table to work

   63 A:f8af                           nxtcol    
   63 A:f8af  a5 30                              lda color                ; increment color by 3
   64 A:f8b1  18                                 clc 
   65 A:f8b2  69 03                              adc #$03
   66 A:f8b4                           setcol    
   66 A:f8b4  29 0f                              and #$0f             ; sets color = 17*A mod 16
   67 A:f8b6  85 30                              sta color
   68 A:f8b8  0a                                 asl 
   69 A:f8b9  0a                                 asl 
   70 A:f8ba  0a                                 asl 
   71 A:f8bb  0a                                 asl                    ; << 4 = *16
   72 A:f8bc  05 30                              ora color                ; + 1
   73 A:f8be  85 30                              sta color
   74 A:f8c0  60                                 rts 
   75 A:f8c1                           selnibl   
   75 A:f8c1  90 04                              bcc rtmaskz                ; if even, use low nibble else use high nibble (was scrn2)
   76 A:f8c3  4a                                 lsr 
   77 A:f8c4  4a                                 lsr 
   78 A:f8c5  4a                                 lsr                    ; shift high nibble into low nibble
   79 A:f8c6  4a                                 lsr 
   80 A:f8c7                           rtmaskz   
   80 A:f8c7  29 0f                              and #$0f             ; mask lower 4 bits
   81 A:f8c9  60                                 rts 
   82 A:f8ca                           insds1    
   82 A:f8ca  a6 3a                              ldx pcl                ; print pcl,h
   83 A:f8cc  a4 3b                              ldy pch
   84 A:f8ce  20 90 fd                           jsr pryx2
   85 A:f8d1  20 90 f9                           jsr prblnk                ; followed by a blank
   86 A:f8d4  a1 3a                              lda (pcl,x)
   87 A:f8d6                           insds2    
   87 A:f8d6  a8                                 tay 
   88 A:f8d7  4a                                 lsr                    ; even / odd test
   89 A:f8d8  90 09                              bcc ieven
   90 A:f8da  6a                                 ror                    ; bit 1 test
   91 A:f8db  b0 10                              bcs err                ; xxxxxx11 invalid opcode
   92 A:f8dd  c9 a2                              cmp #$a2
   93 A:f8df  f0 0c                              beq err                ; opcode 89 invalid
   94 A:f8e1  29 87                              and #$87             ; mask bits
   95 A:f8e3                           ieven     
   95 A:f8e3  4a                                 lsr                    ; lsb into carry for l/r test
   96 A:f8e4  aa                                 tax 
   97 A:f8e5  bd aa f9                           lda fmt1,x              ; get format index byte
   98 A:f8e8  20 c1 f8                           jsr selnibl                ; r/l h-byte on carry
   99 A:f8eb  d0 04                              bne getfmt
  100 A:f8ed                           err       
  100 A:f8ed  a0 80                              ldy #$80             ; substitute $80 for invalid ops
  101 A:f8ef  a9 00                              lda #$00             ; set print format index to 0
  102 A:f8f1                           getfmt    
  102 A:f8f1  aa                                 tax 
  103 A:f8f2  bd ee f9                           lda fmt2,x              ; index into print format table
  104 A:f8f5  85 2e                              sta format                ; save for addr field formatting
  105 A:f8f7  29 03                              and #$03             ; mask for 2-bit length
  106 A:f8f9                                    ; (P=1 byte, 1=2 byte, 2=3 byte)
  107 A:f8f9  85 2f                              sta length
  108 A:f8fb  98                                 tya                    ; opcode
  109 A:f8fc  29 8f                              and #$8f             ; mask for 1xxx1010 test
  110 A:f8fe  aa                                 tax                    ;  save it
  111 A:f8ff  98                                 tya                    ; opcode to a again
  112 A:f900  a0 03                              ldy #$03
  113 A:f902  e0 8a                              cpx #$8a
  114 A:f904  f0 0b                              beq mnndx3
  115 A:f906                           mnndx1    
  115 A:f906  4a                                 lsr 
  116 A:f907  90 08                              bcc mnndx3                ; form index into mnemonic tble
  117 A:f909  4a                                 lsr 
  118 A:f90a                           mnndx2    
  118 A:f90a  4a                                 lsr                    ; 1)  1xxx1010 => 00101xxx
  119 A:f90b  09 20                              ora #$20             ; 2)  xxxyyy01 => 00111xxx
  120 A:f90d  88                                 dey                    ; 3)  xxxyyy10 => 00110xxx
  121 A:f90e  d0 fa                              bne mnndx2                ; 4)  xxxyy100 => 00100xxx
  122 A:f910  c8                                 iny                    ; 5)  xxxxx000 => 000xxxxx
  123 A:f911                           mnndx3    
  123 A:f911  88                                 dey 
  124 A:f912  d0 f2                              bne mnndx1
  125 A:f914  60                                 rts 
  126 A:f915  ff ff ff                           .byt $ff,$ff,$ff  ; ???
  127 A:f918                           instdsp   
  127 A:f918  20 ca f8                           jsr insds1                ; gen fmt, len bytes
  128 A:f91b  48                                 pha                    ; save mnemonic table index
  129 A:f91c                           prntop    
  129 A:f91c  b1 3a                              lda (pcl),y
  130 A:f91e  20 d4 fd                           jsr prbyte
  131 A:f921  a2 01                              ldx #$01             ; print 2 blanks
  132 A:f923                           prntbl    
  132 A:f923  20 92 f9                           jsr prbl2
  133 A:f926  c4 2f                              cpy length                ; print inst (1-3 bytes)
  134 A:f928  c8                                 iny                    ; in a 12 char field
  135 A:f929  90 f1                              bcc prntop
  136 A:f92b  a2 03                              ldx #$03             ; char count for mnemonic print
  137 A:f92d  c0 04                              cpy #$04
  138 A:f92f  90 f2                              bcc prntbl
  139 A:f931  68                                 pla                    ; recover mnemonic index
  140 A:f932  a8                                 tay 
  141 A:f933  b9 08 fa                           lda mneml,y
  142 A:f936  85 2c                              sta lmnem                ; fetch 3 char mnemonic
  143 A:f938  b9 48 fa                           lda mnemr,y              ;   (packed in 2 bytes, only chars A-Z
  144 A:f93b  85 2d                              sta rmnem
  145 A:f93d                           prmn1     
  145 A:f93d  a9 00                              lda #$00
  146 A:f93f  a0 05                              ldy #$05
  147 A:f941                           prnm2     
  147 A:f941  06 2d                              asl rmnem                ; shift 5 bits of
  148 A:f943  26 2c                              rol lmnem                ;   character into Accu
  149 A:f945  2a                                 rol                    ;      (clears carry)
  150 A:f946  88                                 dey 
  151 A:f947  d0 f8                              bne prnm2
  152 A:f949  69 3f                              adc #'?'             ; add "?" offset
  153 A:f94b  20 e7 fd                           jsr cout                ; output a char of mnem
  154 A:f94e  ca                                 dex 
  155 A:f94f  d0 ec                              bne prmn1
  156 A:f951  20 90 f9                           jsr prblnk                ; output 3 blanks
  157 A:f954  a4 2f                              ldy length
  158 A:f956  a2 06                              ldx #$06             ; count for 6 format bits
  159 A:f958                           pradr1    
  159 A:f958  e0 03                              cpx #$03
  160 A:f95a  f0 1c                              beq pradr5                ; if x=3 then addr
  161 A:f95c                           pradr2    
  161 A:f95c  06 2e                              asl format
  162 A:f95e  90 0e                              bcc pradr3
  163 A:f960  bd fb f9                           lda char1-1,x
  164 A:f963  20 e7 fd                           jsr cout
  165 A:f966  bd 01 fa                           lda char2-1,x
  166 A:f969  f0 03                              beq pradr3
  167 A:f96b  20 e7 fd                           jsr cout
  168 A:f96e                           pradr3    
  168 A:f96e  ca                                 dex 
  169 A:f96f  d0 e7                              bne pradr1
  170 A:f971  60                                 rts 
  171 A:f972                           pradr4    
  171 A:f972  88                                 dey 
  172 A:f973  30 e7                              bmi pradr2
  173 A:f975  20 d4 fd                           jsr prbyte
  174 A:f978                           pradr5    
  174 A:f978  a5 2e                              lda format
  175 A:f97a  c9 e8                              cmp #$e8             ; handle relative address mode
  176 A:f97c  b1 3a                              lda (pcl),y            ;  special (print target, not offset)
  177 A:f97e  90 f2                              bcc pradr4
  178 A:f980                           reladr    
  178 A:f980  20 9e f9                           jsr pcadj3
  179 A:f983  aa                                 tax                    ; pcl,pch+offset+1 to a,y
  180 A:f984  e8                                 inx 
  181 A:f985  d0 01                              bne prntyx                ; +1 to y,x
  182 A:f987  c8                                 iny 
  183 A:f988                                    ;
  184 A:f988                                    ; print y and x  as 4 digit hex number
  185 A:f988                                    ;
  186 A:f988                           prntyx    
  186 A:f988  98                                 tya 
  187 A:f989                           prntax    
  187 A:f989  20 d4 fd                           jsr prbyte                ; output target adr
  188 A:f98c                           prntx     
  188 A:f98c  8a                                 txa                    ;    of branch and return
  189 A:f98d  4c d4 fd                           jmp prbyte
  190 A:f990                           prblnk    
  190 A:f990  a2 03                              ldx #$03             ; blank count
  191 A:f992                           prbl2     
  191 A:f992  a9 20                              lda #' '             ; load a space
  192 A:f994                           prbl3     
  192 A:f994  20 e7 fd                           jsr cout                ; output a blank
  193 A:f997  ca                                 dex 
  194 A:f998  d0 f8                              bne prbl2
  195 A:f99a  60                                 rts 
  196 A:f99b                           pcadj     
  196 A:f99b  38                                 sec                    ; 0=1-byte, 1=2-byte,
  197 A:f99c                           pcadj2    
  197 A:f99c  a5 2f                              lda length                ;   2=3-byte
  198 A:f99e                           pcadj3    
  198 A:f99e  a4 3b                              ldy pch
  199 A:f9a0  aa                                 tax                    ; test displacement sign
  200 A:f9a1  10 01                              bpl pcadj4                ;   (for rel branch)
  201 A:f9a3  88                                 dey 
  202 A:f9a4                           pcadj4    
  202 A:f9a4  65 3a                              adc pcl
  203 A:f9a6  90 01                              bcc rts2                ; pcl+LENGTH(or Displc.)+1 to A
  204 A:f9a8  c8                                 iny                    ;   carry inot y (pch)
  205 A:f9a9                           rts2      
  205 A:f9a9  60                                 rts 
  206 A:f9aa                                    ;
  207 A:f9aa                                    ; fmt1 bytes
  207 A:f9aa                           XXXXXXY0 instructions 
  208 A:f9aa                                    ;       if Y=0
  208 A:f9aa                           then left half byte 
  209 A:f9aa                                    ;       if Y=1  then right half byte
  210 A:f9aa                                    ;                    (X=index)
  211 A:f9aa                           fmt1      
  211 A:f9aa  04 20 54 30 0d                     .byt $04,$20,$54,$30,$0d
  212 A:f9af  80 04 90 03 22                     .byt $80,$04,$90,$03,$22
  213 A:f9b4  54 33 0d 80 04                     .byt $54,$33,$0d,$80,$04
  214 A:f9b9  90 04 20 54 33                     .byt $90,$04,$20,$54,$33
  215 A:f9be  0d 80 04 90 04                     .byt $0d,$80,$04,$90,$04
  216 A:f9c3  20 54 3b 0d 80                     .byt $20,$54,$3b,$0d,$80
  217 A:f9c8  04 90 00 22 44                     .byt $04,$90,$00,$22,$44
  218 A:f9cd  33 0d c8 44 00                     .byt $33,$0d,$c8,$44,$00
  219 A:f9d2  11 22 44 33 0d                     .byt $11,$22,$44,$33,$0d
  220 A:f9d7  c8 44 a9 01 22                     .byt $c8,$44,$a9,$01,$22
  221 A:f9dc  44 33 0d 80 04                     .byt $44,$33,$0d,$80,$04
  222 A:f9e1  90 01 22 44 33                     .byt $90,$01,$22,$44,$33
  223 A:f9e6  0d 80 04 90                        .byt $0d,$80,$04,$90
  224 A:f9ea  26 31 87 9a                        .byt $26,$31,$87,$9a; ZZXXXXY01 instructions
  225 A:f9ee                           fmt2      
  225 A:f9ee  00                                 .byt $00              ; ERR
  226 A:f9ef  21                                 .byt $21              ; IMM
  227 A:f9f0  81                                 .byt $81              ; Z-PAGE
  228 A:f9f1  82                                 .byt $82              ; ABS
  229 A:f9f2  00                                 .byt $00              ; IMPLIED
  230 A:f9f3  00                                 .byt $00              ; ACCUMULATOR
  231 A:f9f4  59                                 .byt $59              ; (ZPAG,X)
  232 A:f9f5  4d                                 .byt $4d              ; (ZPAG),Y
  233 A:f9f6  91                                 .byt $91              ; ZPAG,X
  234 A:f9f7  92                                 .byt $92              ; ABS,X
  235 A:f9f8  86                                 .byt $86              ; ABS,Y
  236 A:f9f9  4a                                 .byt $4a              ; (ABS)
  237 A:f9fa  85                                 .byt $85              ; ZPAG,Y
  238 A:f9fb  9d                                 .byt $9d              ; RELATIVE
  239 A:f9fc                           char1     
  239 A:f9fc  2c 29 2c 23 28 24                  .byt ',',')',',','#','(','$'
  240 A:fa02                           char2     
  240 A:fa02  59 00 58 24 24 00                  .byt 'Y',0,"X$$",0
  241 A:fa08                                    ;
  242 A:fa08                                    ; mneml is of form
  242 A:fa08                                    
  243 A:fa08                                    ; (A) XXXXX000
  244 A:fa08                                    ; (B) XXXYY100
  245 A:fa08                                    ; (C) 1XXX1010
  246 A:fa08                                    ; (D) XXXYYY10
  247 A:fa08                                    ; (E) XXXYYY01
  248 A:fa08                                    ;     (X=index)
  249 A:fa08                           mneml     
  249 A:fa08  1c 8a 1c 23 5d 8b                  .byt $1c,$8a,$1c,$23,$5d,$8b
  250 A:fa0e  1b a1 9d 8a 1d 23                  .byt $1b,$a1,$9d,$8a,$1d,$23
  251 A:fa14  9d 8b 1d a1 00 29                  .byt $9d,$8b,$1d,$a1,$00,$29
  252 A:fa1a  19 ae 69 a8 19 23                  .byt $19,$ae,$69,$a8,$19,$23
  253 A:fa20  24 53 1b 23 24 53                  .byt $24,$53,$1b,$23,$24,$53
  254 A:fa26  19 a1                              .byt $19,$a1        ; (A) Format Above
  255 A:fa28  00 1a 5b 5b a5 69                  .byt $00,$1a,$5b,$5b,$a5,$69
  256 A:fa2e  24 24                              .byt $24,$24        ; (B) Format
  257 A:fa30  ae ae a8 ad 29 00                  .byt $ae,$ae,$a8,$ad,$29,$00
  258 A:fa36  7c 00                              .byt $7c,$00        ; (C) Format
  259 A:fa38  15 9c 6d 9c a5 69                  .byt $15,$9c,$6d,$9c,$a5,$69
  260 A:fa3e  29 53                              .byt $29,$53        ; (D) Format
  261 A:fa40  84 13 34 11 a5 69                  .byt $84,$13,$34,$11,$a5,$69
  262 A:fa46  23 a0                              .byt $23,$a0        ; (E) Format
  263 A:fa48                           mnemr     
  263 A:fa48  d8 62 5a 48 26 62                  .byt $d8,$62,$5a,$48,$26,$62
  264 A:fa4e  94 88 54 44 c8 54                  .byt $94,$88,$54,$44,$c8,$54
  265 A:fa54  68 44 e8 94 00 b4                  .byt $68,$44,$e8,$94,$00,$b4
  266 A:fa5a  08 84 74 b4 28 6e                  .byt $08,$84,$74,$b4,$28,$6e
  267 A:fa60  74 f4 cc 4a 72 f2                  .byt $74,$f4,$cc,$4a,$72,$f2
  268 A:fa66  a4 8a                              .byt $a4,$8a        ; (A) Format
  269 A:fa68  00 aa a2 a2 74 74                  .byt $00,$aa,$a2,$a2,$74,$74
  270 A:fa6e  74 72                              .byt $74,$72        ; (B) Format
  271 A:fa70  44 68 b2 32 b2 00                  .byt $44,$68,$b2,$32,$b2,$00
  272 A:fa76  22 00                              .byt $22,$00        ; (C) Format
  273 A:fa78  1a 1a 26 26 72 72                  .byt $1a,$1a,$26,$26,$72,$72
  274 A:fa7e  88 c8                              .byt $88,$c8        ; (D) Format
  275 A:fa80  c4 ca 26 48 44 44                  .byt $c4,$ca,$26,$48,$44,$44
  276 A:fa86  a2 c8                              .byt $a2,$c8        ; (E) Format
  277 A:fa88  ff ff ff                           .byt $ff,$ff,$ff
  278 A:fa8b                                    ;
  279 A:fa8b                                    ; monitor stepping
  280 A:fa8b                                    ; this is nice... it emulates itself to execute a program stepwise
  281 A:fa8b                                    ;
  282 A:fa8b                           step      
  282 A:fa8b  20 18 f9                           jsr instdsp                ; disassemble one instruction
  283 A:fa8e  68                                 pla                    ;   at (pcl,h)
  284 A:fa8f  85 2c                              sta rtnl                ; adjust to user
  285 A:fa91  68                                 pla                    ;   stack, save
  286 A:fa92  85 2d                              sta rtnh                ;   return address
  287 A:fa94  a2 08                              ldx #$08
  288 A:fa96                           xqinit    
  288 A:fa96  bd 58 fb                           lda initbl-1,x        ; init xeq (execute) area
  289 A:fa99  95 3c                              sta xqt,x
  290 A:fa9b  ca                                 dex 
  291 A:fa9c  d0 f8                              bne xqinit
  292 A:fa9e  a1 3a                              lda (pcl,x)            ; user opcode byte
  293 A:faa0  f0 42                              beq xbrk                ; special if BRK
  294 A:faa2  a4 2f                              ldy length                ; LEN from disassembly
  295 A:faa4  c9 20                              cmp #$20
  296 A:faa6  f0 59                              beq xjsr                ; handle jsr, rts, jmp,
  297 A:faa8  c9 60                              cmp #$60             ;   jmp (), rti special
  298 A:faaa  f0 45                              beq xrts
  299 A:faac  c9 4c                              cmp #$4c
  300 A:faae  f0 5c                              beq xjmp
  301 A:fab0  c9 6c                              cmp #$6c
  302 A:fab2  f0 59                              beq xjmpat
  303 A:fab4  c9 40                              cmp #$40
  304 A:fab6  f0 35                              beq xrti
  305 A:fab8  29 1f                              and #$1f             ; TODO comment
  306 A:faba  49 14                              eor #$14
  307 A:fabc  c9 04                              cmp #$04             ; copy user instruction to xeq area
  308 A:fabe  f0 02                              beq xq2                ;   with trailing nops
  309 A:fac0                           xq1       
  309 A:fac0  b1 3a                              lda (pcl),y            ; change rel branch
  310 A:fac2                           xq2       
  310 A:fac2  99 3c 00                           sta xqtnz,y              ;   disp to 4 for
  311 A:fac5  88                                 dey                    ;   jmp to branch or
  312 A:fac6  10 f8                              bpl xq1                ;   nbranch from xeq
  313 A:fac8  20 3f ff                           jsr restore                ; restore user reg contents
  314 A:facb  4c 3c 00                           jmp xqtnz                ; xeq (execute) user op from RAM
  315 A:face                           irqvec    
  315 A:face  85 45                              sta acc                ;    (return to nbranch)
  316 A:fad0  68                                 pla                    ; fetch p status register into a
  317 A:fad1  48                                 pha                    ; * * IRQ handler
  318 A:fad2  0a                                 asl 
  319 A:fad3  0a                                 asl 
  320 A:fad4  0a                                 asl                    ; put B flag in high bit
  321 A:fad5  30 03                              bmi break                ; if set, handle BRK
  322 A:fad7  6c fe 03                           jmp (irqloc)              ; user routine vector in RAM
  323 A:fada                           break     
  323 A:fada  28                                 plp 
  324 A:fadb  20 4c ff                           jsr sav1                ; save regs on break
  325 A:fade  68                                 pla                    ; including pc
  326 A:fadf  85 3a                              sta pcl
  327 A:fae1  68                                 pla 
  328 A:fae2  85 3b                              sta pch
  329 A:fae4                           xbrk      
  329 A:fae4  20 ca f8                           jsr insds1                ; print user pc
  330 A:fae7  20 22 fb                           jsr rgdsp1                ;   and registers
  331 A:faea  4c 65 ff                           jmp mon                ; go to monitor
  332 A:faed                           xrti      
  332 A:faed  18                                 clc 
  333 A:faee  68                                 pla                    ; simulate rti by expecting
  334 A:faef  85 48                              sta status                ;    status from stack, then rts
  335 A:faf1                           xrts      
  335 A:faf1  68                                 pla                    ; rts simulation
  336 A:faf2  85 3a                              sta pcl                ;   extract pc from stack
  337 A:faf4  68                                 pla                    ; and update pc by 1 (LEN=0)
  338 A:faf5                           pcinc2    
  338 A:faf5  85 3b                              sta pch
  339 A:faf7                           pcinc3    
  339 A:faf7  a5 2f                              lda length                ; update pc by LEN
  340 A:faf9  20 9e f9                           jsr pcadj3
  341 A:fafc  84 3b                              sty pch
  342 A:fafe  18                                 clc                    ; short unconditional jump
  343 A:faff  90 14                              bcc newpcl                ;  CLC BCC #rel
  344 A:fb01                           xjsr      
  344 A:fb01  18                                 clc 
  345 A:fb02  20 9c f9                           jsr pcadj2                ; update pc and push
  346 A:fb05  aa                                 tax                    ;   onto stack for
  347 A:fb06  98                                 tya                    ;   JSR simulate
  348 A:fb07  48                                 pha 
  349 A:fb08  8a                                 txa 
  350 A:fb09  48                                 pha 
  351 A:fb0a  a0 02                              ldy #$02
  352 A:fb0c                           xjmp      
  352 A:fb0c  18                                 clc 
  353 A:fb0d                           xjmpat    
  353 A:fb0d  b1 3a                              lda (pcl),Y
  354 A:fb0f  aa                                 tax                    ; load pc for jump,
  355 A:fb10  88                                 dey                    ;   (JMP) simulate
  356 A:fb11  b1 3a                              lda (pcl),y
  357 A:fb13  86 3b                              stx pch
  358 A:fb15                           newpcl    
  358 A:fb15  85 3a                              sta pcl
  359 A:fb17  b0 f3                              bcs xjmp
  360 A:fb19                           rtnjmp    
  360 A:fb19  a5 2d                              lda rtnh
  361 A:fb1b  48                                 pha 
  362 A:fb1c  a5 2c                              lda rtnl
  363 A:fb1e  48                                 pha 
  364 A:fb1f                           regdsp    
  364 A:fb1f  20 88 fd                           jsr crout                ; display user reg
  365 A:fb22                           rgdsp1    
  365 A:fb22  a9 45                              lda #<acc              ;  contents with
  366 A:fb24  85 40                              sta a3l                ;  labels
  367 A:fb26  a9 00                              lda #>acc
  368 A:fb28  85 41                              sta a3h
  369 A:fb2a  a2 fb                              ldx #$fb
  370 A:fb2c                           rdsp1     
  370 A:fb2c  a9 20                              lda #' '
  371 A:fb2e  20 e7 fd                           jsr cout                ; output space
  372 A:fb31  bd 66 fa                           lda rtbl-$fb,x        ; register name (x has FB so base address = rtbl - FB)
  373 A:fb34  20 e7 fd                           jsr cout
  374 A:fb37  a9 3d                              lda #'='             ; '='
  375 A:fb39  20 e7 fd                           jsr cout
  376 A:fb3c  b5 4a                              lda acc+5,x
  377 A:fb3e  20 d4 fd                           jsr prbyte
  378 A:fb41  e8                                 inx 
  379 A:fb42  30 e8                              bmi rdsp1
  380 A:fb44  60                                 rts 
  381 A:fb45                           branch    
  381 A:fb45  18                                 clc                    ; branch taken,
  382 A:fb46  a0 01                              ldy #$01             ;  add LEN+2 to pc
  383 A:fb48  b1 3a                              lda (pcl),y
  384 A:fb4a  20 9e f9                           jsr pcadj3
  385 A:fb4d  85 3a                              sta pcl
  386 A:fb4f  98                                 tya 
  387 A:fb50  38                                 sec 
  388 A:fb51  b0 a2                              bcs pcinc2
  389 A:fb53                           nbranch   
  389 A:fb53  20 4a ff                           jsr save                ; normal return after
  390 A:fb56  38                                 sec                    ;   xeq user of
  391 A:fb57  b0 9e                              bcs pcinc3                ; go update pc
  392 A:fb59                           initbl    
  392 A:fb59  ea                                 nop 
  393 A:fb5a  ea                                 nop                    ; dummy fill for
  394 A:fb5b  4c 53 fb                           jmp nbranch                ;   xeq area
  395 A:fb5e  4c 45 fb                           jmp branch
  396 A:fb61                           rtbl      
  396 A:fb61  c1                                 .byt $c1              ; 'A'
  397 A:fb62  d8                                 .byt $d8              ; 'X'
  398 A:fb63  d9                                 .byt $d9              ; 'Y'
  399 A:fb64  d0                                 .byt $d0              ; 'P'
  400 A:fb65  d3                                 .byt $d3              ; 'S'
  401 A:fb66                           pread     
  401 A:fb66  ad 70 c0                           lda ptrig                ; paddle read; trigger paddles
  402 A:fb69  a0 00                              ldy #$00             ; init count
  403 A:fb6b  ea                                 nop                    ; compensate timing for first count
  404 A:fb6c  ea                                 nop                    ; 2 x 2 cycles
  405 A:fb6d                           pread2    
  405 A:fb6d  bd 61 c0                           lda paddl0,x              ; count y-reg
  406 A:fb70  10 04                              bpl rts2d                ;    every 12 usec
  407 A:fb72  c8                                 iny 
  408 A:fb73  d0 f8                              bne pread2                ;    exit at 255 max
  409 A:fb75  88                                 dey 
  410 A:fb76                           rts2d     
  410 A:fb76  60                                 rts 
  411 A:fb77                           init      
  411 A:fb77  a9 00                              lda #$00             ; clr status for debug
  412 A:fb79  85 48                              sta status                ;   software
  413 A:fb7b                           settxt    
  413 A:fb7b  a9 00                              lda #$00             ;   full screen window
  414 A:fb7d                           setwnd    
  414 A:fb7d  85 22                              sta wndtop                ; set for 40 col window
  415 A:fb7f  a9 00                              lda #$00             ;    top in accu,
  416 A:fb81  85 20                              sta wndlft                ;    bottom at line 24
  417 A:fb83  ad 17 c0                           lda termww                ; get terminal window width
  418 A:fb86  85 21                              sta wndwdth
  419 A:fb88  ad 16 c0                           lda termwh                ; get terminal window height
  420 A:fb8b  85 23                              sta wndbtm
  421 A:fb8d  38                                 sec 
  422 A:fb8e  e9 01                              sbc #$01             ; last possible row in window
  423 A:fb90                           tabv      
  423 A:fb90  85 25                              sta cv                ; vtabs to row in accu
  424 A:fb92  60                                 rts 
  425 A:fb93                           mulpm     
  425 A:fb93  20 d7 fb                           jsr md1                ; abs value of ac, aux
  426 A:fb96                           mul       
  426 A:fb96  a0 10                              ldy #$10             ; index for 16 bits
  427 A:fb98                           mul2      
  427 A:fb98  a5 50                              lda acl                ; acx * aux + xtnd
  428 A:fb9a  4a                                 lsr                    ;  to ac, xtnd
  429 A:fb9b  90 0c                              bcc mul4                ; if no carry,
  430 A:fb9d  18                                 clc                    ;   no partial product
  431 A:fb9e  a2 fe                              ldx #$fe
  432 A:fba0                           mul3      
  432 A:fba0  b5 54                              lda xtndl+2,x        ; add multiplicant (aux)
  433 A:fba2  75 56                              adc auxl+2,x        ;   to partial product
  434 A:fba4  95 54                              sta xtndl+2,x        ;     (xtnd)
  435 A:fba6  e8                                 inx 
  436 A:fba7  d0 f7                              bne mul3
  437 A:fba9                           mul4      
  437 A:fba9  a2 03                              ldx #$03
  438 A:fbab                           mul5      
  438 A:fbab  76 50                              ror acl,x              ; orig DFB #$76, #$50 ?!? maybe a bug in their assembler software
  439 A:fbad  ca                                 dex 
  440 A:fbae  10 fb                              bpl mul5
  441 A:fbb0  88                                 dey 
  442 A:fbb1  d0 e5                              bne mul2
  443 A:fbb3  60                                 rts 
  444 A:fbb4                           divpm     
  444 A:fbb4  20 d7 fb                           jsr md1                ; abs value of ac, aux
  445 A:fbb7                           div       
  445 A:fbb7  a0 10                              ldy #$10             ; index for 16 bits
  446 A:fbb9                           div2      
  446 A:fbb9  06 51                              asl ach
  447 A:fbbb  26 51                              rol ach
  448 A:fbbd  26 52                              rol xtndl                ; xtnd/aux
  449 A:fbbf  26 53                              rol xtndh                ;   to ac.
  450 A:fbc1  38                                 sec 
  451 A:fbc2  a5 52                              lda xtndl
  452 A:fbc4  e5 54                              sbc auxl                ; mod to xtnd
  453 A:fbc6  aa                                 tax 
  454 A:fbc7  a5 53                              lda xtndh
  455 A:fbc9  e5 55                              sbc auxh
  456 A:fbcb  90 06                              bcc div3
  457 A:fbcd  86 52                              stx xtndl
  458 A:fbcf  85 53                              sta xtndh
  459 A:fbd1  e6 50                              inc acl
  460 A:fbd3                           div3      
  460 A:fbd3  88                                 dey 
  461 A:fbd4  d0 e3                              bne div2
  462 A:fbd6  60                                 rts 
  463 A:fbd7                           md1       
  463 A:fbd7  a0 00                              ldy #$00             ; abs value of ac, aux
  464 A:fbd9  84 2f                              sty sign                ;   with result sign
  465 A:fbdb  a2 54                              ldx #auxl               ;   in lsb of sign
  466 A:fbdd  20 e2 fb                           jsr md2
  467 A:fbe0  a2 50                              ldx #acl
  468 A:fbe2                           md2       
  468 A:fbe2  b5 01                              lda loc1,x              ; x specifies ac or aux
  469 A:fbe4  10 0d                              bpl mdrts
  470 A:fbe6  38                                 sec 
  471 A:fbe7                           md3       
  471 A:fbe7  98                                 tya 
  472 A:fbe8  f5 00                              sbc loc0,x              ; compl specified reg
  473 A:fbea  95 00                              sta loc0,x              ;   if negative
  474 A:fbec  98                                 tya 
  475 A:fbed  f5 01                              sbc loc1,x
  476 A:fbef  95 01                              sta loc1,x
  477 A:fbf1  e6 2f                              inc sign
  478 A:fbf3                           mdrts     
  478 A:fbf3  60                                 rts 

  480 A:fbf4                           bell1     
  480 A:fbf4  a9 07                              lda #k_ctl_g               ; output bell and return
  481 A:fbf6  8d 12 c0                           sta termout                ; pit to term directly here...
  482 A:fbf9  60                                 rts 
  483 A:fbfa  ea ff 10 00 00 24 2c ...           .dsb $10,$ea
  484 A:fc0a                           rts2b     
  484 A:fc0a  60                                 rts 
  485 A:fc0b                                    ;
  486 A:fc0b                                    ; Store terminal char output and advance screen cursor
  487 A:fc0b                                    ;
  488 A:fc0b                           stoadv    
  488 A:fc0b  a4 25                              ldy cv                ; cursor y index to y register
  489 A:fc0d  8c 10 c0                           sty termcy                ; set terminal cursor y
  490 A:fc10  a4 24                              ldy ch                ; cursor h index to y register
  491 A:fc12  8c 11 c0                           sty termcx                ; set terminal cursor x
  492 A:fc15  a4 32                              ldy invflg                ;
  493 A:fc17  8c 13 c0                           sty termesc                ; invflg has the command byte for the char attribute normal or reverse
  494 A:fc1a  8d 12 c0                           sta termout                ; output char
  495 A:fc1d                                    ;
  496 A:fc1d                                    ; advance cursor
  497 A:fc1d                                    ;
  498 A:fc1d                                    ; add next line routine if cursor proceeds to right margin
  499 A:fc1d                                    ;
  500 A:fc1d                           advance   
  500 A:fc1d  e6 24                              inc ch                ; increment cursor h index
  501 A:fc1f  a5 24                              lda ch                ;   (move right)
  502 A:fc21  c5 21                              cmp wndwdth                ; beyond window width?
  503 A:fc23  b0 4e                              bcs cr                ;   yes, cr to next line
  504 A:fc25                           rts3      
  504 A:fc25  60                                 rts                    ; no, return
  505 A:fc26                                    ;
  506 A:fc26                                    ; Video out
  507 A:fc26                                    ;
  508 A:fc26                                    ; Write character to terminal I/O
  509 A:fc26                                    ;
  510 A:fc26                           vidout    
  510 A:fc26  c9 20                              cmp #' '             ; control char?
  511 A:fc28  b0 e1                              bcs stoadv                ;   no, output it
  512 A:fc2a  c9 0a                              cmp #k_entr               ; CR?  0x1D | 0x80
  513 A:fc2c  f0 45                              beq cr                ;   yes
  514 A:fc2e  c9 0a                              cmp #k_lf               ; LF?
  515 A:fc30  f0 45                              beq lf                ;   yes
  516 A:fc32  c9 08                              cmp #k_bs               ; backspace (CTRL-H)?
  517 A:fc34  d0 be                              bne bell1                ;   no, check for bell
  518 A:fc36                           bs        
  518 A:fc36  c6 24                              dec ch                ; decrement cursor h index
  519 A:fc38  10 eb                              bpl rts3                ; if pos, ok, else move up
  520 A:fc3a  a5 21                              lda wndwdth                ; set ch to wndwdth-1
  521 A:fc3c  85 24                              sta ch
  522 A:fc3e  c6 24                              dec ch                ; rightmost screen position
  523 A:fc40                           up        
  523 A:fc40  a5 22                              lda wndtop                ; cursor v index
  524 A:fc42  c5 25                              cmp cv
  525 A:fc44  b0 02                              bcs rts4                ; if top line then return
  526 A:fc46  c6 25                              dec cv                ; decr cursor v
  527 A:fc48                           rts4      
  527 A:fc48  60                                 rts 
  528 A:fc49                           esc1      
  528 A:fc49  49 1b                              eor #k_esc               ; esc?
  529 A:fc4b  f0 1c                              beq home                ;   if so, do home and clear
  530 A:fc4d  e9 02                              sbc #$02             ; esc-a or -b check
  531 A:fc4f  30 cc                              bmi advance                ;   a, advance
  532 A:fc51  f0 e3                              beq bs                ;   b, backspace
  533 A:fc53  e9 02                              sbc #$02             ; esc-c or -d check
  534 A:fc55  30 20                              bmi lf                ;   c, down
  535 A:fc57  f0 e7                              beq up                ;   d, go up
  536 A:fc59  e9 02                              sbc #$02             ; esc-e or -f check
  537 A:fc5b  90 2a                              bcc clreol                ;   e, clear to end of line
  538 A:fc5d  d0 e9                              bne rts4                ;   not f, return
  539 A:fc5f                           clreop    
  539 A:fc5f  a4 24                              ldy ch                ; cursor h to y
  540 A:fc61  a5 25                              lda cv                ; cursor v to a
  541 A:fc63                           cleop1    
  541 A:fc63  48                                 pha                    ; save current line on stk
  542 A:fc64  a9 00                              lda #t_cls               ; clear screen command
  543 A:fc66  8d 13 c0                           sta termesc                ; send to terminal
  544 A:fc69                           home      
  544 A:fc69  a5 22                              lda wndtop                ; init cursor v
  545 A:fc6b  85 25                              sta cv                ;   and h-indices
  546 A:fc6d  a0 00                              ldy #$00
  547 A:fc6f  84 24                              sty ch                ; then clear to end of page
  548 A:fc71  f0 f0                              beq cleop1
  549 A:fc73                           cr        
  549 A:fc73  a9 00                              lda #$00             ; cursor to left of index
  550 A:fc75  85 24                              sta ch
  551 A:fc77                           lf        
  551 A:fc77  e6 25                              inc cv                ; incr cursor v (down 1 line)
  552 A:fc79  a5 25                              lda cv
  553 A:fc7b  c5 23                              cmp wndbtm                ; off screen?
  554 A:fc7d  90 c9                              bcc rts4                ;   no, done
  555 A:fc7f  c6 25                              dec cv                ; decr cursor v (back to bottom)
  556 A:fc81                           scroll    
  556 A:fc81  a9 03                              lda #t_scr               ; scroll command
  557 A:fc83  8d 13 c0                           sta termesc                ; let the terminal scroll.
  558 A:fc86  60                                 rts 
  559 A:fc87                           clreol    
  559 A:fc87  a9 01                              lda #t_cll               ; clear to eol command
  560 A:fc89  8d 13 c0                           sta termesc                ; execute
  561 A:fc8c  60                                 rts 
  562 A:fc8d                           wait      
  562 A:fc8d  38                                 sec 
  563 A:fc8e                           wait2     
  563 A:fc8e  48                                 pha 
  564 A:fc8f                           wait3     
  564 A:fc8f  e9 01                              sbc #$01
  565 A:fc91  d0 fc                              bne wait3                ; 1.02.4 uSec
  566 A:fc93  68                                 pla                    ; (13+2712*A+512*A*A) on 1 MHz
  567 A:fc94  e9 01                              sbc #$01
  568 A:fc96  d0 f6                              bne wait2                ; busy, busy, busy waiting
  569 A:fc98  60                                 rts 
  570 A:fc99                           nxta4     
  570 A:fc99  e6 42                              inc a4l                ; incr 2-byte a4
  571 A:fc9b  d0 02                              bne nxta1                ;  and a1
  572 A:fc9d  e6 43                              inc a4h
  573 A:fc9f                           nxta1     
  573 A:fc9f  a5 3c                              lda a1l                ; incr 2-byte a1
  574 A:fca1  c5 3e                              cmp a2l
  575 A:fca3  a5 3d                              lda a1h                ;   and compare to a2
  576 A:fca5  e5 3f                              sbc a2h
  577 A:fca7  e6 3c                              inc a1l                ;  carry set if >=
  578 A:fca9  d0 02                              bne rts4b
  579 A:fcab  e6 3d                              inc a1h
  580 A:fcad                           rts4b     
  580 A:fcad  60                                 rts 
  581 A:fcae                           headr     
  581 A:fcae  a0 4b                              ldy #$4b             ; write A * 256 'long 1'
  582 A:fcb0  20 c0 fc                           jsr zerdly                ;   half cycles
  583 A:fcb3  d0 f9                              bne headr                ;     (650 usec each)
  584 A:fcb5  69 fe                              adc #$fe
  585 A:fcb7  b0 f5                              bcs headr                ; then a 'short 0'
  586 A:fcb9  a0 21                              ldy #$21             ;    (400 usec)
  587 A:fcbb                           wrbit     
  587 A:fcbb  20 c0 fc                           jsr zerdly                ; write two half cycles
  588 A:fcbe  c8                                 iny                    ;   of 250 usec ('0')
  589 A:fcbf  c8                                 iny                    ;   or 500 usec ('0')
  590 A:fcc0                           zerdly    
  590 A:fcc0  88                                 dey                    ; it means 'zero delay'
  591 A:fcc1  d0 fd                              bne zerdly
  592 A:fcc3  90 05                              bcc wrtape                ; y is count for
  593 A:fcc5  a0 32                              ldy #$32             ;   timing loop
  594 A:fcc7                           onedly    
  594 A:fcc7  88                                 dey                    ; 'ones delay'
  595 A:fcc8  d0 fd                              bne onedly
  596 A:fcca                           wrtape    
  596 A:fcca  48                                 pha 
  597 A:fccb  a4 26                              ldy tpdir
  598 A:fccd  b9 20 c0                           lda tapeout,y              ; tape output toggle
  599 A:fcd0  68                                 pla 
  600 A:fcd1  a0 2c                              ldy #$2c
  601 A:fcd3  ca                                 dex 
  602 A:fcd4  60                                 rts 
  603 A:fcd5                           rdbyte    
  603 A:fcd5  a2 08                              ldx #$08             ; 8 bits to read
  604 A:fcd7                           rdbyt2    
  604 A:fcd7  48                                 pha                    ; read two transitions
  605 A:fcd8  20 e3 fc                           jsr rd2bit                ;   (find edge)
  606 A:fcdb  68                                 pla 
  607 A:fcdc  2a                                 rol                    ; next bit
  608 A:fcdd  a0 3a                              ldy #$3a             ; count for samples
  609 A:fcdf  ca                                 dex 
  610 A:fce0  d0 f5                              bne rdbyt2
  611 A:fce2  60                                 rts 
  612 A:fce3                           rd2bit    
  612 A:fce3  20 e6 fc                           jsr rdbit
  613 A:fce6                           rdbit     
  613 A:fce6  88                                 dey                    ; decr y until
  614 A:fce7  ad 21 c0                           lda tapein                ;   tape transition
  615 A:fcea  45 2f                              eor lastin
  616 A:fcec  10 f8                              bpl rdbit
  617 A:fcee  45 2f                              eor lastin
  618 A:fcf0  85 2f                              sta lastin
  619 A:fcf2  c0 80                              cpy #$80             ; set carry on y register
  620 A:fcf4  60                                 rts 
  621 A:fcf5                           charout   
  621 A:fcf5  a4 25                              ldy cv                ; cursor y index to y register
  622 A:fcf7  8c 10 c0                           sty termcy                ; set terminal cursor y
  623 A:fcfa  a4 24                              ldy ch                ; cursor h index to y register
  624 A:fcfc  8c 11 c0                           sty termcx                ; set terminal cursor x
  625 A:fcff  8d 12 c0                           sta termout                ; output char
  626 A:fd02  60                                 rts 
  627 A:fd03                           rdkey     
  627 A:fd03  a0 06                              ldy #t_blnk               ; set screen to flash
  628 A:fd05  8c 13 c0                           sty termesc
  629 A:fd08  ad 12 c0                           lda termout                ; get char at cursor pos.
  630 A:fd0b  20 f5 fc                           jsr charout
  631 A:fd0e  a0 04                              ldy #t_norm               ; set screen back to normal after
  632 A:fd10  8c 13 c0                           sty termesc
  633 A:fd13  6c 38 00                           jmp (kswl)              ; go to user key-in
  634 A:fd16                           keyin     
  634 A:fd16  e6 4e                              inc rndl
  635 A:fd18  d0 02                              bne keyin2                ; inc random number
  636 A:fd1a  e6 4f                              inc rndh
  637 A:fd1c                           keyin2    
  637 A:fd1c  ad 00 c0                           lda kbd
  638 A:fd1f  f0 f5                              beq keyin                ; busy waiting loop until key != 0...
  639 A:fd21  20 f5 fc                           jsr charout                ; replace flashing screen
  640 A:fd24  2c 01 c0                           bit kbdstrb                ; clear key strobe
  641 A:fd27  60                                 rts 
  642 A:fd28                           esc       
  642 A:fd28  20 03 fd                           jsr rdkey                ; get keycode
  643 A:fd2b  20 49 fc                           jsr esc1                ;  handle esc function
  644 A:fd2e                           rdchar    
  644 A:fd2e  20 03 fd                           jsr rdkey                ; read key
  645 A:fd31  c9 1b                              cmp #k_esc               ; ESC?
  646 A:fd33  f0 f3                              beq esc                ;   yes, don't return
  647 A:fd35  60                                 rts 
  648 A:fd36                           notcr     
  648 A:fd36  a5 32                              lda invflg
  649 A:fd38  48                                 pha 
  650 A:fd39  a9 04                              lda #t_norm
  651 A:fd3b  85 32                              sta invflg                ; echo user line
  652 A:fd3d  bd 00 02                           lda in,x              ;   non inverse
  653 A:fd40  20 e7 fd                           jsr cout
  654 A:fd43  68                                 pla 
  655 A:fd44  85 32                              sta invflg
  656 A:fd46  bd 00 02                           lda in,x
  657 A:fd49  c9 08                              cmp #k_bs               ; check for edit keys
  658 A:fd4b  f0 1d                              beq bckspc                ;  bs, ctrl-x
  659 A:fd4d  c9 18                              cmp #k_ctl_x
  660 A:fd4f  f0 0a                              beq cancel
  661 A:fd51  e0 f8                              cpx #$f8             ; margin?
  662 A:fd53  90 03                              bcc notcr1
  663 A:fd55  20 3a ff                           jsr bell                ; yes, sound bell
  664 A:fd58                           notcr1    
  664 A:fd58  e8                                 inx                    ; advance input index
  665 A:fd59  d0 13                              bne nxtchar
  666 A:fd5b                           cancel    
  666 A:fd5b  a9 5c                              lda #'\'             ; backslash after cancelled LTN?
  667 A:fd5d  20 e7 fd                           jsr cout
  668 A:fd60                           getlnz    
  668 A:fd60  20 88 fd                           jsr crout                ; output cr
  669 A:fd63                           getln     
  669 A:fd63  a5 33                              lda prompt
  670 A:fd65  20 e7 fd                           jsr cout                ; output prompt char
  671 A:fd68  a2 01                              ldx #$01             ; init input index
  672 A:fd6a                           bckspc    
  672 A:fd6a  8a                                 txa                    ;   will backspace to u
  673 A:fd6b  f0 f3                              beq getlnz
  674 A:fd6d  ca                                 dex 
  675 A:fd6e                           nxtchar   
  675 A:fd6e  20 2e fd                           jsr rdchar
  676 A:fd71  c9 15                              cmp #k_ctl_u               ; use screen char
  677 A:fd73  d0 03                              bne captst                ;  for ctrl-u
  678 A:fd75  ad 12 c0                           lda termout                ; get char under cursor
  679 A:fd78                           captst    
  679 A:fd78  c9 60                              cmp #$60
  680 A:fd7a  90 02                              bcc addinp                ; convert to caps; for now..
  681 A:fd7c  29 df                              and #$df
  682 A:fd7e                           addinp    
  682 A:fd7e  9d 00 02                           sta in,x              ; add to input buffer
  683 A:fd81  c9 0a                              cmp #k_entr
  684 A:fd83  d0 b1                              bne notcr
  685 A:fd85  20 87 fc                           jsr clreol                ; clear to eol if cr
  686 A:fd88                           crout     
  686 A:fd88  a9 0a                              lda #k_entr
  687 A:fd8a  d0 5b                              bne cout                ; branches always ?!?
  688 A:fd8c                           pra1      
  688 A:fd8c  a4 3d                              ldy a1h                ; print CR,A1 in hex
  689 A:fd8e  a6 3c                              ldx a1l
  690 A:fd90                                    ;
  691 A:fd90                                    ; print address header at start of line
  692 A:fd90                                    ; yyxx-
  693 A:fd90                                    ;
  694 A:fd90                           pryx2     
  694 A:fd90  20 88 fd                           jsr crout
  695 A:fd93  20 88 f9                           jsr prntyx
  696 A:fd96  a0 00                              ldy #$00
  697 A:fd98  a9 2d                              lda #'-'             ; print '-'
  698 A:fd9a  4c e7 fd                           jmp cout
  699 A:fd9d                                    ;
  700 A:fd9d                                    ; Examine 8 bytes at address
  701 A:fd9d                                    ; Triggered by command xxxx.yyyy
  702 A:fd9d                                    ;
  703 A:fd9d                           xam8      
  703 A:fd9d  a5 3c                              lda a1l
  704 A:fd9f  09 07                              ora #$07             ; set to finish at
  705 A:fda1  85 3e                              sta a2l                ;   mod 8=7
  706 A:fda3  a5 3d                              lda a1h
  707 A:fda5  85 3f                              sta a2h
  708 A:fda7                           mod8chk   
  708 A:fda7  a5 3c                              lda a1l
  709 A:fda9  29 07                              and #$07
  710 A:fdab  d0 03                              bne dataout
  711 A:fdad                                    ;
  712 A:fdad                                    ; Examine byte at address
  713 A:fdad                                    ;
  714 A:fdad                           xam       
  714 A:fdad  20 8c fd                           jsr pra1
  715 A:fdb0                           dataout   
  715 A:fdb0  a9 20                              lda #' '
  716 A:fdb2  20 e7 fd                           jsr cout                ; output blank
  717 A:fdb5  b1 3c                              lda (a1l),y
  718 A:fdb7  20 d4 fd                           jsr prbyte                ; print byte in hex
  719 A:fdba  20 9f fc                           jsr nxta1
  720 A:fdbd  90 e8                              bcc mod8chk                ; check if time to,
  721 A:fdbf  60                                 rts                    ;  print address
  722 A:fdc0                           xampm     
  722 A:fdc0  4a                                 lsr                    ; determine if mon
  723 A:fdc1  90 ea                              bcc xam                ;  mode is xam
  724 A:fdc3  4a                                 lsr                    ;  add or sub
  725 A:fdc4  4a                                 lsr 
  726 A:fdc5  a5 3e                              lda a2l
  727 A:fdc7  90 02                              bcc add
  728 A:fdc9  49 ff                              eor #$ff             ; sub - form 2's complement
  729 A:fdcb                           add       
  729 A:fdcb  65 3c                              adc a1l
  730 A:fdcd  48                                 pha 
  731 A:fdce  a9 3d                              lda #'='             ; print '=' the result
  732 A:fdd0  20 e7 fd                           jsr cout
  733 A:fdd3  68                                 pla 
  734 A:fdd4                                    ;
  735 A:fdd4                                    ; print byte as 2 hex digits
  736 A:fdd4                                    ;
  737 A:fdd4                           prbyte    
  737 A:fdd4  48                                 pha                    ; save a for second half
  738 A:fdd5  4a                                 lsr                    ; shift 4 high digits into low nibble, destroys accu
  739 A:fdd6  4a                                 lsr 
  740 A:fdd7  4a                                 lsr 
  741 A:fdd8  4a                                 lsr 
  742 A:fdd9  20 df fd                           jsr prhexz                ; first hex per subroutine,
  743 A:fddc  68                                 pla                    ;   second hex direct, reuse rts for prbyte
  744 A:fddd                           prhex     
  744 A:fddd  29 0f                              and #$0f             ; print hex digit in accu
  745 A:fddf                                    ;
  746 A:fddf                                    ; print lower accu nibble as hex number
  747 A:fddf                                    ;
  748 A:fddf                           prhexz    
  748 A:fddf  09 30                              ora #$30             ;   lsb's
  749 A:fde1  c9 3a                              cmp #$3a
  750 A:fde3  90 02                              bcc cout
  751 A:fde5  69 06                              adc #$06             ; afterwards, flow into cout
  752 A:fde7                                    ;
  753 A:fde7                                    ; Character out to screen
  754 A:fde7                                    ; go through cswl zero page vector
  755 A:fde7                                    ;
  756 A:fde7                           cout      
  756 A:fde7  6c 36 00                           jmp (cswl)              ; vector to user output routine
  757 A:fdea                                    ;
  758 A:fdea                                    ; Standard cswl character out routine
  759 A:fdea                                    ;
  760 A:fdea                           cout1     
  760 A:fdea  84 35                              sty ysav1                ; save the y register
  761 A:fdec  48                                 pha                    ; save A
  762 A:fded  20 26 fc                           jsr vidout                ; output a as ascii
  763 A:fdf0  68                                 pla                    ; restore A
  764 A:fdf1  a4 35                              ldy ysav1                ; restore y and return
  765 A:fdf3  60                                 rts 
  766 A:fdf4                                    ;
  767 A:fdf4                                    ; on blank / return, execute preceding command
  768 A:fdf4                                    ;
  769 A:fdf4                           bli       
  769 A:fdf4  c6 34                              dec ysav
  770 A:fdf6  f0 a5                              beq xam8
  771 A:fdf8                           blank     
  771 A:fdf8  ca                                 dex                    ; blank to mon
  772 A:fdf9  d0 16                              bne setmdz                ; after blank
  773 A:fdfb  c9 3a                              cmp #':'             ; data store mode?
  774 A:fdfd  d0 c1                              bne xampm                ;   no, xam, add or sub
  775 A:fdff                           stor      
  775 A:fdff  85 31                              sta mode                ; keep in store mode
  776 A:fe01  a5 3e                              lda a2l
  777 A:fe03  91 40                              sta (a3l),y            ; store as low byte as (a3)
  778 A:fe05  e6 40                              inc a3l
  779 A:fe07  d0 02                              bne rts5                ; incr a3, return
  780 A:fe09  e6 41                              inc a3h
  781 A:fe0b                           rts5      
  781 A:fe0b  60                                 rts 
  782 A:fe0c                                    ;
  783 A:fe0c                                    ; set the command mode
  784 A:fe0c                                    ;
  785 A:fe0c                           setmode   
  785 A:fe0c  a4 34                              ldy ysav                ; save converted colon, '+',
  786 A:fe0e  b9 ff 01                           lda in-1,y          ;  '-', '.' as mode.
  787 A:fe11                           setmdz    
  787 A:fe11  85 31                              sta mode
  788 A:fe13  60                                 rts 
  789 A:fe14                                    ;
  790 A:fe14                                    ; '<' command for move / verify
  791 A:fe14                                    ; initialize zero page variables for following V/M command
  792 A:fe14                                    ;
  793 A:fe14                           lt        
  793 A:fe14  a2 01                              ldx #$01
  794 A:fe16                           lt2       
  794 A:fe16  b5 3e                              lda a2l,x              ; copy a2 (2 bytes) to
  795 A:fe18  95 42                              sta a4l,x              ;   a4 and a5
  796 A:fe1a  95 44                              sta a5l,x
  797 A:fe1c  ca                                 dex 
  798 A:fe1d  10 f7                              bpl lt2
  799 A:fe1f  60                                 rts 
  800 A:fe20                                    ;
  801 A:fe20                                    ; copy memory range
  802 A:fe20                                    ;
  803 A:fe20                           move      
  803 A:fe20  b1 3c                              lda (a1l),y            ; move (a1 to a2) to
  804 A:fe22  91 42                              sta (a4l),y            ;   (a4)
  805 A:fe24  20 99 fc                           jsr nxta4
  806 A:fe27  90 f7                              bcc move
  807 A:fe29  60                                 rts 
  808 A:fe2a                                    ;
  809 A:fe2a                                    ; verify that two memory ranges have same content
  810 A:fe2a                                    ;
  811 A:fe2a                           vfy       
  811 A:fe2a  b1 3c                              lda (a1l),y            ; verify (a1 to a2) with
  812 A:fe2c  d1 42                              cmp (a4l),y            ;   (a4)
  813 A:fe2e  f0 1c                              beq vfyok
  814 A:fe30  20 8c fd                           jsr pra1
  815 A:fe33  b1 3c                              lda (a1l),y
  816 A:fe35  20 d4 fd                           jsr prbyte
  817 A:fe38  a9 20                              lda #' '             ; space
  818 A:fe3a  20 e7 fd                           jsr cout
  819 A:fe3d  a9 28                              lda #'('             ; '('
  820 A:fe3f  20 e7 fd                           jsr cout
  821 A:fe42  b1 42                              lda (a4l),y
  822 A:fe44  20 d4 fd                           jsr prbyte
  823 A:fe47  a9 29                              lda #')'             ; ')'
  824 A:fe49  20 e7 fd                           jsr cout
  825 A:fe4c                           vfyok     
  825 A:fe4c  20 99 fc                           jsr nxta4
  826 A:fe4f  90 d9                              bcc vfy
  827 A:fe51  60                                 rts 
  828 A:fe52                                    ;
  829 A:fe52                                    ; list memory range as assembler
  830 A:fe52                                    ;
  831 A:fe52                           list      
  831 A:fe52  20 69 fe                           jsr a1pc                ; move a1 (2 bytes) to
  832 A:fe55  a9 14                              lda #$14             ;  pc if specified and
  833 A:fe57                           list2     
  833 A:fe57  48                                 pha                    ;  dissemble 20 instructions
  834 A:fe58  20 18 f9                           jsr instdsp
  835 A:fe5b  20 9b f9                           jsr pcadj                ; adjust pc each instruction
  836 A:fe5e  85 3a                              sta pcl
  837 A:fe60  84 3b                              sty pch
  838 A:fe62  68                                 pla 
  839 A:fe63  38                                 sec 
  840 A:fe64  e9 01                              sbc #$01             ; next 20 instr.
  841 A:fe66  d0 ef                              bne list2
  842 A:fe68  60                                 rts 
  843 A:fe69                           a1pc      
  843 A:fe69  8a                                 txa                    ; if user specified address
  844 A:fe6a  f0 07                              beq a1pcrts                ;   copy from a1 to pc
  845 A:fe6c                           a1pclp    
  845 A:fe6c  b5 3c                              lda a1l,X
  846 A:fe6e  95 3a                              sta pcl,x
  847 A:fe70  ca                                 dex 
  848 A:fe71  10 f9                              bpl a1pclp
  849 A:fe73                           a1pcrts   
  849 A:fe73  60                                 rts 
  850 A:fe74                                    ;
  851 A:fe74                                    ; set inverde character mode
  852 A:fe74                                    ;
  853 A:fe74                           setinv    
  853 A:fe74  a0 05                              ldy #t_inv               ; set for inverse video
  854 A:fe76  d0 02                              bne setiflg
  855 A:fe78                                    ;
  856 A:fe78                                    ; set norml character mode
  857 A:fe78                                    ;
  858 A:fe78                           setnorm   
  858 A:fe78  a0 04                              ldy #t_norm               ; set for normal video
  859 A:fe7a                           setiflg   
  859 A:fe7a  84 32                              sty invflg
  860 A:fe7c  60                                 rts 
  861 A:fe7d                                    ;
  862 A:fe7d                                    ; set input port to standard keyboard
  863 A:fe7d                                    ;
  864 A:fe7d                           setkbd    
  864 A:fe7d  a9 00                              lda #$00             ; simulate port #0 input
  865 A:fe7f                           inport    
  865 A:fe7f  85 3e                              sta a2l                ;   specified (keyin routine)
  866 A:fe81                           inprt     
  866 A:fe81  a2 38                              ldx #kswl
  867 A:fe83  a0 16                              ldy #<keyin              ; see if it is the default vector
  868 A:fe85  d0 08                              bne ioprt
  869 A:fe87                                    ;
  870 A:fe87                                    ; Set output port to standard terminal
  871 A:fe87                                    ;
  872 A:fe87                           setvid    
  872 A:fe87  a9 00                              lda #$00             ; simulate port #0 output
  873 A:fe89                           outport   
  873 A:fe89  85 3e                              sta a2l                ;   specified (cout routine)
  874 A:fe8b                           outprt    
  874 A:fe8b  a2 36                              ldx #cswl
  875 A:fe8d  a0 ea                              ldy #<cout1              ; compare with address of default vector
  876 A:fe8f                           ioprt     
  876 A:fe8f  a5 3e                              lda a2l                ; set ram in/out vectors
  877 A:fe91  29 0f                              and #$0f
  878 A:fe93  f0 06                              beq ioprt1
  879 A:fe95  09 c0                              ora #>ioadr              ; high byte
  880 A:fe97  a0 00                              ldy #$00
  881 A:fe99  f0 02                              beq ioprt2
  882 A:fe9b                           ioprt1    
  882 A:fe9b  a9 fd                              lda #>cout1
  883 A:fe9d                           ioprt2    
  883 A:fe9d  94 00                              sty loc0,x
  884 A:fe9f  95 01                              sta loc1,x
  885 A:fea1  60                                 rts 
  886 A:fea2                                    ;
  887 A:fea2                                    ; execute installed language
  888 A:fea2                                    ;
  889 A:fea2                           x_lang    
  889 A:fea2  4c 00 e0                           jmp lang
  890 A:fea5                                    ; soft entry vector for installed language
  891 A:fea5                           bascont   
  891 A:fea5  4c 03 e0                           jmp lang2
  892 A:fea8                           go        
  892 A:fea8  20 69 fe                           jsr a1pc                ; adr to pc if specified
  893 A:feab  20 3f ff                           jsr restore                ; restore meta registers
  894 A:feae  6c 3a 00                           jmp (pcl)              ; go to user subroutine
  895 A:feb1                           regz      
  895 A:feb1  4c 1f fb                           jmp regdsp                ; jump to register display
  896 A:feb4                                    ;
  897 A:feb4                                    ; trace command
  898 A:feb4                                    ;
  899 A:feb4                           trace     
  899 A:feb4  c6 34                              dec ysav
  900 A:feb6                           stepz     
  900 A:feb6  20 69 fe                           jsr a1pc                ; adr to pc if specified
  901 A:feb9  4c 8b fa                           jmp step                ; take one step
  902 A:febc                                    ;
  903 A:febc                                    ; execute user command
  904 A:febc                                    ; 
  905 A:febc                           usr       
  905 A:febc  4c f8 03                           jmp usradr                ; to usr subroutine at usradr
  906 A:febf                                    ;
  907 A:febf                                    ; write memory range to tape OUT
  908 A:febf                                    ;
  909 A:febf                           write     
  909 A:febf  a9 00                              lda #$00             ; set header to WRITE
  910 A:fec1  85 26                              sta tpdir
  911 A:fec3  a9 40                              lda #$40
  912 A:fec5  20 ae fc                           jsr headr                ; write 10-sec header
  913 A:fec8  a0 27                              ldy #$27
  914 A:feca                           wr1       
  914 A:feca  a2 00                              ldx #$00
  915 A:fecc  41 3c                              eor (a1l,x)
  916 A:fece  48                                 pha 
  917 A:fecf  a1 3c                              lda (a1l,x)
  918 A:fed1  20 e6 fe                           jsr wrbyte
  919 A:fed4  20 9f fc                           jsr nxta1
  920 A:fed7  a0 1d                              ldy #$1d
  921 A:fed9  68                                 pla 
  922 A:feda  90 ee                              bcc wr1
  923 A:fedc  a0 22                              ldy #$22
  924 A:fede  20 e6 fe                           jsr wrbyte
  925 A:fee1  ad 22 c0                           lda tapecls                ; close tape
  926 A:fee4  f0 54                              beq bell                ; sound bell and return
  927 A:fee6                           wrbyte    
  927 A:fee6  a2 10                              ldx #$10
  928 A:fee8                           wrbyt2    
  928 A:fee8  0a                                 asl 
  929 A:fee9  20 bb fc                           jsr wrbit
  930 A:feec  d0 fa                              bne wrbyt2
  931 A:feee  60                                 rts 
  932 A:feef                                    ;
  933 A:feef                                    ; execute command line
  934 A:feef                                    ;
  935 A:feef                           crmon     
  935 A:feef  20 f4 fd                           jsr bli                ; handle CR as blank
  936 A:fef2  68                                 pla                    ;  then pop stack
  937 A:fef3  68                                 pla                    ; and return to mon
  938 A:fef4  d0 73                              bne monz
  939 A:fef6                                    ;
  940 A:fef6                                    ; read memory area from tape IN
  941 A:fef6                                    ;
  942 A:fef6                                    ; first synchronize timing with the header block,
  943 A:fef6                                    ; Then read bytes and check checksum
  944 A:fef6                                    ; 1s and 0s have different lengths, so number and frequency 
  945 A:fef6                                    ; of machine cycles is important for executing this
  946 A:fef6                                    ;
  947 A:fef6                           read      
  947 A:fef6  a9 01                              lda #$01             ; set header to READ
  948 A:fef8  85 26                              sta tpdir
  949 A:fefa  20 e3 fc                           jsr rd2bit                ; find tapein edge
  950 A:fefd  a9 16                              lda #$16
  951 A:feff  20 ae fc                           jsr headr                ; delay 3.5s
  952 A:ff02  85 2e                              sta chksum                ; init checksum = $FF
  953 A:ff04  20 e3 fc                           jsr rd2bit                ; find tapein edge
  954 A:ff07                           rd2       
  954 A:ff07  a0 24                              ldy #$24             ; look for sync bit
  955 A:ff09  20 e6 fc                           jsr rdbit                ; (short 0)
  956 A:ff0c  b0 f9                              bcs rd2                ; loop until found
  957 A:ff0e  20 e6 fc                           jsr rdbit                ; skip second sync h-cycle
  958 A:ff11  a0 3b                              ldy #$3b             ; index for 0/1 test
  959 A:ff13                           rd3       
  959 A:ff13  20 d5 fc                           jsr rdbyte                ; read a byte
  960 A:ff16  81 3c                              sta (a1l,x)            ; store at (a1)
  961 A:ff18  45 2e                              eor chksum
  962 A:ff1a  85 2e                              sta chksum                ; update running checksum
  963 A:ff1c  20 9f fc                           jsr nxta1                ; incr a1, compare to a2
  964 A:ff1f  a0 35                              ldy #$35             ; compensate 0/1 index
  965 A:ff21  90 f0                              bcc rd3                ; loop until done
  966 A:ff23  20 d5 fc                           jsr rdbyte                ; read chksum byte
  967 A:ff26  ac 22 c0                           ldy tapecls                ; close tape
  968 A:ff29  c5 2e                              cmp chksum
  969 A:ff2b  f0 0d                              beq bell                ; good, sound bell and return
  970 A:ff2d                                    ;
  971 A:ff2d                                    ; print "ERR" and beep
  972 A:ff2d                                    ;
  973 A:ff2d                           prerr     
  973 A:ff2d  a9 c5                              lda #$c5             ; 'E'
  974 A:ff2f  20 e7 fd                           jsr cout                ; print "ERR" then bell
  975 A:ff32  a9 d2                              lda #$d2             ; 'R'
  976 A:ff34  20 e7 fd                           jsr cout
  977 A:ff37  20 e7 fd                           jsr cout
  978 A:ff3a                                    ;
  979 A:ff3a                                    ; ring the terminal bell
  980 A:ff3a                                    ;
  981 A:ff3a                           bell      
  981 A:ff3a  a9 07                              lda #k_ctl_g               ; output bell and return
  982 A:ff3c  4c e7 fd                           jmp cout                ; reuse cout rts directly here...
  983 A:ff3f                                    ;
  984 A:ff3f                                    ; restore registers from zero page storage
  985 A:ff3f                                    ;
  986 A:ff3f                           restore   
  986 A:ff3f  a5 48                              lda status                ; restore 6502 register contents
  987 A:ff41  48                                 pha                    ;  used by debug software
  988 A:ff42  a5 45                              lda acc
  989 A:ff44                           restr1    
  989 A:ff44  a6 46                              ldx xreg
  990 A:ff46  a4 47                              ldy yreg
  991 A:ff48  28                                 plp 
  992 A:ff49  60                                 rts 
  993 A:ff4a                                    ;
  994 A:ff4a                                    ; save 6502 reg contents to zero page storage
  995 A:ff4a                                    ;
  996 A:ff4a                           save      
  996 A:ff4a  85 45                              sta acc
  997 A:ff4c                           sav1      
  997 A:ff4c  86 46                              stx xreg
  998 A:ff4e  84 47                              sty yreg
  999 A:ff50  08                                 php 
 1000 A:ff51  68                                 pla 
 1001 A:ff52  85 48                              sta status
 1002 A:ff54  ba                                 tsx 
 1003 A:ff55  86 49                              stx spnt
 1004 A:ff57  d8                                 cld 
 1005 A:ff58  60                                 rts 
 1006 A:ff59                                    ;
 1007 A:ff59                                    ; 6502 reset vector
 1008 A:ff59                                    ;
 1009 A:ff59                           reset     
 1009 A:ff59  20 78 fe                           jsr setnorm
 1010 A:ff5c  20 77 fb                           jsr init
 1011 A:ff5f  20 87 fe                           jsr setvid
 1012 A:ff62  20 7d fe                           jsr setkbd
 1013 A:ff65                                    ;
 1014 A:ff65                                    ; Monitor entry point
 1015 A:ff65                                    ;
 1016 A:ff65                           mon       
 1016 A:ff65  d8                                 cld 
 1017 A:ff66  20 3a ff                           jsr bell
 1018 A:ff69                           monz      
 1018 A:ff69  a9 2a                              lda #'*'             ; Monitor prompt
 1019 A:ff6b  85 33                              sta prompt
 1020 A:ff6d  20 60 fd                           jsr getlnz                ; get line
 1021 A:ff70  20 c7 ff                           jsr zmode                ; clear monitor mode, scan idx
 1022 A:ff73                                    ;
 1023 A:ff73                                    ; get the next item from input line
 1024 A:ff73                                    ;
 1025 A:ff73                           nxtitm    
 1025 A:ff73  20 a7 ff                           jsr getnum                ; get item, non-hex
 1026 A:ff76  84 34                              sty ysav
 1027 A:ff78  a0 17                              ldy #$17             ; x-reg=0 if no hex input
 1028 A:ff7a                                    ;
 1029 A:ff7a                                    ; look up command subroutine for current character
 1030 A:ff7a                                    ;
 1031 A:ff7a                           chrsrch   
 1031 A:ff7a  88                                 dey 
 1032 A:ff7b  30 e8                              bmi mon                ; not found, go to mon
 1033 A:ff7d  d9 cc ff                           cmp chrtbl,y              ; find cmnd char in table
 1034 A:ff80  d0 f8                              bne chrsrch
 1035 A:ff82  20 be ff                           jsr tosub                ; found call corresponding subroutine
 1036 A:ff85  a4 34                              ldy ysav
 1037 A:ff87  4c 73 ff                           jmp nxtitm
 1038 A:ff8a                                    ;
 1039 A:ff8a                                    ; get one hex digit from input
 1040 A:ff8a                                    ;
 1041 A:ff8a                           dig       
 1041 A:ff8a  a2 03                              ldx #$03
 1042 A:ff8c  0a                                 asl 
 1043 A:ff8d  0a                                 asl                    ; got hex digit in low nibble, shift into A2
 1044 A:ff8e  0a                                 asl 
 1045 A:ff8f  0a                                 asl                    ; first, position in high nibble of accu
 1046 A:ff90                           nxtbit    
 1046 A:ff90  0a                                 asl                    ; transport a high bit to carry
 1047 A:ff91  26 3e                              rol a2l                ; rotate carry into low byte into carry
 1048 A:ff93  26 3f                              rol a2h                ; rotate carry into high byte
 1049 A:ff95  ca                                 dex                    ; leave x = $FF if digit
 1050 A:ff96  10 f8                              bpl nxtbit
 1051 A:ff98                           nxtbas    
 1051 A:ff98  a5 31                              lda mode
 1052 A:ff9a  d0 06                              bne nxtbs2                ;   if mode is zero
 1053 A:ff9c  b5 3f                              lda a2h,x              ;    then copy a2 to
 1054 A:ff9e  95 3d                              sta a1h,x              ;     a1 and a3
 1055 A:ffa0  95 41                              sta a3h,x
 1056 A:ffa2                           nxtbs2    
 1056 A:ffa2  e8                                 inx 
 1057 A:ffa3  f0 f3                              beq nxtbas
 1058 A:ffa5  d0 06                              bne nxtchr
 1059 A:ffa7                                    ;
 1060 A:ffa7                                    ; getnum read command
 1061 A:ffa7                                    ; result
 1061 A:ffa7                                    
 1062 A:ffa7                                    ;   a - mode
 1063 A:ffa7                                    ;   x - number of numeric args
 1064 A:ffa7                                    ;
 1065 A:ffa7                           getnum    
 1065 A:ffa7  a2 00                              ldx #$00             ;  clear A2
 1066 A:ffa9  86 3f                              stx a2h
 1067 A:ffab  86 3e                              stx a2l
 1068 A:ffad                           nxtchr    
 1068 A:ffad  b9 00 02                           lda in,y              ; get char
 1069 A:ffb0  c8                                 iny 
 1070 A:ffb1  49 30                              eor #$30             ; $30 0 -> $00; $39 9 -> $09; $41 A -> $71; $20 -> $10...
 1071 A:ffb3  c9 0a                              cmp #$0a
 1072 A:ffb5  90 d3                              bcc dig                ; if hex digit
 1073 A:ffb7  69 88                              adc #$88             ; c=1, $76 F + $88 + 1 = $FF; $71 A + $88 + 1 = $FA
 1074 A:ffb9  c9 fa                              cmp #$fa
 1075 A:ffbb  b0 cd                              bcs dig                ; if not a digit a now has ch eor #$30 + $B9
 1076 A:ffbd  60                                 rts 
 1077 A:ffbe                                    ;
 1078 A:ffbe                                    ; Go to command routine
 1079 A:ffbe                                    ;
 1080 A:ffbe                           tosub     
 1080 A:ffbe  a9 fe                              lda #>go              ; Push high order subroutine address on stack
 1081 A:ffc0  48                                 pha 
 1082 A:ffc1  b9 e3 ff                           lda subtbl,y              ; Push low order subroutine address on stack
 1083 A:ffc4  48                                 pha 
 1084 A:ffc5  a5 31                              lda mode                ;  old mode to A
 1085 A:ffc7                                    ;
 1086 A:ffc7                                    ; 
 1087 A:ffc7                           zmode     
 1087 A:ffc7  a0 00                              ldy #$00             ; clr mode,
 1088 A:ffc9  84 31                              sty mode
 1089 A:ffcb  60                                 rts                    ; go to command subroutine previously pushed on the stack

 1091 A:ffcc                           chrtbl    
 1091 A:ffcc  bc                                 .byt (((k_ctl_c^$30)+$89)&$ff)
 1092 A:ffcd  b2                                 .byt (((k_ctl_y^$30)+$89)&$ff)
 1093 A:ffce  be                                 .byt (((k_ctl_e^$30)+$89)&$ff)
 1094 A:ffcf  ed                                 .byt ((('T'^$30)+$89)&$ff)
 1095 A:ffd0  ef                                 .byt ((('V'^$30)+$89)&$ff)
 1096 A:ffd1  c4                                 .byt (((k_ctl_k^$30)+$89)&$ff)
 1097 A:ffd2  ec                                 .byt ((('S'^$30)+$89)&$ff)
 1098 A:ffd3  a9                                 .byt (((k_ctl_p^$30)+$89)&$ff)
 1099 A:ffd4  bb                                 .byt (((k_ctl_b^$30)+$89)&$ff)
 1100 A:ffd5  a6                                 .byt ((('-'^$30)+$89)&$ff)
 1101 A:ffd6  a4                                 .byt ((('+'^$30)+$89)&$ff)
 1102 A:ffd7  06                                 .byt ((('M'^$30)+$89)&$ff)
 1103 A:ffd8  95                                 .byt ((('<'^$30)+$89)&$ff)
 1104 A:ffd9  07                                 .byt ((('N'^$30)+$89)&$ff)
 1105 A:ffda  02                                 .byt ((('I'^$30)+$89)&$ff)
 1106 A:ffdb  05                                 .byt ((('L'^$30)+$89)&$ff)
 1107 A:ffdc  f0                                 .byt ((('W'^$30)+$89)&$ff)
 1108 A:ffdd  00                                 .byt ((('G'^$30)+$89)&$ff)
 1109 A:ffde  eb                                 .byt ((('R'^$30)+$89)&$ff)
 1110 A:ffdf  93                                 .byt (((':'^$30)+$89)&$ff)
 1111 A:ffe0  a7                                 .byt ((('.'^$30)+$89)&$ff)
 1112 A:ffe1  c3                                 .byt (((k_entr^$30)+$89)&$ff)
 1113 A:ffe2  99                                 .byt (((' '^$30)+$89)&$ff)
 1114 A:ffe3                                    ; Monitor commands
 1114 A:ffe3                                    
 1115 A:ffe3                                    ; ctrl-c        bascont
 1116 A:ffe3                                    ; ctrl-y        usr
 1117 A:ffe3                                    ; ctrl-e        regz
 1118 A:ffe3                                    ; 'T'           trace
 1119 A:ffe3                                    ; 'V'           vfy
 1120 A:ffe3                                    ; ctrl-k        inprt
 1121 A:ffe3                                    ; 'S'           stepz
 1122 A:ffe3                                    ; ctrl-p        outprt
 1123 A:ffe3                                    ; ctrl-b        x_lang
 1124 A:ffe3                                    ; '-'           setmode
 1125 A:ffe3                                    ; '+'           setmode
 1126 A:ffe3                                    ; 'M'           move
 1127 A:ffe3                                    ; '<'           lt
 1128 A:ffe3                                    ; 'N'           setnorm
 1129 A:ffe3                                    ; 'I'           setinv
 1130 A:ffe3                                    ; 'L'           list
 1131 A:ffe3                                    ; 'W'           write
 1132 A:ffe3                                    ; 'G'           go
 1133 A:ffe3                                    ; 'R'           read
 1134 A:ffe3                                    ; colon         write area addr1,addr2
 1135 A:ffe3                                    ; '.'           hexdump addr1,addr2
 1136 A:ffe3                                    ; enter         execute monitor command line
 1137 A:ffe3                                    ; ' '           add preceding command to line

 1139 A:ffe3                           subtbl    
 1139 A:ffe3  a5                                 .byt <bascont               ; CTL-C - exit moitor to installed language
 1140 A:ffe4  bc                                 .byt <usr               ; CTL-Y - execute user command at vector %3F8
 1141 A:ffe5  b1                                 .byt <regz               ; CTL-E - examine registers
 1142 A:ffe6  b4                                 .byt <trace               ; "T" - Trace until reset or brk
 1143 A:ffe7  2a                                 .byt <vfy               ; "V" - Verify memory range
 1144 A:ffe8  81                                 .byt <inprt               ; [0-7] CTL-K - input from keyboard (0) or peripheral card 1-7
 1145 A:ffe9  b6                                 .byt <stepz               ; "S" - Step
 1146 A:ffea  8b                                 .byt <outprt               ; [0-7] CTL-P - send output to video (0) or printer peripheral 1-7
 1147 A:ffeb  a2                                 .byt <x_lang               ; CTL-B -
 1148 A:ffec  0c                                 .byt <setmode               ; "-" - hexadecimal substraction
 1149 A:ffed  0c                                 .byt <setmode               ; "+" - hexadecimal addition
 1150 A:ffee  20                                 .byt <move               ; "M" - mpve memory range
 1151 A:ffef  14                                 .byt <lt               ; "< aaaa.bbbb M|V" - Move / compare memory range
 1152 A:fff0  78                                 .byt <setnorm               ; "N" - set to normal output
 1153 A:fff1  74                                 .byt <setinv               ; "I" - set to inverse output
 1154 A:fff2  52                                 .byt <list               ; "L" - list preceding memory add
 1155 A:fff3  bf                                 .byt <write               ; "aaaa.bbbb W" - Save memory range on tape
 1156 A:fff4  a8                                 .byt <go               ; "aaaa G" - Run program as subroutine at aaaa
 1157 A:fff5  f6                                 .byt <read               ; "aaaa.bbbb R" - Read memory range from tape
 1158 A:fff6  0c                                 .byt <setmode               ; colon xx yy... - change current location. to given ehx bytes
 1159 A:fff7  0c                                 .byt <setmode               ; ".yyyy" - examine bytes between after current position and yyyy
 1160 A:fff8  ef                                 .byt <crmon               ; enter - starts evaluation of commands in input line
 1161 A:fff9  f8                                 .byt <blank               ; space separator
 1162 A:fffa                                    ;
 1163 A:fffa                                    ; 6502 fixed system vectors. Must start at 0xFFFA
 1164 A:fffa                                    ; .org not working here, adjusting with
 1165 A:fffa                                    ; .dsb block "keep_aligned" above
 1166 A:fffa                                    ;
 1167 A:fffa                           sysvec_nmi 
 1167 A:fffa  fb 03                              .word nmiloc                ; nmi vector set up in RAM by reset routine
 1168 A:fffc                           sysvec_reset 
 1168 A:fffc  59 ff                              .word reset                ; reset vector
 1169 A:fffe                           sysvec_irq 
 1169 A:fffe  ce fa                              .word irqvec                ; irq vector in rom
