
rom.s

    1 A:1000                                    ;
    2 A:1000                                    ; haiku6502 ROM
    3 A:1000                                    ;
    4 A:1000                                    ; Annotated and modified emulator ROM using orig_monitor_rom.s as a template.
    5 A:1000                                    ; This code is only for academic purposes.
    6 A:1000                                    ; This file is compatible with xa assembler and is not relocatable.
    7 A:1000                                    ; Care has to be taken to keep the "go" jump table addresses area on page 0xFE or else it will cease to work this way.
    8 A:1000                                    ; There are a few nifty tricks in the original assembler code to save a few bytes here and there that probably
    9 A:1000                                    ; would not have been done this way were there more than 12KB address space available for ROM.
   10 A:1000                                    ;
   11 A:1000                                    ; The following modifications have been made
   11 A:1000                                    
   12 A:1000                                    ;
   13 A:1000                                    ; - fixed character mapping. ASCII chars are now ASCII chars in the right code points.
   14 A:1000                                    ; - removed memory mapped text and graphics screens. The screen is now a terminal peripheral controlled
   15 A:1000                                    ;   through I/O ports 0xC010-0xC01F
   16 A:1000                                    ; - keyboard strobe is now in 0xC001, to make space for more i/o control addresses
   17 A:1000                                    ; - removed screen address calculations, no longer needed with sane terminal cursor coordinates that
   18 A:1000                                    ;   are no longer aligned with cathode ray tube electronic beam scan sequence.
   19 A:1000                                    ; - Bell just sends a CTL-G to terminal
   20 A:1000                                    ; - Tape in/out goes to a tape file. with the right sampling rate, it should be possible to read in data tapes.
   21 A:1000                                    ;   not much use though, since the rom routine addresses are now no longer compatible.
   22 A:1000                                    ; - The screen size is taken from the terminal dimensions. Size is no longer restricted to 1KB text pages.
   23 A:1000                                    ; - Lo-Res and Hi-Res graphics modes are gone for now since they don't work too well with the standard ncurses based
   24 A:1000                                    ;   terminal peripheral. A graphics terminal peripheral could be added, though.
   25 A:1000                                    ; - The peripheral system is not completed, especially emulator interrupt management is rudimentary. So peripheral
   26 A:1000                                    ;   rom areas can be addressed, but the extension rom area 0xC800-0xC8FF needs work. This does not ffect this rom,
   27 A:1000                                    ;   though...
   28 A:1000                                    ;
   29 A:1000                                    ; The monitor part works pretty much the same as described in the Apple II Reference Manual. It has a nice disassembler.
   30 A:1000                                    ; It provides RAM editing as hex dump only for now.
   31 A:1000                                    ;
   32 A:1000                                    ; Memory layout
   32 A:1000                                    
   33 A:1000                                    ;
   34 A:1000                                    ; 0x0000-0x00FF Zero page
   35 A:1000                                    ; 0x0100-9x01FF Stack
   36 A:1000                                    ; 0x0200-0x02FF text buffer
   37 A:1000                                    ; 0x0300-0x03FF system vars & vectors
   38 A:1000                                    ; 0x0400-0xBFFF free RAM
   39 A:1000                                    ; 0xC000-0xCFFF I/O
   40 A:1000                                    ; 0xD000-0xFFFF ROM; thereof
   41 A:1000                                    ;               0xD000 - 0xF800 Reserved for language modules
   42 A:1000                                    ;               0xF800 - 0xFFFF System Monitor ROM
   43 A:1000                                    ;               0xFFFA - 0xFFFF Hardwired 6502 NMI, Reset and IRQ vectors, have to be kept at fixed addresses.
   44 A:1000                                    ; On Reset, the program counter is loaded from 0xFFFC and 0xFFFD. all addresses with least
   45 A:1000                                    ; significant (lsb,low) byte first.
   46 A:1000                                    ;
   47 A:1000                                    ; TODO Fix remaining bugs, cleanup code
   48 A:1000                                    ;

   50 A:1000                                     .include "symbols.inc"

symbols.inc

    1 A:1000                                    ; common symbol definitions, borrowed from
    2 A:1000                                    ; 1979 Apple ][ Reference Manual, Monitor ROM Listing

    4 A:1000                                    loc0=$00
    5 A:1000                                    loc1=$01
    6 A:1000                                    wndlft=$20
    7 A:1000                                    wndwdth=$21
    8 A:1000                                    wndtop=$22
    9 A:1000                                    wndbtm=$23
   10 A:1000                                    ch=$24
   11 A:1000                                    cv=$25
   12 A:1000                                    tpdir=$26           ; tape direction for header op - 0 write, 1 read
   13 A:1000                                    rdline=$28           ; vector for readline
   14 A:1000                                    rdlinh=$29           ;   msb
   15 A:1000                                    h2=$2c
   16 A:1000                                    lmnem=$2c
   17 A:1000                                    rtnl=$2c
   18 A:1000                                    v2=$2d
   19 A:1000                                    rmnem=$2d
   20 A:1000                                    rtnh=$2d
   21 A:1000                                    mask=$2e
   22 A:1000                                    chksum=$2e
   23 A:1000                                    format=$2e
   24 A:1000                                    lastin=$2f
   25 A:1000                                    length=$2f
   26 A:1000                                    sign=$2f
   27 A:1000                                    color=$30
   28 A:1000                                    mode=$31
   29 A:1000                                    invflg=$32
   30 A:1000                                    prompt=$33
   31 A:1000                                    ysav=$34
   32 A:1000                                    ysav1=$35
   33 A:1000                                    cswl=$36           ; CSW character out vector
   34 A:1000                                    cswh=$37
   35 A:1000                                    kswl=$38           ; keyboard input vector
   36 A:1000                                    kswh=$39
   37 A:1000                                    pcl=$3a
   38 A:1000                                    pch=$3b
   39 A:1000                                    xqt=$3c
   40 A:1000                                    xqtnz=$3c
   41 A:1000                                    a1l=$3c
   42 A:1000                                    a1h=$3d
   43 A:1000                                    a2l=$3e
   44 A:1000                                    a2h=$3f
   45 A:1000                                    a3l=$40
   46 A:1000                                    a3h=$41
   47 A:1000                                    a4l=$42
   48 A:1000                                    a4h=$43
   49 A:1000                                    a5l=$44
   50 A:1000                                    a5h=$45
   51 A:1000                                    acc=$45
   52 A:1000                                    xreg=$46
   53 A:1000                                    yreg=$47
   54 A:1000                                    status=$48
   55 A:1000                                    spnt=$49
   56 A:1000                                    rndl=$4e           ; pseudo-random
   57 A:1000                                    rndh=$4f
   58 A:1000                                    acl=$50
   59 A:1000                                    ach=$51
   60 A:1000                                    xtndl=$52
   61 A:1000                                    xtndh=$53
   62 A:1000                                    auxl=$54
   63 A:1000                                    auxh=$55
   64 A:1000                                    in=$0200           ; input buffer base
   65 A:1000                                    usradr=$03f8
   66 A:1000                                    nmiloc=$03fb
   67 A:1000                                    irqloc=$03fe
   68 A:1000                                    ioadr=$c000
   69 A:1000                                    kbd=$c000
   70 A:1000                                    kbdstrb=$c001
   71 A:1000                                    termcy=$c010           ; terminal cursor y   RW
   72 A:1000                                    termcx=$c011           ; terminal cursor x   RW
   73 A:1000                                    termout=$c012           ; termout character under cursor RW
   74 A:1000                                    termesc=$c013           ; terminal connamd byte W
   75 A:1000                                    termea1=$c014           ; terminal command argl   (bad design, will change)
   76 A:1000                                    termea2=$c015           ; terminal command argh
   77 A:1000                                    termwh=$c016           ; temrinal window height
   78 A:1000                                    termww=$c017           ; terminal window width
   79 A:1000                                    termin=$c018
   80 A:1000                                    terml=$c019           ; stdio mode next line char of 0 terminated string. R
   81 A:1000                                    termp=$c01a           ; stdio mode next line char of 0 terminated string. RW
   82 A:1000                                    termmd=$c01f           ; terminal mode, RO. #$00 - screen, #$01 - stdio
   83 A:1000                                    tapeout=$c020
   84 A:1000                                    tapein=$c021
   85 A:1000                                    tapecls=$c022
   86 A:1000                                    spkr=$c030
   87 A:1000                                    paddl0=$c061
   88 A:1000                                    ptrig=$c070

   90 A:1000                                    ;
   91 A:1000                                    ;  Ecape commands for terminal
   91 A:1000                                    
   92 A:1000                                    ;
   93 A:1000                                    t_cls=$00           ; Clear screen
   94 A:1000                                    t_cll=$01           ; clear from cursor to end of line
   95 A:1000                                    t_clb=$02           ; clear from cursor to end of line
   96 A:1000                                    t_scr=$03           ; scroll one line up
   97 A:1000                                    t_norm=$04           ; normal chars
   98 A:1000                                    t_inv=$05           ; inverse chars
   99 A:1000                                    t_blnk=$06           ; blinking chars
  100 A:1000                                    t_qcch=$07           ; query current character under cursor

  102 A:1000                                    ; t_qy    = $04   ; query terminal cursor y; for result read terminl,h
  103 A:1000                                    ; t_qx    = $05   ; query terminal cursor x; for result read terminl,h

  105 A:1000                                    ; characters
  106 A:1000                                    k_ctl_a=$01
  107 A:1000                                    k_ctl_b=$02
  108 A:1000                                    k_ctl_c=$03
  109 A:1000                                    k_ctl_d=$04
  110 A:1000                                    k_ctl_e=$05
  111 A:1000                                    k_ctl_f=$06
  112 A:1000                                    k_ctl_g=$07
  113 A:1000                                    k_bs=$08
  114 A:1000                                    k_tab=$09
  115 A:1000                                    k_lf=$0a
  116 A:1000                                    k_ctl_k=$0b
  117 A:1000                                    k_ctl_l=$0c
  118 A:1000                                    k_cr=$0a
  119 A:1000                                    k_ctl_n=$0e
  120 A:1000                                    k_ctl_o=$0f
  121 A:1000                                    k_ctl_p=$10
  122 A:1000                                    k_ctl_q=$11
  123 A:1000                                    k_ctl_r=$12
  124 A:1000                                    k_ctl_s=$13
  125 A:1000                                    k_ctl_t=$14
  126 A:1000                                    k_ctl_u=$15
  127 A:1000                                    k_ctl_v=$16
  128 A:1000                                    k_ctl_w=$17
  129 A:1000                                    k_ctl_x=$18
  130 A:1000                                    k_ctl_y=$19
  131 A:1000                                    k_ctl_z=$1a
  132 A:1000                                    k_esc=$1b
  133 A:1000                                    k_entr=k_cr
  134 A:1000                                    gr_top='+'
  135 A:1000                                    gr_btm='_'
  136 A:1000                                    gr_grid=$61

rom.s

    1 A:1000                                     *= $d000              ; ROM start address

   52 A:d000  00 ff 00 10 00 24 2c ...           .dsb $1000,$00        ; first filler, 4KB low ROM
   53 A:e000                           lang      
   53 A:e000  20 06 e0                           jsr lang_init
   54 A:e003                           lang2     
   54 A:e003  4c 07 e0                           jmp lang_cont
   55 A:e006                           lang_init 
   55 A:e006  60                                 rts 
   56 A:e007                           lang_cont 
   56 A:e007  00 ff f9 17 00 24 2c ...           .dsb $17f9,$00        ; filler up to F800

   58 A:f800                                    ;  SPACE FREE in last 4k
   59 A:f800                           keep_aligned 
   59 A:f800                                    
   60 A:f800  00 ff 1f 00 00 24 f8 ...           .dsb $1f              ; Make sure 6502 vectors stay at $FFFA
   61 A:f81f                                    ;
   62 A:f81f                                    ; Emulator exit
   63 A:f81f                                    ; terminate by setting PC to $FFFF, which should not happen in normal operation.
   64 A:f81f                                    ;
   65 A:f81f                           exit      
   65 A:f81f  4c ff ff                           jmp $ffff
   66 A:f822                                    ;
   67 A:f822                                    ; getline vector.
   68 A:f822                                    ;
   69 A:f822                           getlnv    
   69 A:f822  6c 28 00                           jmp (rdline)
   70 A:f825                           stdin     
   70 A:f825  ad 18 c0                           lda termin
   71 A:f828  60                                 rts 
   72 A:f829                                    ;
   73 A:f829                                    ; readline from stdio
   74 A:f829                                    ; this will block until line is read
   75 A:f829                                    ; this way it uses standard readline
   76 A:f829                                    ; funcionality hostside.
   77 A:f829                                    ;
   78 A:f829                           stdrdln   
   78 A:f829                                     .( 
   79 A:f829  98                                 tya 
   80 A:f82a  48                                 pha 
   81 A:f82b  a5 33                              lda prompt                ; set prompt
   82 A:f82d  8d 1a c0                           sta termp
   83 A:f830  a0 ff                              ldy #$ff
   84 A:f832                           loop      
   84 A:f832  c8                                 iny 
   85 A:f833  ad 19 c0                           lda terml
   86 A:f836  99 00 02                           sta in,y
   87 A:f839  d0 f7                              bne loop
   88 A:f83b  a9 0a                              lda #k_entr
   89 A:f83d  99 00 02                           sta in,y
   90 A:f840  68                                 pla 
   91 A:f841  a8                                 tay 
   92 A:f842  60                                 rts 
   93 A:f843                                     .) 
   94 A:f843                           stdout    
   94 A:f843  8d 12 c0                           sta termout
   95 A:f846  60                                 rts 
   96 A:f847                           nxtcol    
   96 A:f847  a5 30                              lda color                ; increment color by 3
   97 A:f849  18                                 clc 
   98 A:f84a  69 03                              adc #$03
   99 A:f84c                           setcol    
   99 A:f84c  29 0f                              and #$0f             ; sets color = 17*A mod 16
  100 A:f84e  85 30                              sta color
  101 A:f850  0a                                 asl 
  102 A:f851  0a                                 asl 
  103 A:f852  0a                                 asl 
  104 A:f853  0a                                 asl                    ; << 4 = *16
  105 A:f854  05 30                              ora color                ; + 1
  106 A:f856  85 30                              sta color
  107 A:f858  60                                 rts 
  108 A:f859                           selnibl   
  108 A:f859  90 04                              bcc rtmaskz                ; if even, use low nibble else use high nibble (was scrn2)
  109 A:f85b  4a                                 lsr 
  110 A:f85c  4a                                 lsr 
  111 A:f85d  4a                                 lsr                    ; shift high nibble into low nibble
  112 A:f85e  4a                                 lsr 
  113 A:f85f                           rtmaskz   
  113 A:f85f  29 0f                              and #$0f             ; mask lower 4 bits
  114 A:f861  60                                 rts 
  115 A:f862                           insds1    
  115 A:f862  a6 3a                              ldx pcl                ; print pcl,h
  116 A:f864  a4 3b                              ldy pch
  117 A:f866  20 2b fd                           jsr pryx2
  118 A:f869  20 28 f9                           jsr prblnk                ; followed by a blank
  119 A:f86c  a1 3a                              lda (pcl,x)
  120 A:f86e                           insds2    
  120 A:f86e  a8                                 tay 
  121 A:f86f  4a                                 lsr                    ; even / odd test
  122 A:f870  90 09                              bcc ieven
  123 A:f872  6a                                 ror                    ; bit 1 test
  124 A:f873  b0 10                              bcs err                ; xxxxxx11 invalid opcode
  125 A:f875  c9 a2                              cmp #$a2
  126 A:f877  f0 0c                              beq err                ; opcode 89 invalid
  127 A:f879  29 87                              and #$87             ; mask bits
  128 A:f87b                           ieven     
  128 A:f87b  4a                                 lsr                    ; lsb into carry for l/r test
  129 A:f87c  aa                                 tax 
  130 A:f87d  bd 42 f9                           lda fmt1,x              ; get format index byte
  131 A:f880  20 59 f8                           jsr selnibl                ; r/l h-byte on carry
  132 A:f883  d0 04                              bne getfmt
  133 A:f885                           err       
  133 A:f885  a0 80                              ldy #$80             ; substitute $80 for invalid ops
  134 A:f887  a9 00                              lda #$00             ; set print format index to 0
  135 A:f889                           getfmt    
  135 A:f889  aa                                 tax 
  136 A:f88a  bd 86 f9                           lda fmt2,x              ; index into print format table
  137 A:f88d  85 2e                              sta format                ; save for addr field formatting
  138 A:f88f  29 03                              and #$03             ; mask for 2-bit length
  139 A:f891                                    ; (P=1 byte, 1=2 byte, 2=3 byte)
  140 A:f891  85 2f                              sta length
  141 A:f893  98                                 tya                    ; opcode
  142 A:f894  29 8f                              and #$8f             ; mask for 1xxx1010 test
  143 A:f896  aa                                 tax                    ;  save it
  144 A:f897  98                                 tya                    ; opcode to a again
  145 A:f898  a0 03                              ldy #$03
  146 A:f89a  e0 8a                              cpx #$8a
  147 A:f89c  f0 0b                              beq mnndx3
  148 A:f89e                           mnndx1    
  148 A:f89e  4a                                 lsr 
  149 A:f89f  90 08                              bcc mnndx3                ; form index into mnemonic tble
  150 A:f8a1  4a                                 lsr 
  151 A:f8a2                           mnndx2    
  151 A:f8a2  4a                                 lsr                    ; 1)  1xxx1010 => 00101xxx
  152 A:f8a3  09 20                              ora #$20             ; 2)  xxxyyy01 => 00111xxx
  153 A:f8a5  88                                 dey                    ; 3)  xxxyyy10 => 00110xxx
  154 A:f8a6  d0 fa                              bne mnndx2                ; 4)  xxxyy100 => 00100xxx
  155 A:f8a8  c8                                 iny                    ; 5)  xxxxx000 => 000xxxxx
  156 A:f8a9                           mnndx3    
  156 A:f8a9  88                                 dey 
  157 A:f8aa  d0 f2                              bne mnndx1
  158 A:f8ac  60                                 rts 
  159 A:f8ad  ff ff ff                           .byt $ff,$ff,$ff  ; ???
  160 A:f8b0                           instdsp   
  160 A:f8b0  20 62 f8                           jsr insds1                ; gen fmt, len bytes
  161 A:f8b3  48                                 pha                    ; save mnemonic table index
  162 A:f8b4                           prntop    
  162 A:f8b4  b1 3a                              lda (pcl),y
  163 A:f8b6  20 6f fd                           jsr prbyte
  164 A:f8b9  a2 01                              ldx #$01             ; print 2 blanks
  165 A:f8bb                           prntbl    
  165 A:f8bb  20 2a f9                           jsr prbl2
  166 A:f8be  c4 2f                              cpy length                ; print inst (1-3 bytes)
  167 A:f8c0  c8                                 iny                    ; in a 12 char field
  168 A:f8c1  90 f1                              bcc prntop
  169 A:f8c3  a2 03                              ldx #$03             ; char count for mnemonic print
  170 A:f8c5  c0 04                              cpy #$04
  171 A:f8c7  90 f2                              bcc prntbl
  172 A:f8c9  68                                 pla                    ; recover mnemonic index
  173 A:f8ca  a8                                 tay 
  174 A:f8cb  b9 a0 f9                           lda mneml,y
  175 A:f8ce  85 2c                              sta lmnem                ; fetch 3 char mnemonic
  176 A:f8d0  b9 e0 f9                           lda mnemr,y              ;   (packed in 2 bytes, only chars A-Z
  177 A:f8d3  85 2d                              sta rmnem
  178 A:f8d5                           prmn1     
  178 A:f8d5  a9 00                              lda #$00
  179 A:f8d7  a0 05                              ldy #$05
  180 A:f8d9                           prnm2     
  180 A:f8d9  06 2d                              asl rmnem                ; shift 5 bits of
  181 A:f8db  26 2c                              rol lmnem                ;   character into Accu
  182 A:f8dd  2a                                 rol                    ;      (clears carry)
  183 A:f8de  88                                 dey 
  184 A:f8df  d0 f8                              bne prnm2
  185 A:f8e1  69 3f                              adc #'?'             ; add "?" offset
  186 A:f8e3  20 82 fd                           jsr cout                ; output a char of mnem
  187 A:f8e6  ca                                 dex 
  188 A:f8e7  d0 ec                              bne prmn1
  189 A:f8e9  20 28 f9                           jsr prblnk                ; output 3 blanks
  190 A:f8ec  a4 2f                              ldy length
  191 A:f8ee  a2 06                              ldx #$06             ; count for 6 format bits
  192 A:f8f0                           pradr1    
  192 A:f8f0  e0 03                              cpx #$03
  193 A:f8f2  f0 1c                              beq pradr5                ; if x=3 then addr
  194 A:f8f4                           pradr2    
  194 A:f8f4  06 2e                              asl format
  195 A:f8f6  90 0e                              bcc pradr3
  196 A:f8f8  bd 93 f9                           lda char1-1,x
  197 A:f8fb  20 82 fd                           jsr cout
  198 A:f8fe  bd 99 f9                           lda char2-1,x
  199 A:f901  f0 03                              beq pradr3
  200 A:f903  20 82 fd                           jsr cout
  201 A:f906                           pradr3    
  201 A:f906  ca                                 dex 
  202 A:f907  d0 e7                              bne pradr1
  203 A:f909  60                                 rts 
  204 A:f90a                           pradr4    
  204 A:f90a  88                                 dey 
  205 A:f90b  30 e7                              bmi pradr2
  206 A:f90d  20 6f fd                           jsr prbyte
  207 A:f910                           pradr5    
  207 A:f910  a5 2e                              lda format
  208 A:f912  c9 e8                              cmp #$e8             ; handle relative address mode
  209 A:f914  b1 3a                              lda (pcl),y            ;  special (print target, not offset)
  210 A:f916  90 f2                              bcc pradr4
  211 A:f918                           reladr    
  211 A:f918  20 36 f9                           jsr pcadj3
  212 A:f91b  aa                                 tax                    ; pcl,pch+offset+1 to a,y
  213 A:f91c  e8                                 inx 
  214 A:f91d  d0 01                              bne prntyx                ; +1 to y,x
  215 A:f91f  c8                                 iny 
  216 A:f920                                    ;
  217 A:f920                                    ; print y and x  as 4 digit hex number
  218 A:f920                                    ;
  219 A:f920                           prntyx    
  219 A:f920  98                                 tya 
  220 A:f921                           prntax    
  220 A:f921  20 6f fd                           jsr prbyte                ; output target adr
  221 A:f924                           prntx     
  221 A:f924  8a                                 txa                    ;    of branch and return
  222 A:f925  4c 6f fd                           jmp prbyte
  223 A:f928                           prblnk    
  223 A:f928  a2 03                              ldx #$03             ; blank count
  224 A:f92a                           prbl2     
  224 A:f92a  a9 20                              lda #' '             ; load a space
  225 A:f92c                           prbl3     
  225 A:f92c  20 82 fd                           jsr cout                ; output a blank
  226 A:f92f  ca                                 dex 
  227 A:f930  d0 f8                              bne prbl2
  228 A:f932  60                                 rts 
  229 A:f933                           pcadj     
  229 A:f933  38                                 sec                    ; 0=1-byte, 1=2-byte,
  230 A:f934                           pcadj2    
  230 A:f934  a5 2f                              lda length                ;   2=3-byte
  231 A:f936                           pcadj3    
  231 A:f936  a4 3b                              ldy pch
  232 A:f938  aa                                 tax                    ; test displacement sign
  233 A:f939  10 01                              bpl pcadj4                ;   (for rel branch)
  234 A:f93b  88                                 dey 
  235 A:f93c                           pcadj4    
  235 A:f93c  65 3a                              adc pcl
  236 A:f93e  90 01                              bcc rts2                ; pcl+LENGTH(or Displc.)+1 to A
  237 A:f940  c8                                 iny                    ;   carry inot y (pch)
  238 A:f941                           rts2      
  238 A:f941  60                                 rts 
  239 A:f942                                    ;
  240 A:f942                                    ; fmt1 bytes
  240 A:f942                           XXXXXXY0 instructions 
  241 A:f942                                    ;       if Y=0
  241 A:f942                           then left half byte 
  242 A:f942                                    ;       if Y=1  then right half byte
  243 A:f942                                    ;                    (X=index)
  244 A:f942                           fmt1      
  244 A:f942  04 20 54 30 0d                     .byt $04,$20,$54,$30,$0d
  245 A:f947  80 04 90 03 22                     .byt $80,$04,$90,$03,$22
  246 A:f94c  54 33 0d 80 04                     .byt $54,$33,$0d,$80,$04
  247 A:f951  90 04 20 54 33                     .byt $90,$04,$20,$54,$33
  248 A:f956  0d 80 04 90 04                     .byt $0d,$80,$04,$90,$04
  249 A:f95b  20 54 3b 0d 80                     .byt $20,$54,$3b,$0d,$80
  250 A:f960  04 90 00 22 44                     .byt $04,$90,$00,$22,$44
  251 A:f965  33 0d c8 44 00                     .byt $33,$0d,$c8,$44,$00
  252 A:f96a  11 22 44 33 0d                     .byt $11,$22,$44,$33,$0d
  253 A:f96f  c8 44 a9 01 22                     .byt $c8,$44,$a9,$01,$22
  254 A:f974  44 33 0d 80 04                     .byt $44,$33,$0d,$80,$04
  255 A:f979  90 01 22 44 33                     .byt $90,$01,$22,$44,$33
  256 A:f97e  0d 80 04 90                        .byt $0d,$80,$04,$90
  257 A:f982  26 31 87 9a                        .byt $26,$31,$87,$9a; ZZXXXXY01 instructions
  258 A:f986                           fmt2      
  258 A:f986  00                                 .byt $00              ; ERR
  259 A:f987  21                                 .byt $21              ; IMM
  260 A:f988  81                                 .byt $81              ; Z-PAGE
  261 A:f989  82                                 .byt $82              ; ABS
  262 A:f98a  00                                 .byt $00              ; IMPLIED
  263 A:f98b  00                                 .byt $00              ; ACCUMULATOR
  264 A:f98c  59                                 .byt $59              ; (ZPAG,X)
  265 A:f98d  4d                                 .byt $4d              ; (ZPAG),Y
  266 A:f98e  91                                 .byt $91              ; ZPAG,X
  267 A:f98f  92                                 .byt $92              ; ABS,X
  268 A:f990  86                                 .byt $86              ; ABS,Y
  269 A:f991  4a                                 .byt $4a              ; (ABS)
  270 A:f992  85                                 .byt $85              ; ZPAG,Y
  271 A:f993  9d                                 .byt $9d              ; RELATIVE
  272 A:f994                           char1     
  272 A:f994  2c 29 2c 23 28 24                  .byt ',',')',',','#','(','$'
  273 A:f99a                           char2     
  273 A:f99a  59 00 58 24 24 00                  .byt 'Y',0,"X$$",0
  274 A:f9a0                                    ;
  275 A:f9a0                                    ; mneml is of form
  275 A:f9a0                                    
  276 A:f9a0                                    ; (A) XXXXX000
  277 A:f9a0                                    ; (B) XXXYY100
  278 A:f9a0                                    ; (C) 1XXX1010
  279 A:f9a0                                    ; (D) XXXYYY10
  280 A:f9a0                                    ; (E) XXXYYY01
  281 A:f9a0                                    ;     (X=index)
  282 A:f9a0                           mneml     
  282 A:f9a0  1c 8a 1c 23 5d 8b                  .byt $1c,$8a,$1c,$23,$5d,$8b
  283 A:f9a6  1b a1 9d 8a 1d 23                  .byt $1b,$a1,$9d,$8a,$1d,$23
  284 A:f9ac  9d 8b 1d a1 00 29                  .byt $9d,$8b,$1d,$a1,$00,$29
  285 A:f9b2  19 ae 69 a8 19 23                  .byt $19,$ae,$69,$a8,$19,$23
  286 A:f9b8  24 53 1b 23 24 53                  .byt $24,$53,$1b,$23,$24,$53
  287 A:f9be  19 a1                              .byt $19,$a1        ; (A) Format Above
  288 A:f9c0  00 1a 5b 5b a5 69                  .byt $00,$1a,$5b,$5b,$a5,$69
  289 A:f9c6  24 24                              .byt $24,$24        ; (B) Format
  290 A:f9c8  ae ae a8 ad 29 00                  .byt $ae,$ae,$a8,$ad,$29,$00
  291 A:f9ce  7c 00                              .byt $7c,$00        ; (C) Format
  292 A:f9d0  15 9c 6d 9c a5 69                  .byt $15,$9c,$6d,$9c,$a5,$69
  293 A:f9d6  29 53                              .byt $29,$53        ; (D) Format
  294 A:f9d8  84 13 34 11 a5 69                  .byt $84,$13,$34,$11,$a5,$69
  295 A:f9de  23 a0                              .byt $23,$a0        ; (E) Format
  296 A:f9e0                           mnemr     
  296 A:f9e0  d8 62 5a 48 26 62                  .byt $d8,$62,$5a,$48,$26,$62
  297 A:f9e6  94 88 54 44 c8 54                  .byt $94,$88,$54,$44,$c8,$54
  298 A:f9ec  68 44 e8 94 00 b4                  .byt $68,$44,$e8,$94,$00,$b4
  299 A:f9f2  08 84 74 b4 28 6e                  .byt $08,$84,$74,$b4,$28,$6e
  300 A:f9f8  74 f4 cc 4a 72 f2                  .byt $74,$f4,$cc,$4a,$72,$f2
  301 A:f9fe  a4 8a                              .byt $a4,$8a        ; (A) Format
  302 A:fa00  00 aa a2 a2 74 74                  .byt $00,$aa,$a2,$a2,$74,$74
  303 A:fa06  74 72                              .byt $74,$72        ; (B) Format
  304 A:fa08  44 68 b2 32 b2 00                  .byt $44,$68,$b2,$32,$b2,$00
  305 A:fa0e  22 00                              .byt $22,$00        ; (C) Format
  306 A:fa10  1a 1a 26 26 72 72                  .byt $1a,$1a,$26,$26,$72,$72
  307 A:fa16  88 c8                              .byt $88,$c8        ; (D) Format
  308 A:fa18  c4 ca 26 48 44 44                  .byt $c4,$ca,$26,$48,$44,$44
  309 A:fa1e  a2 c8                              .byt $a2,$c8        ; (E) Format
  310 A:fa20  ff ff ff                           .byt $ff,$ff,$ff
  311 A:fa23                                    ;
  312 A:fa23                                    ; monitor stepping
  313 A:fa23                                    ; this is nice... it emulates itself to execute a program stepwise
  314 A:fa23                                    ;
  315 A:fa23                           step      
  315 A:fa23  20 b0 f8                           jsr instdsp                ; disassemble one instruction
  316 A:fa26  68                                 pla                    ;   at (pcl,h)
  317 A:fa27  85 2c                              sta rtnl                ; adjust to user
  318 A:fa29  68                                 pla                    ;   stack, save
  319 A:fa2a  85 2d                              sta rtnh                ;   return address
  320 A:fa2c  a2 08                              ldx #$08
  321 A:fa2e                           xqinit    
  321 A:fa2e  bd f0 fa                           lda initbl-1,x        ; init xeq (execute) area
  322 A:fa31  95 3c                              sta xqt,x
  323 A:fa33  ca                                 dex 
  324 A:fa34  d0 f8                              bne xqinit
  325 A:fa36  a1 3a                              lda (pcl,x)            ; user opcode byte
  326 A:fa38  f0 42                              beq xbrk                ; special if BRK
  327 A:fa3a  a4 2f                              ldy length                ; LEN from disassembly
  328 A:fa3c  c9 20                              cmp #$20
  329 A:fa3e  f0 59                              beq xjsr                ; handle jsr, rts, jmp,
  330 A:fa40  c9 60                              cmp #$60             ;   jmp (), rti special
  331 A:fa42  f0 45                              beq xrts
  332 A:fa44  c9 4c                              cmp #$4c
  333 A:fa46  f0 5c                              beq xjmp
  334 A:fa48  c9 6c                              cmp #$6c
  335 A:fa4a  f0 59                              beq xjmpat
  336 A:fa4c  c9 40                              cmp #$40
  337 A:fa4e  f0 35                              beq xrti
  338 A:fa50  29 1f                              and #$1f             ; TODO comment
  339 A:fa52  49 14                              eor #$14
  340 A:fa54  c9 04                              cmp #$04             ; copy user instruction to xeq area
  341 A:fa56  f0 02                              beq xq2                ;   with trailing nops
  342 A:fa58                           xq1       
  342 A:fa58  b1 3a                              lda (pcl),y            ; change rel branch
  343 A:fa5a                           xq2       
  343 A:fa5a  99 3c 00                           sta xqtnz,y              ;   disp to 4 for
  344 A:fa5d  88                                 dey                    ;   jmp to branch or
  345 A:fa5e  10 f8                              bpl xq1                ;   nbranch from xeq
  346 A:fa60  20 1d ff                           jsr restore                ; restore user reg contents
  347 A:fa63  4c 3c 00                           jmp xqtnz                ; xeq (execute) user op from RAM
  348 A:fa66                           irqvec    
  348 A:fa66  85 45                              sta acc                ;    (return to nbranch)
  349 A:fa68  68                                 pla                    ; fetch p status register into a
  350 A:fa69  48                                 pha                    ; * * IRQ handler
  351 A:fa6a  0a                                 asl 
  352 A:fa6b  0a                                 asl 
  353 A:fa6c  0a                                 asl                    ; put B flag in high bit
  354 A:fa6d  30 03                              bmi break                ; if set, handle BRK
  355 A:fa6f  6c fe 03                           jmp (irqloc)              ; user routine vector in RAM
  356 A:fa72                           break     
  356 A:fa72  28                                 plp 
  357 A:fa73  20 2a ff                           jsr sav1                ; save regs on break
  358 A:fa76  68                                 pla                    ; including pc
  359 A:fa77  85 3a                              sta pcl
  360 A:fa79  68                                 pla 
  361 A:fa7a  85 3b                              sta pch
  362 A:fa7c                           xbrk      
  362 A:fa7c  20 62 f8                           jsr insds1                ; print user pc
  363 A:fa7f  20 ba fa                           jsr rgdsp1                ;   and registers
  364 A:fa82  4c 46 ff                           jmp mon                ; go to monitor
  365 A:fa85                           xrti      
  365 A:fa85  18                                 clc 
  366 A:fa86  68                                 pla                    ; simulate rti by expecting
  367 A:fa87  85 48                              sta status                ;    status from stack, then rts
  368 A:fa89                           xrts      
  368 A:fa89  68                                 pla                    ; rts simulation
  369 A:fa8a  85 3a                              sta pcl                ;   extract pc from stack
  370 A:fa8c  68                                 pla                    ; and update pc by 1 (LEN=0)
  371 A:fa8d                           pcinc2    
  371 A:fa8d  85 3b                              sta pch
  372 A:fa8f                           pcinc3    
  372 A:fa8f  a5 2f                              lda length                ; update pc by LEN
  373 A:fa91  20 36 f9                           jsr pcadj3
  374 A:fa94  84 3b                              sty pch
  375 A:fa96  18                                 clc                    ; short unconditional jump
  376 A:fa97  90 14                              bcc newpcl                ;  CLC BCC #rel
  377 A:fa99                           xjsr      
  377 A:fa99  18                                 clc 
  378 A:fa9a  20 34 f9                           jsr pcadj2                ; update pc and push
  379 A:fa9d  aa                                 tax                    ;   onto stack for
  380 A:fa9e  98                                 tya                    ;   JSR simulate
  381 A:fa9f  48                                 pha 
  382 A:faa0  8a                                 txa 
  383 A:faa1  48                                 pha 
  384 A:faa2  a0 02                              ldy #$02
  385 A:faa4                           xjmp      
  385 A:faa4  18                                 clc 
  386 A:faa5                           xjmpat    
  386 A:faa5  b1 3a                              lda (pcl),Y
  387 A:faa7  aa                                 tax                    ; load pc for jump,
  388 A:faa8  88                                 dey                    ;   (JMP) simulate
  389 A:faa9  b1 3a                              lda (pcl),y
  390 A:faab  86 3b                              stx pch
  391 A:faad                           newpcl    
  391 A:faad  85 3a                              sta pcl
  392 A:faaf  b0 f3                              bcs xjmp
  393 A:fab1                           rtnjmp    
  393 A:fab1  a5 2d                              lda rtnh
  394 A:fab3  48                                 pha 
  395 A:fab4  a5 2c                              lda rtnl
  396 A:fab6  48                                 pha 
  397 A:fab7                           regdsp    
  397 A:fab7  20 23 fd                           jsr crout                ; display user reg
  398 A:faba                           rgdsp1    
  398 A:faba  a9 45                              lda #<acc              ;  contents with
  399 A:fabc  85 40                              sta a3l                ;  labels
  400 A:fabe  a9 00                              lda #>acc
  401 A:fac0  85 41                              sta a3h
  402 A:fac2  a2 fb                              ldx #$fb
  403 A:fac4                           rdsp1     
  403 A:fac4  a9 20                              lda #' '
  404 A:fac6  20 82 fd                           jsr cout                ; output space
  405 A:fac9  bd fe f9                           lda rtbl-$fb,x        ; register name (x has FB so base address = rtbl - FB)
  406 A:facc  20 82 fd                           jsr cout
  407 A:facf  a9 3d                              lda #'='             ; '='
  408 A:fad1  20 82 fd                           jsr cout
  409 A:fad4  b5 4a                              lda acc+5,x
  410 A:fad6  20 6f fd                           jsr prbyte
  411 A:fad9  e8                                 inx 
  412 A:fada  30 e8                              bmi rdsp1
  413 A:fadc  60                                 rts 
  414 A:fadd                           branch    
  414 A:fadd  18                                 clc                    ; branch taken,
  415 A:fade  a0 01                              ldy #$01             ;  add LEN+2 to pc
  416 A:fae0  b1 3a                              lda (pcl),y
  417 A:fae2  20 36 f9                           jsr pcadj3
  418 A:fae5  85 3a                              sta pcl
  419 A:fae7  98                                 tya 
  420 A:fae8  38                                 sec 
  421 A:fae9  b0 a2                              bcs pcinc2
  422 A:faeb                           nbranch   
  422 A:faeb  20 28 ff                           jsr save                ; normal return after
  423 A:faee  38                                 sec                    ;   xeq user of
  424 A:faef  b0 9e                              bcs pcinc3                ; go update pc
  425 A:faf1                           initbl    
  425 A:faf1  ea                                 nop 
  426 A:faf2  ea                                 nop                    ; dummy fill for
  427 A:faf3  4c eb fa                           jmp nbranch                ;   xeq area
  428 A:faf6  4c dd fa                           jmp branch
  429 A:faf9                           rtbl      
  429 A:faf9  41                                 .byt 'A'
  430 A:fafa  58                                 .byt 'X'
  431 A:fafb  59                                 .byt 'Y'
  432 A:fafc  50                                 .byt 'P'
  433 A:fafd  53                                 .byt 'S'
  434 A:fafe                           pread     
  434 A:fafe  ad 70 c0                           lda ptrig                ; paddle read; trigger paddles
  435 A:fb01  a0 00                              ldy #$00             ; init count
  436 A:fb03  ea                                 nop                    ; compensate timing for first count
  437 A:fb04  ea                                 nop                    ; 2 x 2 cycles
  438 A:fb05                           pread2    
  438 A:fb05  bd 61 c0                           lda paddl0,x              ; count y-reg
  439 A:fb08  10 04                              bpl rts2d                ;    every 12 usec
  440 A:fb0a  c8                                 iny 
  441 A:fb0b  d0 f8                              bne pread2                ;    exit at 255 max
  442 A:fb0d  88                                 dey 
  443 A:fb0e                           rts2d     
  443 A:fb0e  60                                 rts 
  444 A:fb0f                           init      
  444 A:fb0f  a9 00                              lda #$00             ; clr status for debug
  445 A:fb11  85 48                              sta status                ;   software
  446 A:fb13                           settxt    
  446 A:fb13  a9 00                              lda #$00             ;   full screen window
  447 A:fb15                           setwnd    
  447 A:fb15  85 22                              sta wndtop                ; set for 40 col window
  448 A:fb17  a9 00                              lda #$00             ;    top in accu,
  449 A:fb19  85 20                              sta wndlft                ;    bottom at line 24
  450 A:fb1b  ad 17 c0                           lda termww                ; get terminal window width
  451 A:fb1e  85 21                              sta wndwdth
  452 A:fb20  ad 16 c0                           lda termwh                ; get terminal window height
  453 A:fb23  85 23                              sta wndbtm
  454 A:fb25  38                                 sec 
  455 A:fb26  e9 01                              sbc #$01             ; last possible row in window
  456 A:fb28                           tabv      
  456 A:fb28  85 25                              sta cv                ; vtabs to row in accu
  457 A:fb2a  60                                 rts 
  458 A:fb2b                           mulpm     
  458 A:fb2b  20 6f fb                           jsr md1                ; abs value of ac, aux
  459 A:fb2e                           mul       
  459 A:fb2e  a0 10                              ldy #$10             ; index for 16 bits
  460 A:fb30                           mul2      
  460 A:fb30  a5 50                              lda acl                ; acx * aux + xtnd
  461 A:fb32  4a                                 lsr                    ;  to ac, xtnd
  462 A:fb33  90 0c                              bcc mul4                ; if no carry,
  463 A:fb35  18                                 clc                    ;   no partial product
  464 A:fb36  a2 fe                              ldx #$fe
  465 A:fb38                           mul3      
  465 A:fb38  b5 54                              lda xtndl+2,x        ; add multiplicant (aux)
  466 A:fb3a  75 56                              adc auxl+2,x        ;   to partial product
  467 A:fb3c  95 54                              sta xtndl+2,x        ;     (xtnd)
  468 A:fb3e  e8                                 inx 
  469 A:fb3f  d0 f7                              bne mul3
  470 A:fb41                           mul4      
  470 A:fb41  a2 03                              ldx #$03
  471 A:fb43                           mul5      
  471 A:fb43  76 50                              ror acl,x              ; orig DFB #$76, #$50 ?!? maybe a bug in their assembler software
  472 A:fb45  ca                                 dex 
  473 A:fb46  10 fb                              bpl mul5
  474 A:fb48  88                                 dey 
  475 A:fb49  d0 e5                              bne mul2
  476 A:fb4b  60                                 rts 
  477 A:fb4c                           divpm     
  477 A:fb4c  20 6f fb                           jsr md1                ; abs value of ac, aux
  478 A:fb4f                           div       
  478 A:fb4f  a0 10                              ldy #$10             ; index for 16 bits
  479 A:fb51                           div2      
  479 A:fb51  06 51                              asl ach
  480 A:fb53  26 51                              rol ach
  481 A:fb55  26 52                              rol xtndl                ; xtnd/aux
  482 A:fb57  26 53                              rol xtndh                ;   to ac.
  483 A:fb59  38                                 sec 
  484 A:fb5a  a5 52                              lda xtndl
  485 A:fb5c  e5 54                              sbc auxl                ; mod to xtnd
  486 A:fb5e  aa                                 tax 
  487 A:fb5f  a5 53                              lda xtndh
  488 A:fb61  e5 55                              sbc auxh
  489 A:fb63  90 06                              bcc div3
  490 A:fb65  86 52                              stx xtndl
  491 A:fb67  85 53                              sta xtndh
  492 A:fb69  e6 50                              inc acl
  493 A:fb6b                           div3      
  493 A:fb6b  88                                 dey 
  494 A:fb6c  d0 e3                              bne div2
  495 A:fb6e  60                                 rts 
  496 A:fb6f                           md1       
  496 A:fb6f  a0 00                              ldy #$00             ; abs value of ac, aux
  497 A:fb71  84 2f                              sty sign                ;   with result sign
  498 A:fb73  a2 54                              ldx #auxl               ;   in lsb of sign
  499 A:fb75  20 7a fb                           jsr md2
  500 A:fb78  a2 50                              ldx #acl
  501 A:fb7a                           md2       
  501 A:fb7a  b5 01                              lda loc1,x              ; x specifies ac or aux
  502 A:fb7c  10 0d                              bpl mdrts
  503 A:fb7e  38                                 sec 
  504 A:fb7f                           md3       
  504 A:fb7f  98                                 tya 
  505 A:fb80  f5 00                              sbc loc0,x              ; compl specified reg
  506 A:fb82  95 00                              sta loc0,x              ;   if negative
  507 A:fb84  98                                 tya 
  508 A:fb85  f5 01                              sbc loc1,x
  509 A:fb87  95 01                              sta loc1,x
  510 A:fb89  e6 2f                              inc sign
  511 A:fb8b                           mdrts     
  511 A:fb8b  60                                 rts 

  513 A:fb8c                           bell1     
  513 A:fb8c  a9 07                              lda #k_ctl_g               ; output bell and return
  514 A:fb8e  8d 12 c0                           sta termout                ; pit to term directly here...
  515 A:fb91  60                                 rts 
  516 A:fb92  ea ff 10 00 00 24 2c ...           .dsb $10,$ea
  517 A:fba2                           rts2b     
  517 A:fba2  60                                 rts 
  518 A:fba3                                    ;
  519 A:fba3                                    ; Store terminal char output and advance screen cursor
  520 A:fba3                                    ;
  521 A:fba3                           stoadv    
  521 A:fba3  a4 25                              ldy cv                ; cursor y index to y register
  522 A:fba5  8c 10 c0                           sty termcy                ; set terminal cursor y
  523 A:fba8  a4 24                              ldy ch                ; cursor h index to y register
  524 A:fbaa  8c 11 c0                           sty termcx                ; set terminal cursor x
  525 A:fbad  a4 32                              ldy invflg                ;
  526 A:fbaf  8c 13 c0                           sty termesc                ; invflg has the command byte for the char attribute normal or reverse
  527 A:fbb2  8d 12 c0                           sta termout                ; output char
  528 A:fbb5                                    ;
  529 A:fbb5                                    ; advance cursor
  530 A:fbb5                                    ;
  531 A:fbb5                                    ; add next line routine if cursor proceeds to right margin
  532 A:fbb5                                    ;
  533 A:fbb5                           advance   
  533 A:fbb5  e6 24                              inc ch                ; increment cursor h index
  534 A:fbb7  a5 24                              lda ch                ;   (move right)
  535 A:fbb9  c5 21                              cmp wndwdth                ; beyond window width?
  536 A:fbbb  b0 4e                              bcs cr                ;   yes, cr to next line
  537 A:fbbd                           rts3      
  537 A:fbbd  60                                 rts                    ; no, return
  538 A:fbbe                                    ;
  539 A:fbbe                                    ; Video out
  540 A:fbbe                                    ;
  541 A:fbbe                                    ; Write character to terminal I/O
  542 A:fbbe                                    ;
  543 A:fbbe                           vidout    
  543 A:fbbe  c9 20                              cmp #' '             ; control char?
  544 A:fbc0  b0 e1                              bcs stoadv                ;   no, output it
  545 A:fbc2  c9 0a                              cmp #k_entr               ; CR?  0x1D | 0x80
  546 A:fbc4  f0 45                              beq cr                ;   yes
  547 A:fbc6  c9 0a                              cmp #k_lf               ; LF?
  548 A:fbc8  f0 45                              beq lf                ;   yes
  549 A:fbca  c9 08                              cmp #k_bs               ; backspace (CTRL-H)?
  550 A:fbcc  d0 be                              bne bell1                ;   no, check for bell
  551 A:fbce                           bs        
  551 A:fbce  c6 24                              dec ch                ; decrement cursor h index
  552 A:fbd0  10 eb                              bpl rts3                ; if pos, ok, else move up
  553 A:fbd2  a5 21                              lda wndwdth                ; set ch to wndwdth-1
  554 A:fbd4  85 24                              sta ch
  555 A:fbd6  c6 24                              dec ch                ; rightmost screen position
  556 A:fbd8                           up        
  556 A:fbd8  a5 22                              lda wndtop                ; cursor v index
  557 A:fbda  c5 25                              cmp cv
  558 A:fbdc  b0 02                              bcs rts4                ; if top line then return
  559 A:fbde  c6 25                              dec cv                ; decr cursor v
  560 A:fbe0                           rts4      
  560 A:fbe0  60                                 rts 
  561 A:fbe1                           esc1      
  561 A:fbe1  49 1b                              eor #k_esc               ; esc?
  562 A:fbe3  f0 1c                              beq home                ;   if so, do home and clear
  563 A:fbe5  e9 02                              sbc #$02             ; esc-a or -b check
  564 A:fbe7  30 cc                              bmi advance                ;   a, advance
  565 A:fbe9  f0 e3                              beq bs                ;   b, backspace
  566 A:fbeb  e9 02                              sbc #$02             ; esc-c or -d check
  567 A:fbed  30 20                              bmi lf                ;   c, down
  568 A:fbef  f0 e7                              beq up                ;   d, go up
  569 A:fbf1  e9 02                              sbc #$02             ; esc-e or -f check
  570 A:fbf3  90 2a                              bcc clreol                ;   e, clear to end of line
  571 A:fbf5  d0 e9                              bne rts4                ;   not f, return
  572 A:fbf7                           clreop    
  572 A:fbf7  a4 24                              ldy ch                ; cursor h to y
  573 A:fbf9  a5 25                              lda cv                ; cursor v to a
  574 A:fbfb                           cleop1    
  574 A:fbfb  48                                 pha                    ; save current line on stk
  575 A:fbfc  a9 00                              lda #t_cls               ; clear screen command
  576 A:fbfe  8d 13 c0                           sta termesc                ; send to terminal
  577 A:fc01                           home      
  577 A:fc01  a5 22                              lda wndtop                ; init cursor v
  578 A:fc03  85 25                              sta cv                ;   and h-indices
  579 A:fc05  a0 00                              ldy #$00
  580 A:fc07  84 24                              sty ch                ; then clear to end of page
  581 A:fc09  f0 f0                              beq cleop1
  582 A:fc0b                           cr        
  582 A:fc0b  a9 00                              lda #$00             ; cursor to left of index
  583 A:fc0d  85 24                              sta ch
  584 A:fc0f                           lf        
  584 A:fc0f  e6 25                              inc cv                ; incr cursor v (down 1 line)
  585 A:fc11  a5 25                              lda cv
  586 A:fc13  c5 23                              cmp wndbtm                ; off screen?
  587 A:fc15  90 c9                              bcc rts4                ;   no, done
  588 A:fc17  c6 25                              dec cv                ; decr cursor v (back to bottom)
  589 A:fc19                           scroll    
  589 A:fc19  a9 03                              lda #t_scr               ; scroll command
  590 A:fc1b  8d 13 c0                           sta termesc                ; let the terminal scroll.
  591 A:fc1e  60                                 rts 
  592 A:fc1f                           clreol    
  592 A:fc1f  a9 01                              lda #t_cll               ; clear to eol command
  593 A:fc21  8d 13 c0                           sta termesc                ; execute
  594 A:fc24  60                                 rts 
  595 A:fc25                           wait      
  595 A:fc25  38                                 sec 
  596 A:fc26                           wait2     
  596 A:fc26  48                                 pha 
  597 A:fc27                           wait3     
  597 A:fc27  e9 01                              sbc #$01
  598 A:fc29  d0 fc                              bne wait3                ; 1.02.4 uSec
  599 A:fc2b  68                                 pla                    ; (13+2712*A+512*A*A) on 1 MHz
  600 A:fc2c  e9 01                              sbc #$01
  601 A:fc2e  d0 f6                              bne wait2                ; busy, busy, busy waiting
  602 A:fc30  60                                 rts 
  603 A:fc31                           nxta4     
  603 A:fc31  e6 42                              inc a4l                ; incr 2-byte a4
  604 A:fc33  d0 02                              bne nxta1                ;  and a1
  605 A:fc35  e6 43                              inc a4h
  606 A:fc37                           nxta1     
  606 A:fc37  a5 3c                              lda a1l                ; incr 2-byte a1
  607 A:fc39  c5 3e                              cmp a2l
  608 A:fc3b  a5 3d                              lda a1h                ;   and compare to a2
  609 A:fc3d  e5 3f                              sbc a2h
  610 A:fc3f  e6 3c                              inc a1l                ;  carry set if >=
  611 A:fc41  d0 02                              bne rts4b
  612 A:fc43  e6 3d                              inc a1h
  613 A:fc45                           rts4b     
  613 A:fc45  60                                 rts 
  614 A:fc46                           headr     
  614 A:fc46  a0 4b                              ldy #$4b             ; write or skip A * 256 'long 1'
  615 A:fc48  20 58 fc                           jsr zerdly                ;   half cycles
  616 A:fc4b  d0 f9                              bne headr                ;     (650 usec each)
  617 A:fc4d  69 fe                              adc #$fe
  618 A:fc4f  b0 f5                              bcs headr                ; then a 'short 0'
  619 A:fc51  a0 21                              ldy #$21             ;    (400 usec)
  620 A:fc53                           wrbit     
  620 A:fc53  20 58 fc                           jsr zerdly                ; write two half cycles
  621 A:fc56  c8                                 iny                    ;   of 250 usec ('0')
  622 A:fc57  c8                                 iny                    ;   or 500 usec ('0')
  623 A:fc58                           zerdly    
  623 A:fc58  88                                 dey                    ; it means 'zero delay'
  624 A:fc59  d0 fd                              bne zerdly
  625 A:fc5b  90 05                              bcc wrtape                ; y is count for
  626 A:fc5d  a0 32                              ldy #$32             ;   timing loop
  627 A:fc5f                           onedly    
  627 A:fc5f  88                                 dey                    ; 'ones delay'
  628 A:fc60  d0 fd                              bne onedly
  629 A:fc62                           wrtape    
  629 A:fc62  48                                 pha 
  630 A:fc63  a4 26                              ldy tpdir
  631 A:fc65  b9 20 c0                           lda tapeout,y              ; y=0 - tape out, y=1 - tape in
  632 A:fc68  68                                 pla 
  633 A:fc69  a0 2c                              ldy #$2c
  634 A:fc6b  ca                                 dex 
  635 A:fc6c  60                                 rts 
  636 A:fc6d                           rdbyte    
  636 A:fc6d  a2 08                              ldx #$08             ; 8 bits to read
  637 A:fc6f                           rdbyt2    
  637 A:fc6f  48                                 pha                    ; read two transitions
  638 A:fc70  20 7b fc                           jsr rd2bit                ;   (find edge)
  639 A:fc73  68                                 pla 
  640 A:fc74  2a                                 rol                    ; next bit
  641 A:fc75  a0 3a                              ldy #$3a             ; count for samples
  642 A:fc77  ca                                 dex 
  643 A:fc78  d0 f5                              bne rdbyt2
  644 A:fc7a  60                                 rts 
  645 A:fc7b                           rd2bit    
  645 A:fc7b  20 7e fc                           jsr rdbit
  646 A:fc7e                           rdbit     
  646 A:fc7e  88                                 dey                    ; decr y until
  647 A:fc7f  ad 21 c0                           lda tapein                ;   tape transition
  648 A:fc82  45 2f                              eor lastin
  649 A:fc84  10 f8                              bpl rdbit
  650 A:fc86  45 2f                              eor lastin
  651 A:fc88  85 2f                              sta lastin
  652 A:fc8a  c0 80                              cpy #$80             ; set carry on y register
  653 A:fc8c  60                                 rts 
  654 A:fc8d                           charout   
  654 A:fc8d  a4 25                              ldy cv                ; cursor y index to y register
  655 A:fc8f  8c 10 c0                           sty termcy                ; set terminal cursor y
  656 A:fc92  a4 24                              ldy ch                ; cursor h index to y register
  657 A:fc94  8c 11 c0                           sty termcx                ; set terminal cursor x
  658 A:fc97  8d 12 c0                           sta termout                ; output char
  659 A:fc9a  60                                 rts 
  660 A:fc9b                           rdkey     
  660 A:fc9b  a0 06                              ldy #t_blnk               ; set screen to flash
  661 A:fc9d  8c 13 c0                           sty termesc
  662 A:fca0  ad 12 c0                           lda termout                ; get char at cursor pos.
  663 A:fca3  20 8d fc                           jsr charout
  664 A:fca6  a0 04                              ldy #t_norm               ; set screen back to normal after
  665 A:fca8  8c 13 c0                           sty termesc
  666 A:fcab  6c 38 00                           jmp (kswl)              ; go to user key-in
  667 A:fcae                           keyin     
  667 A:fcae  e6 4e                              inc rndl
  668 A:fcb0  d0 02                              bne keyin2                ; inc random number
  669 A:fcb2  e6 4f                              inc rndh
  670 A:fcb4                           keyin2    
  670 A:fcb4  ad 00 c0                           lda kbd
  671 A:fcb7  f0 f5                              beq keyin                ; busy waiting loop until key != 0...
  672 A:fcb9  20 8d fc                           jsr charout                ; replace flashing screen
  673 A:fcbc  2c 01 c0                           bit kbdstrb                ; clear key strobe
  674 A:fcbf  60                                 rts 
  675 A:fcc0                           esc       
  675 A:fcc0  20 9b fc                           jsr rdkey                ; get keycode
  676 A:fcc3  20 e1 fb                           jsr esc1                ;  handle esc function
  677 A:fcc6                           rdchar    
  677 A:fcc6  20 9b fc                           jsr rdkey                ; read key
  678 A:fcc9  c9 1b                              cmp #k_esc               ; ESC?
  679 A:fccb  f0 f3                              beq esc                ;   yes, don't return
  680 A:fccd  60                                 rts 
  681 A:fcce                           notcr     
  681 A:fcce  a5 32                              lda invflg
  682 A:fcd0  48                                 pha 
  683 A:fcd1  a9 04                              lda #t_norm
  684 A:fcd3  85 32                              sta invflg                ; echo user line
  685 A:fcd5  bd 00 02                           lda in,x              ;   non inverse
  686 A:fcd8  20 82 fd                           jsr cout
  687 A:fcdb  68                                 pla 
  688 A:fcdc  85 32                              sta invflg
  689 A:fcde  bd 00 02                           lda in,x
  690 A:fce1  c9 08                              cmp #k_bs               ; check for edit keys
  691 A:fce3  f0 20                              beq bckspc                ;  bs, ctrl-x
  692 A:fce5  c9 18                              cmp #k_ctl_x
  693 A:fce7  f0 0a                              beq cancel
  694 A:fce9  e0 f8                              cpx #$f8             ; margin?
  695 A:fceb  90 03                              bcc notcr1
  696 A:fced  20 18 ff                           jsr bell                ; yes, sound bell
  697 A:fcf0                           notcr1    
  697 A:fcf0  e8                                 inx                    ; advance input index
  698 A:fcf1  d0 16                              bne nxtchar
  699 A:fcf3                           cancel    
  699 A:fcf3  a9 5c                              lda #'\'             ; backslash after cancelled LTN?
  700 A:fcf5  20 82 fd                           jsr cout
  701 A:fcf8                           getlnz    
  701 A:fcf8  20 23 fd                           jsr crout                ; output cr
  702 A:fcfb                           getln     
  702 A:fcfb  6c 28 00                           jmp (rdline)
  703 A:fcfe                           getlnw    
  703 A:fcfe  a5 33                              lda prompt
  704 A:fd00  20 82 fd                           jsr cout                ; output prompt char
  705 A:fd03  a2 01                              ldx #$01             ; init input index
  706 A:fd05                           bckspc    
  706 A:fd05  8a                                 txa                    ;   will backspace to u
  707 A:fd06  f0 f0                              beq getlnz
  708 A:fd08  ca                                 dex 
  709 A:fd09                           nxtchar   
  709 A:fd09  20 c6 fc                           jsr rdchar
  710 A:fd0c  c9 15                              cmp #k_ctl_u               ; use screen char
  711 A:fd0e  d0 03                              bne captst                ;  for ctrl-u
  712 A:fd10  ad 12 c0                           lda termout                ; get char under cursor
  713 A:fd13                           captst    
  713 A:fd13  c9 60                              cmp #$60
  714 A:fd15  90 02                              bcc addinp                ; convert to caps; for now..
  715 A:fd17  29 df                              and #$df
  716 A:fd19                           addinp    
  716 A:fd19  9d 00 02                           sta in,x              ; add to input buffer
  717 A:fd1c  c9 0a                              cmp #k_entr
  718 A:fd1e  d0 ae                              bne notcr
  719 A:fd20  20 1f fc                           jsr clreol                ; clear to eol if cr

  721 A:fd23                           crout     
  721 A:fd23  a9 0a                              lda #k_entr
  722 A:fd25  d0 5b                              bne cout                ; branches always ?!?
  723 A:fd27                           pra1      
  723 A:fd27  a4 3d                              ldy a1h                ; print CR,A1 in hex
  724 A:fd29  a6 3c                              ldx a1l
  725 A:fd2b                                    ;
  726 A:fd2b                                    ; print address header at start of line
  727 A:fd2b                                    ; yyxx-
  728 A:fd2b                                    ;
  729 A:fd2b                           pryx2     
  729 A:fd2b  20 23 fd                           jsr crout
  730 A:fd2e  20 20 f9                           jsr prntyx
  731 A:fd31  a0 00                              ldy #$00
  732 A:fd33  a9 2d                              lda #'-'             ; print '-'
  733 A:fd35  4c 82 fd                           jmp cout
  734 A:fd38                                    ;
  735 A:fd38                                    ; Examine 8 bytes at address
  736 A:fd38                                    ; Triggered by command xxxx.yyyy
  737 A:fd38                                    ;
  738 A:fd38                           xam8      
  738 A:fd38  a5 3c                              lda a1l
  739 A:fd3a  09 07                              ora #$07             ; set to finish at
  740 A:fd3c  85 3e                              sta a2l                ;   mod 8=7
  741 A:fd3e  a5 3d                              lda a1h
  742 A:fd40  85 3f                              sta a2h
  743 A:fd42                           mod8chk   
  743 A:fd42  a5 3c                              lda a1l
  744 A:fd44  29 07                              and #$07
  745 A:fd46  d0 03                              bne dataout
  746 A:fd48                                    ;
  747 A:fd48                                    ; Examine byte at address
  748 A:fd48                                    ;
  749 A:fd48                           xam       
  749 A:fd48  20 27 fd                           jsr pra1
  750 A:fd4b                           dataout   
  750 A:fd4b  a9 20                              lda #' '
  751 A:fd4d  20 82 fd                           jsr cout                ; output blank
  752 A:fd50  b1 3c                              lda (a1l),y
  753 A:fd52  20 6f fd                           jsr prbyte                ; print byte in hex
  754 A:fd55  20 37 fc                           jsr nxta1
  755 A:fd58  90 e8                              bcc mod8chk                ; check if time to,
  756 A:fd5a  60                                 rts                    ;  print address
  757 A:fd5b                           xampm     
  757 A:fd5b  4a                                 lsr                    ; determine if mon
  758 A:fd5c  90 ea                              bcc xam                ;  mode is xam
  759 A:fd5e  4a                                 lsr                    ;  add or sub
  760 A:fd5f  4a                                 lsr 
  761 A:fd60  a5 3e                              lda a2l
  762 A:fd62  90 02                              bcc add
  763 A:fd64  49 ff                              eor #$ff             ; sub - form 2's complement
  764 A:fd66                           add       
  764 A:fd66  65 3c                              adc a1l
  765 A:fd68  48                                 pha 
  766 A:fd69  a9 3d                              lda #'='             ; print '=' the result
  767 A:fd6b  20 82 fd                           jsr cout
  768 A:fd6e  68                                 pla 
  769 A:fd6f                                    ;
  770 A:fd6f                                    ; print byte as 2 hex digits
  771 A:fd6f                                    ;
  772 A:fd6f                           prbyte    
  772 A:fd6f  48                                 pha                    ; save a for second half
  773 A:fd70  4a                                 lsr                    ; shift 4 high digits into low nibble, destroys accu
  774 A:fd71  4a                                 lsr 
  775 A:fd72  4a                                 lsr 
  776 A:fd73  4a                                 lsr 
  777 A:fd74  20 7a fd                           jsr prhexz                ; first hex per subroutine,
  778 A:fd77  68                                 pla                    ;   second hex direct, reuse rts for prbyte
  779 A:fd78                           prhex     
  779 A:fd78  29 0f                              and #$0f             ; print hex digit in accu
  780 A:fd7a                                    ;
  781 A:fd7a                                    ; print lower accu nibble as hex number
  782 A:fd7a                                    ;
  783 A:fd7a                           prhexz    
  783 A:fd7a  09 30                              ora #$30             ;   lsb's
  784 A:fd7c  c9 3a                              cmp #$3a
  785 A:fd7e  90 02                              bcc cout
  786 A:fd80  69 06                              adc #$06             ; afterwards, flow into cout
  787 A:fd82                                    ;
  788 A:fd82                                    ; Character out to screen
  789 A:fd82                                    ; go through cswl zero page vector
  790 A:fd82                                    ;
  791 A:fd82                           cout      
  791 A:fd82  6c 36 00                           jmp (cswl)              ; vector to user output routine
  792 A:fd85                                    ;
  793 A:fd85                                    ; Standard cswl character out routine
  794 A:fd85                                    ;
  795 A:fd85                           cout1     
  795 A:fd85  84 35                              sty ysav1                ; save the y register
  796 A:fd87  48                                 pha                    ; save A
  797 A:fd88  20 be fb                           jsr vidout                ; output a as ascii
  798 A:fd8b  68                                 pla                    ; restore A
  799 A:fd8c  a4 35                              ldy ysav1                ; restore y and return
  800 A:fd8e  60                                 rts 
  801 A:fd8f                                    ;
  802 A:fd8f                                    ; on blank / return, execute preceding command
  803 A:fd8f                                    ;
  804 A:fd8f                           bli       
  804 A:fd8f  c6 34                              dec ysav
  805 A:fd91  f0 a5                              beq xam8
  806 A:fd93                           blank     
  806 A:fd93  ca                                 dex                    ; blank to mon
  807 A:fd94  d0 16                              bne setmdz                ; after blank
  808 A:fd96  c9 3a                              cmp #':'             ; data store mode?
  809 A:fd98  d0 c1                              bne xampm                ;   no, xam, add or sub
  810 A:fd9a                           stor      
  810 A:fd9a  85 31                              sta mode                ; keep in store mode
  811 A:fd9c  a5 3e                              lda a2l
  812 A:fd9e  91 40                              sta (a3l),y            ; store as low byte as (a3)
  813 A:fda0  e6 40                              inc a3l
  814 A:fda2  d0 02                              bne rts5                ; incr a3, return
  815 A:fda4  e6 41                              inc a3h
  816 A:fda6                           rts5      
  816 A:fda6  60                                 rts 
  817 A:fda7                                    ;
  818 A:fda7                                    ; set the command mode
  819 A:fda7                                    ;
  820 A:fda7                           setmode   
  820 A:fda7  a4 34                              ldy ysav                ; save converted colon, '+',
  821 A:fda9  b9 ff 01                           lda in-1,y          ;  '-', '.' as mode.
  822 A:fdac                           setmdz    
  822 A:fdac  85 31                              sta mode
  823 A:fdae  60                                 rts 
  824 A:fdaf                                    ;
  825 A:fdaf                                    ; '<' command for move / verify
  826 A:fdaf                                    ; initialize zero page variables for following V/M command
  827 A:fdaf                                    ;
  828 A:fdaf                           lt        
  828 A:fdaf  a2 01                              ldx #$01
  829 A:fdb1                           lt2       
  829 A:fdb1  b5 3e                              lda a2l,x              ; copy a2 (2 bytes) to
  830 A:fdb3  95 42                              sta a4l,x              ;   a4 and a5
  831 A:fdb5  95 44                              sta a5l,x
  832 A:fdb7  ca                                 dex 
  833 A:fdb8  10 f7                              bpl lt2
  834 A:fdba  60                                 rts 
  835 A:fdbb                                    ;
  836 A:fdbb                                    ; copy memory range
  837 A:fdbb                                    ;
  838 A:fdbb                           move      
  838 A:fdbb  b1 3c                              lda (a1l),y            ; move (a1 to a2) to
  839 A:fdbd  91 42                              sta (a4l),y            ;   (a4)
  840 A:fdbf  20 31 fc                           jsr nxta4                ; y is set to 0 in zmode. there is no address
  841 A:fdc2  90 f7                              bcc move                ;  mode for zero indirect without y, and move
  842 A:fdc4  60                                 rts                    ;  must work with ranges > 255
  843 A:fdc5                                    ;
  844 A:fdc5                                    ; verify that two memory ranges have same content
  845 A:fdc5                                    ;
  846 A:fdc5                           vfy       
  846 A:fdc5  b1 3c                              lda (a1l),y            ; verify (a1 to a2) with
  847 A:fdc7  d1 42                              cmp (a4l),y            ;   (a4)
  848 A:fdc9  f0 1c                              beq vfyok
  849 A:fdcb  20 27 fd                           jsr pra1
  850 A:fdce  b1 3c                              lda (a1l),y
  851 A:fdd0  20 6f fd                           jsr prbyte
  852 A:fdd3  a9 20                              lda #' '             ; space
  853 A:fdd5  20 82 fd                           jsr cout
  854 A:fdd8  a9 28                              lda #'('             ; '('
  855 A:fdda  20 82 fd                           jsr cout
  856 A:fddd  b1 42                              lda (a4l),y
  857 A:fddf  20 6f fd                           jsr prbyte
  858 A:fde2  a9 29                              lda #')'             ; ')'
  859 A:fde4  20 82 fd                           jsr cout
  860 A:fde7                           vfyok     
  860 A:fde7  20 31 fc                           jsr nxta4
  861 A:fdea  90 d9                              bcc vfy
  862 A:fdec  60                                 rts 
  863 A:fded                                    ;
  864 A:fded                                    ; list memory range as assembler
  865 A:fded                                    ;
  866 A:fded                           list      
  866 A:fded  20 04 fe                           jsr a1pc                ; move a1 (2 bytes) to
  867 A:fdf0  a9 14                              lda #$14             ;  pc if specified and
  868 A:fdf2                           list2     
  868 A:fdf2  48                                 pha                    ;  dissemble 20 instructions
  869 A:fdf3  20 b0 f8                           jsr instdsp
  870 A:fdf6  20 33 f9                           jsr pcadj                ; adjust pc each instruction
  871 A:fdf9  85 3a                              sta pcl
  872 A:fdfb  84 3b                              sty pch
  873 A:fdfd  68                                 pla 
  874 A:fdfe  38                                 sec 
  875 A:fdff  e9 01                              sbc #$01             ; next 20 instr.
  876 A:fe01  d0 ef                              bne list2
  877 A:fe03  60                                 rts 
  878 A:fe04                           a1pc      
  878 A:fe04  8a                                 txa                    ; if user specified address
  879 A:fe05  f0 07                              beq a1pcrts                ;   copy from a1 to pc
  880 A:fe07                           a1pclp    
  880 A:fe07  b5 3c                              lda a1l,X
  881 A:fe09  95 3a                              sta pcl,x
  882 A:fe0b  ca                                 dex 
  883 A:fe0c  10 f9                              bpl a1pclp
  884 A:fe0e                           a1pcrts   
  884 A:fe0e  60                                 rts 
  885 A:fe0f                                    ;
  886 A:fe0f                                    ; set inverse character mode
  887 A:fe0f                                    ;
  888 A:fe0f                           setinv    
  888 A:fe0f  a0 05                              ldy #t_inv               ; set for inverse video
  889 A:fe11  d0 02                              bne setiflg
  890 A:fe13                                    ;
  891 A:fe13                                    ; set norml character mode
  892 A:fe13                                    ;
  893 A:fe13                           setnorm   
  893 A:fe13  a0 04                              ldy #t_norm               ; set for normal video
  894 A:fe15                           setiflg   
  894 A:fe15  84 32                              sty invflg
  895 A:fe17  60                                 rts 
  896 A:fe18                                    ;
  897 A:fe18                                    ; Switch terminal configuration
  898 A:fe18                                    ; Terminal mode in $C01F is 0 when in screen mode,
  899 A:fe18                                    ; and 1 when in stdio mode
  900 A:fe18                                    ;
  901 A:fe18                           termsw    
  901 A:fe18                                    
  902 A:fe18  60                                 rts 
  903 A:fe19                                    ;
  904 A:fe19                                    ; set input port to standard keyboard
  905 A:fe19                                    ;
  906 A:fe19                           setkbd    
  906 A:fe19  a9 00                              lda #$00             ; simulate port #0 input
  907 A:fe1b                           inport    
  907 A:fe1b  85 3e                              sta a2l                ;   specified (keyin routine)
  908 A:fe1d                           inprt     
  908 A:fe1d                                     .( 
  909 A:fe1d  a2 38                              ldx #kswl
  910 A:fe1f  ad 1f c0                           lda termmd                ; window mode - 0, stdio mode - 1
  911 A:fe22  d0 09                              bne inprt3                ; stdio
  912 A:fe24  a0 ae                              ldy #<keyin
  913 A:fe26  a9 fc                              lda #>keyin
  914 A:fe28  85 3f                              sta a2h                ; default msb
  915 A:fe2a  4c 6d fe                           jmp ioprt
  916 A:fe2d                           inprt3    
  916 A:fe2d  a0 25                              ldy #<stdin              ; load stdout vector
  917 A:fe2f  a9 f8                              lda #>stdin              ; y lsb of cout1 standard vector
  918 A:fe31  85 3f                              sta a2h                ; default msb
  919 A:fe33  4c 6d fe                           jmp ioprt
  920 A:fe36                                     .) 
  921 A:fe36                                    ;
  922 A:fe36                                    ; set input port to standard keyboard
  923 A:fe36                                    ;
  924 A:fe36                           setrdl    
  924 A:fe36  a9 00                              lda #$00             ; simulate port #0 input
  925 A:fe38                           rdport    
  925 A:fe38  85 3e                              sta a2l                ;   specified (keyin routine)
  926 A:fe3a                           rdprt     
  926 A:fe3a                                     .( 
  927 A:fe3a  a2 28                              ldx #rdline
  928 A:fe3c  ad 1f c0                           lda termmd                ; window mode - 0, stdio mode - 1
  929 A:fe3f  d0 09                              bne rdprt3                ; stdio
  930 A:fe41  a0 fe                              ldy #<getlnw
  931 A:fe43  a9 fc                              lda #>getlnw
  932 A:fe45  85 3f                              sta a2h                ; default msb
  933 A:fe47  4c 6d fe                           jmp ioprt
  934 A:fe4a                           rdprt3    
  934 A:fe4a  a0 29                              ldy #<stdrdln              ; load stdout vector
  935 A:fe4c  a9 f8                              lda #>stdrdln              ; y lsb of cout1 standard vector
  936 A:fe4e  85 3f                              sta a2h                ; default msb
  937 A:fe50  4c 6d fe                           jmp ioprt
  938 A:fe53                                     .) 
  939 A:fe53                                    ;
  940 A:fe53                                    ; Set output port to standard terminal
  941 A:fe53                                    ;
  942 A:fe53                           setvid    
  942 A:fe53  a9 00                              lda #$00             ; simulate port #0 output
  943 A:fe55                           outport   
  943 A:fe55  85 3e                              sta a2l                ;   specified (cout routine)
  944 A:fe57                           outprt    
  944 A:fe57                                     .( 
  945 A:fe57  a2 36                              ldx #cswl               ; x has zero page location for cout vector
  946 A:fe59  ad 1f c0                           lda termmd                ; window mode - 0, stdio mode - 1
  947 A:fe5c  d0 09                              bne outprt3                ; stdio
  948 A:fe5e  a0 85                              ldy #<cout1
  949 A:fe60  a9 fd                              lda #>cout1
  950 A:fe62  85 3f                              sta a2h                ; default msb
  951 A:fe64  4c 6d fe                           jmp ioprt
  952 A:fe67                           outprt3   
  952 A:fe67  a0 43                              ldy #<stdout              ; load stdout vector
  953 A:fe69  a9 f8                              lda #>stdout              ; y lsb of cout1 standard vector
  954 A:fe6b  85 3f                              sta a2h                ; default msb
  955 A:fe6d                                     .) 
  956 A:fe6d                                    ;
  957 A:fe6d                                    ; set either internal or peripheral port
  958 A:fe6d                                    ; a2l contains a port number 0-7
  959 A:fe6d                                    ; a2l = 0 - use internal port
  960 A:fe6d                                    ; a2l > 0 - It is a peripheral, the msb of the address is
  961 A:fe6d                                    ; 0xCn where n is peripheral #1-7
  962 A:fe6d                                    ;
  963 A:fe6d                           ioprt     
  963 A:fe6d  a5 3e                              lda a2l                ; set ram in/out vectors
  964 A:fe6f  29 0f                              and #$0f
  965 A:fe71  f0 06                              beq ioprt1
  966 A:fe73  09 c0                              ora #>ioadr              ; high byte
  967 A:fe75  a0 00                              ldy #$00
  968 A:fe77  f0 02                              beq ioprt2
  969 A:fe79                           ioprt1    
  969 A:fe79  a5 3f                              lda a2h
  970 A:fe7b                           ioprt2    
  970 A:fe7b  94 00                              sty loc0,x
  971 A:fe7d  95 01                              sta loc1,x
  972 A:fe7f  60                                 rts 
  973 A:fe80                                    ;
  974 A:fe80                                    ; execute installed language
  975 A:fe80                                    ;
  976 A:fe80                           x_lang    
  976 A:fe80  4c 00 e0                           jmp lang
  977 A:fe83                                    ; soft entry vector for installed language
  978 A:fe83                           bascont   
  978 A:fe83  4c 03 e0                           jmp lang2
  979 A:fe86                           go        
  979 A:fe86  20 04 fe                           jsr a1pc                ; adr to pc if specified
  980 A:fe89  20 1d ff                           jsr restore                ; restore meta registers
  981 A:fe8c  6c 3a 00                           jmp (pcl)              ; go to user subroutine
  982 A:fe8f                           regz      
  982 A:fe8f  4c b7 fa                           jmp regdsp                ; jump to register display
  983 A:fe92                                    ;
  984 A:fe92                                    ; trace command
  985 A:fe92                                    ;
  986 A:fe92                           trace     
  986 A:fe92  c6 34                              dec ysav
  987 A:fe94                           stepz     
  987 A:fe94  20 04 fe                           jsr a1pc                ; adr to pc if specified
  988 A:fe97  4c 23 fa                           jmp step                ; take one step
  989 A:fe9a                                    ;
  990 A:fe9a                                    ; execute user command
  991 A:fe9a                                    ; 
  992 A:fe9a                           usr       
  992 A:fe9a  4c f8 03                           jmp usradr                ; to usr subroutine at usradr
  993 A:fe9d                                    ;
  994 A:fe9d                                    ; write memory range to tape OUT
  995 A:fe9d                                    ;
  996 A:fe9d                           write     
  996 A:fe9d  a9 00                              lda #$00             ; set header to WRITE
  997 A:fe9f  85 26                              sta tpdir
  998 A:fea1  a9 40                              lda #$40
  999 A:fea3  20 46 fc                           jsr headr                ; write 10-sec header
 1000 A:fea6  a0 27                              ldy #$27
 1001 A:fea8                           wr1       
 1001 A:fea8  a2 00                              ldx #$00
 1002 A:feaa  41 3c                              eor (a1l,x)
 1003 A:feac  48                                 pha 
 1004 A:fead  a1 3c                              lda (a1l,x)
 1005 A:feaf  20 c4 fe                           jsr wrbyte
 1006 A:feb2  20 37 fc                           jsr nxta1
 1007 A:feb5  a0 1d                              ldy #$1d
 1008 A:feb7  68                                 pla 
 1009 A:feb8  90 ee                              bcc wr1
 1010 A:feba  a0 22                              ldy #$22
 1011 A:febc  20 c4 fe                           jsr wrbyte
 1012 A:febf  ad 22 c0                           lda tapecls                ; close tape
 1013 A:fec2  f0 54                              beq bell                ; sound bell and return
 1014 A:fec4                           wrbyte    
 1014 A:fec4  a2 10                              ldx #$10
 1015 A:fec6                           wrbyt2    
 1015 A:fec6  0a                                 asl 
 1016 A:fec7  20 53 fc                           jsr wrbit
 1017 A:feca  d0 fa                              bne wrbyt2
 1018 A:fecc  60                                 rts 
 1019 A:fecd                                    ;
 1020 A:fecd                                    ; execute command line
 1021 A:fecd                                    ;
 1022 A:fecd                           crmon     
 1022 A:fecd  20 8f fd                           jsr bli                ; handle CR as blank
 1023 A:fed0  68                                 pla                    ;  then pop stack
 1024 A:fed1  68                                 pla                    ; and return to mon
 1025 A:fed2  d0 76                              bne monz
 1026 A:fed4                                    ;
 1027 A:fed4                                    ; read memory area from tape IN
 1028 A:fed4                                    ;
 1029 A:fed4                                    ; first synchronize timing with the header block,
 1030 A:fed4                                    ; Then read bytes and check checksum
 1031 A:fed4                                    ; 1s and 0s have different lengths, so number and frequency 
 1032 A:fed4                                    ; of machine cycles is important for executing this
 1033 A:fed4                                    ;
 1034 A:fed4                           read      
 1034 A:fed4  a9 01                              lda #$01             ; set header to READ
 1035 A:fed6  85 26                              sta tpdir
 1036 A:fed8  20 7b fc                           jsr rd2bit                ; find tapein edge
 1037 A:fedb  a9 16                              lda #$16
 1038 A:fedd  20 46 fc                           jsr headr                ; delay 3.5s
 1039 A:fee0  85 2e                              sta chksum                ; init checksum = $FF
 1040 A:fee2  20 7b fc                           jsr rd2bit                ; find tapein edge
 1041 A:fee5                           rd2       
 1041 A:fee5  a0 24                              ldy #$24             ; look for sync bit
 1042 A:fee7  20 7e fc                           jsr rdbit                ; (short 0)
 1043 A:feea  b0 f9                              bcs rd2                ; loop until found
 1044 A:feec  20 7e fc                           jsr rdbit                ; skip second sync h-cycle
 1045 A:feef  a0 3b                              ldy #$3b             ; index for 0/1 test
 1046 A:fef1                           rd3       
 1046 A:fef1  20 6d fc                           jsr rdbyte                ; read a byte
 1047 A:fef4  81 3c                              sta (a1l,x)            ; store at (a1)
 1048 A:fef6  45 2e                              eor chksum
 1049 A:fef8  85 2e                              sta chksum                ; update running checksum
 1050 A:fefa  20 37 fc                           jsr nxta1                ; incr a1, compare to a2
 1051 A:fefd  a0 35                              ldy #$35             ; compensate 0/1 index
 1052 A:feff  90 f0                              bcc rd3                ; loop until done
 1053 A:ff01  20 6d fc                           jsr rdbyte                ; read chksum byte
 1054 A:ff04  ac 22 c0                           ldy tapecls                ; close tape
 1055 A:ff07  c5 2e                              cmp chksum
 1056 A:ff09  f0 0d                              beq bell                ; good, sound bell and return
 1057 A:ff0b                                    ;
 1058 A:ff0b                                    ; print "ERR" and beep
 1059 A:ff0b                                    ;
 1060 A:ff0b                           prerr     
 1060 A:ff0b  a9 c5                              lda #$c5             ; 'E'
 1061 A:ff0d  20 82 fd                           jsr cout                ; print "ERR" then bell
 1062 A:ff10  a9 d2                              lda #$d2             ; 'R'
 1063 A:ff12  20 82 fd                           jsr cout
 1064 A:ff15  20 82 fd                           jsr cout
 1065 A:ff18                                    ;
 1066 A:ff18                                    ; ring the terminal bell
 1067 A:ff18                                    ;
 1068 A:ff18                           bell      
 1068 A:ff18  a9 07                              lda #k_ctl_g               ; output bell and return
 1069 A:ff1a  4c 82 fd                           jmp cout                ; reuse cout rts directly here...
 1070 A:ff1d                                    ;
 1071 A:ff1d                                    ; restore registers from zero page storage
 1072 A:ff1d                                    ;
 1073 A:ff1d                           restore   
 1073 A:ff1d  a5 48                              lda status                ; restore 6502 register contents
 1074 A:ff1f  48                                 pha                    ;  used by debug software
 1075 A:ff20  a5 45                              lda acc
 1076 A:ff22                           restr1    
 1076 A:ff22  a6 46                              ldx xreg
 1077 A:ff24  a4 47                              ldy yreg
 1078 A:ff26  28                                 plp 
 1079 A:ff27  60                                 rts 
 1080 A:ff28                                    ;
 1081 A:ff28                                    ; save 6502 reg contents to zero page storage
 1082 A:ff28                                    ;
 1083 A:ff28                           save      
 1083 A:ff28  85 45                              sta acc
 1084 A:ff2a                           sav1      
 1084 A:ff2a  86 46                              stx xreg
 1085 A:ff2c  84 47                              sty yreg
 1086 A:ff2e  08                                 php 
 1087 A:ff2f  68                                 pla 
 1088 A:ff30  85 48                              sta status
 1089 A:ff32  ba                                 tsx 
 1090 A:ff33  86 49                              stx spnt
 1091 A:ff35  d8                                 cld 
 1092 A:ff36  60                                 rts 
 1093 A:ff37                                    ;
 1094 A:ff37                                    ; 6502 reset vector
 1095 A:ff37                                    ;
 1096 A:ff37                           reset     
 1096 A:ff37  20 13 fe                           jsr setnorm
 1097 A:ff3a  20 0f fb                           jsr init
 1098 A:ff3d  20 53 fe                           jsr setvid
 1099 A:ff40  20 19 fe                           jsr setkbd
 1100 A:ff43  20 36 fe                           jsr setrdl
 1101 A:ff46                                    ;
 1102 A:ff46                                    ; Monitor entry point
 1103 A:ff46                                    ;
 1104 A:ff46                           mon       
 1104 A:ff46  d8                                 cld 
 1105 A:ff47  20 18 ff                           jsr bell
 1106 A:ff4a                           monz      
 1106 A:ff4a  a9 2a                              lda #'*'             ; Monitor prompt
 1107 A:ff4c  85 33                              sta prompt
 1108 A:ff4e  20 f8 fc                           jsr getlnz                ; get line
 1109 A:ff51  20 ad ff                           jsr zmode                ; clear monitor mode, scan idx
 1110 A:ff54                                    ;
 1111 A:ff54                                    ; get the next item from input line
 1112 A:ff54                                    ;
 1113 A:ff54                           nxtitm    
 1113 A:ff54  20 88 ff                           jsr getnum                ; get item, non-hex
 1114 A:ff57  84 34                              sty ysav
 1115 A:ff59  a0 18                              ldy #$18             ; x-reg=0 if no hex input
 1116 A:ff5b                                    ;
 1117 A:ff5b                                    ; look up command subroutine for current character
 1118 A:ff5b                                    ;
 1119 A:ff5b                           chrsrch   
 1119 A:ff5b  88                                 dey 
 1120 A:ff5c  30 e8                              bmi mon                ; not found, go to mon
 1121 A:ff5e  d9 b2 ff                           cmp chrtbl,y              ; find cmnd char in table
 1122 A:ff61  d0 f8                              bne chrsrch
 1123 A:ff63  20 9f ff                           jsr tosub                ; found call corresponding subroutine
 1124 A:ff66  a4 34                              ldy ysav
 1125 A:ff68  4c 54 ff                           jmp nxtitm
 1126 A:ff6b                                    ;
 1127 A:ff6b                                    ; get one hex digit from input
 1128 A:ff6b                                    ;
 1129 A:ff6b                           dig       
 1129 A:ff6b  a2 03                              ldx #$03
 1130 A:ff6d  0a                                 asl 
 1131 A:ff6e  0a                                 asl                    ; got hex digit in low nibble, shift into A2
 1132 A:ff6f  0a                                 asl 
 1133 A:ff70  0a                                 asl                    ; first, position in high nibble of accu
 1134 A:ff71                           nxtbit    
 1134 A:ff71  0a                                 asl                    ; transport a high bit to carry
 1135 A:ff72  26 3e                              rol a2l                ; rotate carry into low byte into carry
 1136 A:ff74  26 3f                              rol a2h                ; rotate carry into high byte
 1137 A:ff76  ca                                 dex                    ; leave x = $FF if digit
 1138 A:ff77  10 f8                              bpl nxtbit
 1139 A:ff79                           nxtbas    
 1139 A:ff79  a5 31                              lda mode
 1140 A:ff7b  d0 06                              bne nxtbs2                ;   if mode is zero
 1141 A:ff7d  b5 3f                              lda a2h,x              ;    then copy a2 to
 1142 A:ff7f  95 3d                              sta a1h,x              ;     a1 and a3
 1143 A:ff81  95 41                              sta a3h,x
 1144 A:ff83                           nxtbs2    
 1144 A:ff83  e8                                 inx 
 1145 A:ff84  f0 f3                              beq nxtbas
 1146 A:ff86  d0 06                              bne nxtchr
 1147 A:ff88                                    ;
 1148 A:ff88                                    ; getnum read command
 1149 A:ff88                                    ; result
 1149 A:ff88                                    
 1150 A:ff88                                    ;   a - mode
 1151 A:ff88                                    ;   x - number of numeric args
 1152 A:ff88                                    ;
 1153 A:ff88                           getnum    
 1153 A:ff88  a2 00                              ldx #$00             ;  clear A2
 1154 A:ff8a  86 3f                              stx a2h
 1155 A:ff8c  86 3e                              stx a2l
 1156 A:ff8e                           nxtchr    
 1156 A:ff8e  b9 00 02                           lda in,y              ; get char
 1157 A:ff91  c8                                 iny 
 1158 A:ff92  49 30                              eor #$30             ; $30 0 -> $00; $39 9 -> $09; $41 A -> $71; $20 -> $10...
 1159 A:ff94  c9 0a                              cmp #$0a
 1160 A:ff96  90 d3                              bcc dig                ; if hex digit
 1161 A:ff98  69 88                              adc #$88             ; c=1, $76 F + $88 + 1 = $FF; $71 A + $88 + 1 = $FA
 1162 A:ff9a  c9 fa                              cmp #$fa
 1163 A:ff9c  b0 cd                              bcs dig                ; if not a digit a now has ch eor #$30 + $B9
 1164 A:ff9e  60                                 rts 
 1165 A:ff9f                                    ;
 1166 A:ff9f                                    ; Go to command routine
 1167 A:ff9f                                    ;
 1168 A:ff9f                           tosub     
 1168 A:ff9f  98                                 tya 
 1169 A:ffa0  0a                                 asl                    ; subroutine table has 16 bit addresses now.
 1170 A:ffa1  a8                                 tay                    ; to much fumbling making them all stay on page $FE
 1171 A:ffa2  b9 ca ff                           lda subtbl,y              ; Push high order subroutine address on stack
 1172 A:ffa5  c8                                 iny 
 1173 A:ffa6  48                                 pha 
 1174 A:ffa7  b9 ca ff                           lda subtbl,y              ; Push low order subroutine address on stack
 1175 A:ffaa  48                                 pha 
 1176 A:ffab  a5 31                              lda mode                ;  old mode to A
 1177 A:ffad                                    ;
 1178 A:ffad                                    ; clear the y flag and the current mode for next subsequence
 1179 A:ffad                                    ;
 1180 A:ffad                           zmode     
 1180 A:ffad  a0 00                              ldy #$00             ; clear y
 1181 A:ffaf  84 31                              sty mode                ; clear mode
 1182 A:ffb1  60                                 rts                    ; go to command subroutine previously pushed on the stack

 1184 A:ffb2                           chrtbl    
 1184 A:ffb2  ea                                 .byt ((('Q'^$30)+$89)&$ff)
 1185 A:ffb3  bc                                 .byt (((k_ctl_c^$30)+$89)&$ff)
 1186 A:ffb4  b2                                 .byt (((k_ctl_y^$30)+$89)&$ff)
 1187 A:ffb5  be                                 .byt (((k_ctl_e^$30)+$89)&$ff)
 1188 A:ffb6  ed                                 .byt ((('T'^$30)+$89)&$ff)
 1189 A:ffb7  ef                                 .byt ((('V'^$30)+$89)&$ff)
 1190 A:ffb8  c4                                 .byt (((k_ctl_k^$30)+$89)&$ff)
 1191 A:ffb9  ec                                 .byt ((('S'^$30)+$89)&$ff)
 1192 A:ffba  a9                                 .byt (((k_ctl_p^$30)+$89)&$ff)
 1193 A:ffbb  bb                                 .byt (((k_ctl_b^$30)+$89)&$ff)
 1194 A:ffbc  a6                                 .byt ((('-'^$30)+$89)&$ff)
 1195 A:ffbd  a4                                 .byt ((('+'^$30)+$89)&$ff)
 1196 A:ffbe  06                                 .byt ((('M'^$30)+$89)&$ff)
 1197 A:ffbf  95                                 .byt ((('<'^$30)+$89)&$ff)
 1198 A:ffc0  07                                 .byt ((('N'^$30)+$89)&$ff)
 1199 A:ffc1  02                                 .byt ((('I'^$30)+$89)&$ff)
 1200 A:ffc2  05                                 .byt ((('L'^$30)+$89)&$ff)
 1201 A:ffc3  f0                                 .byt ((('W'^$30)+$89)&$ff)
 1202 A:ffc4  00                                 .byt ((('G'^$30)+$89)&$ff)
 1203 A:ffc5  eb                                 .byt ((('R'^$30)+$89)&$ff)
 1204 A:ffc6  93                                 .byt (((':'^$30)+$89)&$ff)
 1205 A:ffc7  a7                                 .byt ((('.'^$30)+$89)&$ff)
 1206 A:ffc8  c3                                 .byt (((k_entr^$30)+$89)&$ff)
 1207 A:ffc9  99                                 .byt (((' '^$30)+$89)&$ff)
 1208 A:ffca                                    ; Monitor commands
 1208 A:ffca                                    
 1209 A:ffca                                    ; 'Q'           terminate emulator by jumping to $FFFF. When PC=$FFFF, the cpu loop terminates.
 1210 A:ffca                                    ; ctrl-c        bascont
 1211 A:ffca                                    ; ctrl-y        usr
 1212 A:ffca                                    ; ctrl-e        regz
 1213 A:ffca                                    ; 'T'           trace
 1214 A:ffca                                    ; 'V'           vfy
 1215 A:ffca                                    ; ctrl-k        inprt
 1216 A:ffca                                    ; 'S'           stepz
 1217 A:ffca                                    ; ctrl-p        outprt
 1218 A:ffca                                    ; ctrl-b        x_lang
 1219 A:ffca                                    ; '-'           setmode
 1220 A:ffca                                    ; '+'           setmode
 1221 A:ffca                                    ; 'M'           move
 1222 A:ffca                                    ; '<'           lt
 1223 A:ffca                                    ; 'N'           setnorm
 1224 A:ffca                                    ; 'I'           setinv
 1225 A:ffca                                    ; 'L'           list
 1226 A:ffca                                    ; 'W'           write
 1227 A:ffca                                    ; 'G'           go
 1228 A:ffca                                    ; 'R'           read
 1229 A:ffca                                    ; colon         write area addr1,addr2
 1230 A:ffca                                    ; '.'           hexdump addr1,addr2
 1231 A:ffca                                    ; enter         execute monitor command line
 1232 A:ffca                                    ; ' '           add preceding command to line
 1233 A:ffca                                    ;
 1234 A:ffca                                    ; table must have msb first lsb second
 1235 A:ffca                                    ;

 1237 A:ffca                           subtbl    
 1237 A:ffca  f8 1f                              .byt >exit,<exit          ; Q - Quit emulator
 1238 A:ffcc  fe 83                              .byt >bascont,<bascont          ; CTL-C - exit moitor to installed language
 1239 A:ffce  fe 9a                              .byt >usr,<usr          ; CTL-Y - execute user command at vector %3F8
 1240 A:ffd0  fe 8f                              .byt >regz,<regz          ; CTL-E - examine registers
 1241 A:ffd2  fe 92                              .byt >trace,<trace          ; "T" - Trace until reset or brk
 1242 A:ffd4  fd c5                              .byt >vfy,<vfy          ; "V" - Verify memory range
 1243 A:ffd6  fe 1d                              .byt >inprt,<inprt          ; [0-7] CTL-K - input from keyboard (0) or peripheral card 1-7
 1244 A:ffd8  fe 94                              .byt >stepz,<stepz          ; "S" - Step
 1245 A:ffda  fe 57                              .byt >outprt,<outprt          ; [0-7] CTL-P - send output to video (0) or printer peripheral 1-7
 1246 A:ffdc  fe 80                              .byt >x_lang,<x_lang          ; CTL-B -
 1247 A:ffde  fd a7                              .byt >setmode,<setmode          ; "-" - hexadecimal substraction
 1248 A:ffe0  fd a7                              .byt >setmode,<setmode          ; "+" - hexadecimal addition
 1249 A:ffe2  fd bb                              .byt >move,<move          ; "M" - mpve memory range
 1250 A:ffe4  fd af                              .byt >lt,<lt          ; "< aaaa.bbbb M|V" - Move / compare memory range
 1251 A:ffe6  fe 13                              .byt >setnorm,<setnorm          ; "N" - set to normal output
 1252 A:ffe8  fe 0f                              .byt >setinv,<setinv          ; "I" - set to inverse output
 1253 A:ffea  fd ed                              .byt >list,<list          ; "L" - list preceding memory add
 1254 A:ffec  fe 9d                              .byt >write,<write          ; "aaaa.bbbb W" - Save memory range on tape
 1255 A:ffee  fe 86                              .byt >go,<go          ; "aaaa G" - Run program as subroutine at aaaa
 1256 A:fff0  fe d4                              .byt >read,<read          ; "aaaa.bbbb R" - Read memory range from tape
 1257 A:fff2  fd a7                              .byt >setmode,<setmode          ; colon xx yy... - change current location. to given ehx bytes
 1258 A:fff4  fd a7                              .byt >setmode,<setmode          ; ".yyyy" - examine bytes between after current position and yyyy
 1259 A:fff6  fe cd                              .byt >crmon,<crmon          ; enter - starts evaluation of commands in input line
 1260 A:fff8  fd 93                              .byt >blank,<blank          ; space separator
 1261 A:fffa                                    ;
 1262 A:fffa                                    ; 6502 fixed system vectors. Must start at 0xFFFA
 1263 A:fffa                                    ; .org not working here, adjusting with
 1264 A:fffa                                    ; .dsb block "keep_aligned" above
 1265 A:fffa                                    ;
 1266 A:fffa                           sysvec_nmi 
 1266 A:fffa  fb 03                              .word nmiloc                ; nmi vector set up in RAM by reset routine
 1267 A:fffc                           sysvec_reset 
 1267 A:fffc  37 ff                              .word reset                ; reset vector
 1268 A:fffe                           sysvec_irq 
 1268 A:fffe  66 fa                              .word irqvec                ; irq vector in rom
